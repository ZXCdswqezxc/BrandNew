-- BrandNew UI Script

--[[
ВАЖНО: Игнорируйте ошибки линтера, связанные с функциями API эксплойта:
- hookmetamethod, checkcaller - функции для работы с метатаблицами
- setNoClip - функция для отключения коллизий
- isfolder, makefolder, listfiles, writefile, readfile, isfile, delfile - функции для работы с файловой системой

Эти функции предоставляются средой выполнения эксплойта и не являются стандартными функциями Luau.
Код работает корректно в среде эксплойта, несмотря на предупреждения линтера.
]]

loadstring(game:HttpGet('https://pastebin.com/raw/gimbTwW1'))() --bypass ac dont touch

-- Загрузка таблицы оптимизации
OptURL = "https://raw.githubusercontent.com/ZXCdswqezxc/BrandNew/refs/heads/main/optimization"
o = loadstring(game:HttpGet(OptURL))() or {}

-- Загрузка UI библиотеки
URL = "https://raw.githubusercontent.com/ZXCdswqezxc/BrandNew/refs/heads/main/cfgmanager"
Library = loadstring(game:HttpGet(URL))()

-- Примечание: Игнорируйте ошибки линтера, связанные с функциями API эксплойта, такими как:
-- hookmetamethod, checkcaller, setNoClip, isfolder, makefolder, listfiles, writefile, readfile, isfile, delfile
-- Эти функции предоставляются средой выполнения эксплойта и не являются стандартными функциями Luau.

-- Темная тема
Library.Theme = {
    Inline = Color3.fromRGB(52, 52, 52),
    Background = Color3.fromRGB(36, 36, 36),
    ["Page Background"] = Color3.fromRGB(22, 22, 22),
    ["Section Background"] = Color3.fromRGB(26, 25, 25),
    ["Dark Background"] = Color3.fromRGB(19, 19, 19),
    Accent = Color3.fromRGB(220, 220, 220),
    ["Dark Text"] = Color3.fromRGB(120, 120, 120),
    ["Light Text"] = Color3.fromRGB(160, 160, 160),
    Text = Color3.fromRGB(220, 220, 220),
}

-- Главное окно
Window = Library:Window({name = "BrandNew", size = UDim2.fromOffset(800, 660), open = true})

-- Вкладки
LegitBotTab = Window:Tab({name = "LegitBot", icon = "rbxassetid://6034996695"})
RageBotTab = Window:Tab({name = "RageBot", icon = "rbxassetid://7733715400"})
VisualsTab = Window:Tab({name = "Visuals", icon = "rbxassetid://6031075931"})
MiscTab = Window:Tab({name = "Misc", icon = "rbxassetid://6031094678"})
PlayerTab = Window:Tab({name = "Player", icon = "rbxassetid://6031068427"})
ConfigTab = Window:Tab({name = "Config", icon = "rbxassetid://6031280882"})

-- Создаем секцию Main во вкладке Visuals
VisualsMainSection = VisualsTab:Section({name = "Main", description = ">_<", side = "right"})

-- Конфигурация трейсеров
local BulletTracersConfig = {
    Enabled = false,  -- Включить/выключить трейсеры (true/false)
    Color1 = Color3.new(1, 1, 1),  -- Начальный цвет трейсера
    Color2 = Color3.new(1, 1, 1),  -- Конечный цвет трейсера
    Thickness = 1,  -- Толщина трейсера
    Texture = "rbxassetid://446111271"  -- Текстура трейсера (Starhook)
}

-- Конфигурация MaterialChams
local MaterialChamsConfig = {
    Self = {
        Enabled = false,
        Material = Enum.Material.ForceField,
        Color = Color3.fromRGB(0, 170, 255),
        OriginalMaterials = {},
        OriginalColors = {}
    },
    Other = {
        Enabled = false,
        Material = Enum.Material.ForceField,
        Color = Color3.fromRGB(255, 0, 0),
        Players = {}
    },
    Friend = {
        Enabled = false,
        Material = Enum.Material.ForceField,
        Color = Color3.fromRGB(0, 255, 0),
        Friends = {}
    }
}

-- Конфигурация HighlightChams
local HighlightChamsConfig = {
    Self = {
        Enabled = false,
        FillColor = Color3.fromRGB(0, 170, 255),
        OutlineColor = Color3.fromRGB(255, 255, 255),
        FillTransparency = 0.5,
        OutlineTransparency = 0,
        DepthMode = Enum.HighlightDepthMode.AlwaysOnTop,
        Highlight = nil
    },
    Other = {
        Enabled = false,
        FillColor = Color3.fromRGB(255, 0, 0),
        OutlineColor = Color3.fromRGB(255, 255, 255),
        FillTransparency = 0.5,
        OutlineTransparency = 0,
        DepthMode = Enum.HighlightDepthMode.AlwaysOnTop,
        Players = {}
    },
    Friend = {
        Enabled = false,
        FillColor = Color3.fromRGB(0, 255, 0),
        OutlineColor = Color3.fromRGB(255, 255, 255),
        FillTransparency = 0.5,
        OutlineTransparency = 0,
        DepthMode = Enum.HighlightDepthMode.AlwaysOnTop,
        Friends = {}
    }
}

-- Загрузка списка друзей
local function loadFriends()
    if not isfile or not readfile then return {} end
    
    if isfile("BrandNew/friends.json") then
        local success, result = pcall(function()
            return game:GetService("HttpService"):JSONDecode(readfile("BrandNew/friends.json"))
        end)
        
        if success then
            return result
        end
    end
    
    return {}
end

-- Сохранение списка друзей
local function saveFriends()
    if not writefile or not makefolder then return end
    
    if not isfolder("BrandNew") then
        makefolder("BrandNew")
    end
    
    local success, result = pcall(function()
        return game:GetService("HttpService"):JSONEncode(MaterialChamsConfig.Friend.Friends)
    end)
    
    if success then
        writefile("BrandNew/friends.json", result)
    end
end

-- Загружаем друзей при запуске
MaterialChamsConfig.Friend.Friends = loadFriends()
HighlightChamsConfig.Friend.Friends = {}

-- Функция для применения SelfChams
local function applySelfChams()
    local LocalPlayer = game:GetService('Players').LocalPlayer
    local Character = LocalPlayer.Character
    if not Character then return end
    
    -- Используем pcall для безопасного выполнения
    pcall(function()
        -- Кэшируем конфиг для быстрого доступа
        local config = MaterialChamsConfig.Self
        local material = config.Material
        local color = config.Color
        
        -- Сохраняем и изменяем материал для всех частей тела
        for _, part in pairs(Character:GetChildren()) do
            if part and part:IsA("BasePart") then
                -- Сохраняем оригинальный материал и цвет, если еще не сохранены
                if not config.OriginalMaterials[part] then
                    config.OriginalMaterials[part] = part.Material
                    config.OriginalColors[part] = part.Color
                end
                
                -- Применяем новый материал и цвет
                part.Material = material
                part.Color = color
            end
            
            -- Обрабатываем аксессуары
            if part and part:IsA("Accessory") then
                local handle = part:FindFirstChild("Handle")
                if handle then
                    if not config.OriginalMaterials[handle] then
                        config.OriginalMaterials[handle] = handle.Material
                        config.OriginalColors[handle] = handle.Color
                    end
                    
                    handle.Material = material
                    handle.Color = color
                end
            end
        end
    end)
end

-- Функция для применения SelfHighlight
local function applySelfHighlight()
    local LocalPlayer = game:GetService('Players').LocalPlayer
    local Character = LocalPlayer.Character
    if not Character then return end
    
    -- Используем pcall для безопасного выполнения
    pcall(function()
        -- Кэшируем конфиг для быстрого доступа
        local config = HighlightChamsConfig.Self
        local highlight = config.Highlight
        
        -- Если Highlight уже существует, просто обновим его настройки вместо пересоздания
        if highlight and highlight.Parent and highlight.Parent:IsDescendantOf(game) then
            -- Обновляем настройки существующего Highlight
            highlight.FillColor = config.FillColor
            highlight.OutlineColor = config.OutlineColor
            highlight.FillTransparency = config.FillTransparency
            highlight.OutlineTransparency = config.OutlineTransparency
            highlight.DepthMode = config.DepthMode
            
            -- Если Adornee изменился (новый персонаж), обновляем его
            if highlight.Adornee ~= Character then
                highlight.Adornee = Character
            end
        else
            -- Удаляем старый хайлайт, если есть
            if highlight and highlight:IsA("Highlight") then
                highlight:Destroy()
                config.Highlight = nil
            end
            
            -- Создаем новый хайлайт
            local newHighlight = Instance.new("Highlight")
            newHighlight.Name = "SelfHighlight"
            newHighlight.FillColor = config.FillColor
            newHighlight.OutlineColor = config.OutlineColor
            newHighlight.FillTransparency = config.FillTransparency
            newHighlight.OutlineTransparency = config.OutlineTransparency
            newHighlight.DepthMode = config.DepthMode
            newHighlight.Adornee = Character
            newHighlight.Parent = Character
            
            -- Сохраняем ссылку на хайлайт
            config.Highlight = newHighlight
        end
    end)
end

-- Функция для отключения SelfChams
local function removeSelfChams()
    -- Используем pcall для безопасного выполнения
    pcall(function()
        -- Кэшируем конфиг для быстрого доступа
        local config = MaterialChamsConfig.Self
        
        -- Восстанавливаем оригинальные материалы и цвета
        for part, material in pairs(config.OriginalMaterials) do
            if part and part:IsDescendantOf(game) then
                pcall(function()
                    part.Material = material
                    
                    -- Восстанавливаем оригинальный цвет, если он был сохранен
                    if config.OriginalColors[part] then
                        part.Color = config.OriginalColors[part]
                    end
                end)
            end
        end
        
        -- Очищаем сохраненные материалы и цвета
        config.OriginalMaterials = {}
        config.OriginalColors = {}
    end)
end

-- Функция для отключения SelfHighlight
local function removeSelfHighlight()
    -- Используем pcall для безопасного выполнения
    pcall(function()
        -- Кэшируем конфиг для быстрого доступа
        local config = HighlightChamsConfig.Self
        
        -- Удаляем хайлайт, если он существует
        if config.Highlight and config.Highlight:IsA("Highlight") then
            config.Highlight:Destroy()
            config.Highlight = nil
        end
    end)
end

-- Функция для применения Chams к другим игрокам
local function applyOtherChams()
    local Players = game:GetService('Players')
    local LocalPlayer = Players.LocalPlayer
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            -- Пропускаем друзей, если включен Friend Chams
            if MaterialChamsConfig.Friend.Enabled and MaterialChamsConfig.Friend.Friends[player.Name] then
                continue
            end
            
            local character = player.Character
            local config = MaterialChamsConfig.Other
            
            -- Сохраняем ссылку на персонажа для обновления
            config.Players[player.Name] = character
            
            -- Применяем материал и цвет ко всем частям тела
            for _, part in pairs(character:GetChildren()) do
                if part and part:IsA("BasePart") then
                    part.Material = config.Material
                    part.Color = config.Color
                end
                
                -- Обрабатываем аксессуары
                if part and part:IsA("Accessory") then
                    local handle = part:FindFirstChild("Handle")
                    if handle then
                        handle.Material = config.Material
                        handle.Color = config.Color
                    end
                end
            end
        end
    end
end

-- Функция для применения Highlight к другим игрокам
local function applyOtherHighlight()
    local Players = game:GetService('Players')
    local LocalPlayer = Players.LocalPlayer
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            -- Пропускаем друзей, если включен Friend Highlight
            if HighlightChamsConfig.Friend.Enabled and MaterialChamsConfig.Friend.Friends[player.Name] then
                continue
            end
            
            local character = player.Character
            local config = HighlightChamsConfig.Other
            
            -- Проверяем существующий хайлайт
            local existingData = config.Players[player.Name]
            local existingHighlight = existingData and existingData.Highlight
            
            -- Если хайлайт уже существует и привязан к тому же персонажу, обновляем настройки
            if existingHighlight and existingHighlight.Parent and existingHighlight.Parent:IsDescendantOf(game) and 
               existingData.Character == character then
                -- Обновляем настройки существующего хайлайта
                existingHighlight.FillColor = config.FillColor
                existingHighlight.OutlineColor = config.OutlineColor
                existingHighlight.FillTransparency = config.FillTransparency
                existingHighlight.OutlineTransparency = config.OutlineTransparency
                existingHighlight.DepthMode = config.DepthMode
            else
                -- Удаляем старый хайлайт, если есть
                if existingHighlight and existingHighlight:IsA("Highlight") then
                    existingHighlight:Destroy()
                end
                
                -- Создаем новый хайлайт
                local highlight = Instance.new("Highlight")
                highlight.Name = "OtherHighlight_" .. player.Name
                highlight.FillColor = config.FillColor
                highlight.OutlineColor = config.OutlineColor
                highlight.FillTransparency = config.FillTransparency
                highlight.OutlineTransparency = config.OutlineTransparency
                highlight.DepthMode = config.DepthMode
                highlight.Adornee = character
                highlight.Parent = character
                
                -- Сохраняем ссылку на хайлайт
                config.Players[player.Name] = {
                    Character = character,
                    Highlight = highlight
                }
            end
        end
    end
end

-- Функция для отключения Chams у других игроков
local function removeOtherChams()
    local Players = game:GetService('Players')
    local config = MaterialChamsConfig.Other
    
    for playerName, character in pairs(config.Players) do
        if character and character:IsDescendantOf(game) then
            for _, part in pairs(character:GetChildren()) do
                if part and part:IsA("BasePart") then
                    pcall(function()
                        part.Material = Enum.Material.Plastic
                        part.Color = Color3.new(1, 1, 1)
                    end)
                end
                
                if part and part:IsA("Accessory") then
                    local handle = part:FindFirstChild("Handle")
                    if handle then
                        pcall(function()
                            handle.Material = Enum.Material.Plastic
                            handle.Color = Color3.new(1, 1, 1)
                        end)
                    end
                end
            end
        end
    end
    
    config.Players = {}
end

-- Функция для отключения Highlight у других игроков
local function removeOtherHighlight()
    local config = HighlightChamsConfig.Other
    
    for playerName, data in pairs(config.Players) do
        if data and data.Highlight and data.Highlight:IsA("Highlight") then
            pcall(function()
                data.Highlight:Destroy()
            end)
        end
    end
    
    config.Players = {}
end

-- Функция для применения Chams к друзьям
local function applyFriendChams()
    local Players = game:GetService('Players')
    local config = MaterialChamsConfig.Friend
    
    for playerName, _ in pairs(config.Friends) do
        local player = Players:FindFirstChild(playerName)
        if player and player.Character then
            local character = player.Character
            
            -- Применяем материал и цвет ко всем частям тела
            for _, part in pairs(character:GetChildren()) do
                if part and part:IsA("BasePart") then
                    part.Material = config.Material
                    part.Color = config.Color
                end
                
                -- Обрабатываем аксессуары
                if part and part:IsA("Accessory") then
                    local handle = part:FindFirstChild("Handle")
                    if handle then
                        handle.Material = config.Material
                        handle.Color = config.Color
                    end
                end
            end
        end
    end
end

-- Функция для применения Highlight к друзьям
local function applyFriendHighlight()
    local Players = game:GetService('Players')
    local config = HighlightChamsConfig.Friend
    
    -- Убедимся, что Friends инициализирован
    if not config.Friends then
        config.Friends = {}
    end
    
    for playerName, _ in pairs(MaterialChamsConfig.Friend.Friends) do
        local player = Players:FindFirstChild(playerName)
        if player and player.Character then
            local character = player.Character
            
            -- Проверяем существующий хайлайт
            local existingData = config.Friends[playerName]
            local existingHighlight = existingData and existingData.Highlight
            
            -- Если хайлайт уже существует и привязан к тому же персонажу, обновляем настройки
            if existingHighlight and existingHighlight.Parent and existingHighlight.Parent:IsDescendantOf(game) and 
               existingData.Character == character then
                -- Обновляем настройки существующего хайлайта
                pcall(function()
                    existingHighlight.FillColor = config.FillColor
                    existingHighlight.OutlineColor = config.OutlineColor
                    existingHighlight.FillTransparency = config.FillTransparency
                    existingHighlight.OutlineTransparency = config.OutlineTransparency
                    existingHighlight.DepthMode = config.DepthMode
                end)
            else
                -- Удаляем старый хайлайт, если есть
                if existingHighlight and existingHighlight:IsA("Highlight") then
                    pcall(function()
                        existingHighlight:Destroy()
                    end)
                end
                
                -- Создаем новый хайлайт
                pcall(function()
                    local highlight = Instance.new("Highlight")
                    highlight.Name = "FriendHighlight_" .. playerName
                    highlight.FillColor = config.FillColor
                    highlight.OutlineColor = config.OutlineColor
                    highlight.FillTransparency = config.FillTransparency
                    highlight.OutlineTransparency = config.OutlineTransparency
                    highlight.DepthMode = config.DepthMode
                    highlight.Adornee = character
                    highlight.Parent = character
                    
                    -- Сохраняем ссылку на хайлайт
                    config.Friends[playerName] = {
                        Character = character,
                        Highlight = highlight
                    }
                end)
            end
        end
    end
end

-- Функция для отключения Highlight у друзей
local function removeFriendHighlight()
    local config = HighlightChamsConfig.Friend
    
    -- Убедимся, что Friends инициализирован
    if not config.Friends then
        config.Friends = {}
        return
    end
    
    for playerName, data in pairs(config.Friends) do
        if data and data.Highlight and data.Highlight:IsA("Highlight") then
            pcall(function()
                data.Highlight:Destroy()
            end)
        end
    end
    
    config.Friends = {}
end

-- Функция для обновления всех Chams
local function updateAllChams()
    -- Обновляем Self Chams
    if MaterialChamsConfig.Self.Enabled then
        applySelfChams()
    else
        removeSelfChams()
    end
    
    -- Обновляем Friend Chams
    if MaterialChamsConfig.Friend.Enabled then
        applyFriendChams()
    end
    
    -- Обновляем Other Chams
    if MaterialChamsConfig.Other.Enabled then
        applyOtherChams()
    else
        removeOtherChams()
    end
end

-- Функция для обновления всех Highlights
local function updateAllHighlights()
    -- Обновляем Self Highlight
    if HighlightChamsConfig.Self.Enabled then
        applySelfHighlight()
    else
        removeSelfHighlight()
    end
    
    -- Обновляем Friend Highlight
    if HighlightChamsConfig.Friend.Enabled then
        applyFriendHighlight()
    else
        removeFriendHighlight()
    end
    
    -- Обновляем Other Highlight
    if HighlightChamsConfig.Other.Enabled then
        applyOtherHighlight()
    else
        removeOtherHighlight()
    end
end

-- Обновление при смене персонажа
game:GetService('Players').LocalPlayer.CharacterAdded:Connect(function(character)
    -- Небольшая задержка, чтобы персонаж полностью загрузился
    task.wait(0.5)
    updateAllChams()
    updateAllHighlights()
    
    -- Отслеживаем смерть персонажа для обновления чамсов и хайлайтов
    character:WaitForChild("Humanoid").Died:Connect(function()
        -- Сохраняем текущие состояния MaterialChams
        local selfMaterialEnabled = MaterialChamsConfig.Self.Enabled
        local otherMaterialEnabled = MaterialChamsConfig.Other.Enabled
        local friendMaterialEnabled = MaterialChamsConfig.Friend.Enabled
        
        -- Сохраняем текущие состояния HighlightChams
        local selfHighlightEnabled = HighlightChamsConfig.Self.Enabled
        local otherHighlightEnabled = HighlightChamsConfig.Other.Enabled
        local friendHighlightEnabled = HighlightChamsConfig.Friend.Enabled
        
        -- Очищаем чамсы и хайлайты
        removeSelfChams()
        removeSelfHighlight()
        
        -- Ждем возрождения персонажа
        task.wait(1)
        
        -- Восстанавливаем состояния MaterialChams, если главный тогл включен
        if Library.Flags["visual_materialchams"] then
            MaterialChamsConfig.Self.Enabled = selfMaterialEnabled
            MaterialChamsConfig.Other.Enabled = otherMaterialEnabled
            MaterialChamsConfig.Friend.Enabled = friendMaterialEnabled
            
            -- Применяем чамсы заново
            updateAllChams()
        end
        
        -- Восстанавливаем состояния HighlightChams, если главный тогл включен
        if Library.Flags["visual_highlightchams"] then
            HighlightChamsConfig.Self.Enabled = selfHighlightEnabled
            HighlightChamsConfig.Other.Enabled = otherHighlightEnabled
            HighlightChamsConfig.Friend.Enabled = friendHighlightEnabled
            
            -- Применяем хайлайты заново
            updateAllHighlights()
        end
    end)
end)

-- Добавляем обработчик для текущего персонажа
local currentCharacter = game:GetService('Players').LocalPlayer.Character
if currentCharacter then
    currentCharacter:WaitForChild("Humanoid").Died:Connect(function()
        -- Сохраняем текущие состояния MaterialChams
        local selfMaterialEnabled = MaterialChamsConfig.Self.Enabled
        local otherMaterialEnabled = MaterialChamsConfig.Other.Enabled
        local friendMaterialEnabled = MaterialChamsConfig.Friend.Enabled
        
        -- Сохраняем текущие состояния HighlightChams
        local selfHighlightEnabled = HighlightChamsConfig.Self.Enabled
        local otherHighlightEnabled = HighlightChamsConfig.Other.Enabled
        local friendHighlightEnabled = HighlightChamsConfig.Friend.Enabled
        
        -- Очищаем чамсы и хайлайты
        removeSelfChams()
        removeSelfHighlight()
        
        -- Ждем возрождения персонажа
        task.wait(1)
        
        -- Восстанавливаем состояния MaterialChams, если главный тогл включен
        if Library.Flags["visual_materialchams"] then
            MaterialChamsConfig.Self.Enabled = selfMaterialEnabled
            MaterialChamsConfig.Other.Enabled = otherMaterialEnabled
            MaterialChamsConfig.Friend.Enabled = friendMaterialEnabled
            
            -- Применяем чамсы заново
            updateAllChams()
        end
        
        -- Восстанавливаем состояния HighlightChams, если главный тогл включен
        if Library.Flags["visual_highlightchams"] then
            HighlightChamsConfig.Self.Enabled = selfHighlightEnabled
            HighlightChamsConfig.Other.Enabled = otherHighlightEnabled
            HighlightChamsConfig.Friend.Enabled = friendHighlightEnabled
            
            -- Применяем хайлайты заново
            updateAllHighlights()
        end
    end)
end

-- Состояние оружия
local gunState = {
    current_tool = nil,
    previous_ammo = 0,
    recently_shot = false,
    connections = {}
}

-- Определение игры и путей к пулям
local function detectGame()
    local placeId = game.PlaceId
    
    local gameData = {
        -- Da Hood
        [2788229376] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored.Siren.Radius" },
        [71189885129233] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored" },
        [5602055394] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored" },
        [17403265390] = { BN = "Part", BBN = "gb", BP = "" },
        [17403166075] = { BN = "Part", BBN = "gb", BP = "" },
        [18111448661] = { BN = "Part", BBN = "gb", BP = "" },
        [15186202290] = { BN = "Part", BBN = "gb", BP = "" },
        [11143225577] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "" },
        [15763494605] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "" },
        [15166543806] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "" },
        [17897702920] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "" },
        [16033173781] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored.Siren.Radius" },
        [7213786345] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored.Siren.Radius" },
        [9825515356] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored" },
        [16859411452] = { BN = "bulletray", BBN = "beam", BP = "Ignored" },
        [14277620939] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored" },
        [0] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored" }
    }
    
    local data = gameData[placeId] or gameData[0]
    return data
end

-- Получение пути к пулям
local function getPath(root, path)
    if path == "" then return root end
    local parts = string.split(path, ".")
    local current = root
    for _, part in ipairs(parts) do
        current = current:FindFirstChild(part)
        if not current then return nil end
    end
    return current
end

-- Создание луча (beam)
local function createBeam(from, to, color1, color2, thickness, texture)
    -- Создаем невидимую основную часть
    local mainPart = Instance.new("Part")
    mainPart.Name = "BulletTracer"
    mainPart.Parent = workspace
    mainPart.Size = Vector3.new(0, 0, 0)
    mainPart.Massless = true
    mainPart.Transparency = 1
    mainPart.CanCollide = false
    mainPart.Position = from
    mainPart.Anchored = true
    
    -- Создаем две точки для луча
    local part0 = Instance.new("Part")
    part0.Parent = mainPart
    part0.Size = Vector3.new(0, 0, 0)
    part0.Massless = true
    part0.Transparency = 1
    part0.CanCollide = false
    part0.Position = from
    part0.Anchored = true
    
    local part1 = Instance.new("Part")
    part1.Parent = mainPart
    part1.Size = Vector3.new(0, 0, 0)
    part1.Massless = true
    part1.Transparency = 1
    part1.CanCollide = false
    part1.Position = to
    part1.Anchored = true
    
    -- Создаем точки крепления для луча
    local attachment0 = Instance.new("Attachment")
    attachment0.Parent = part0
    
    local attachment1 = Instance.new("Attachment")
    attachment1.Parent = part1
    
    -- Создаем сам луч с градиентом цвета
    local beam = Instance.new("Beam")
    beam.Texture = texture
    beam.TextureMode = Enum.TextureMode.Wrap
    beam.TextureLength = 10
    beam.LightEmission = 1
    beam.LightInfluence = 1
    beam.FaceCamera = true
    beam.ZOffset = -1
    beam.Transparency = NumberSequence.new({
        NumberSequenceKeypoint.new(0, 0),
        NumberSequenceKeypoint.new(1, 1),
    })
    beam.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, color1),
        ColorSequenceKeypoint.new(1, color2),
    })
    beam.Attachment0 = attachment0
    beam.Attachment1 = attachment1
    beam.Width0 = thickness
    beam.Width1 = thickness
    beam.Enabled = true
    beam.Parent = mainPart
    
    -- Уничтожаем луч через указанное время
    task.delay(0.4, function()
        mainPart:Destroy()
    end)
end

-- Функция для получения оружия локального игрока
local function getGun(player)
    if not player or not player.Character then return nil end
    
    local tool = player.Character:FindFirstChildWhichIsA("Tool")
    if not tool then return nil end
    
    local gunInfo = {}
    
    -- Ищем значение патронов в оружии
    local descendants = tool:GetDescendants()
    for _, obj in ipairs(descendants) do
        if (string.lower(obj.Name):find("ammo") and not string.lower(obj.Name):find("max") and
            (obj.ClassName == "IntValue" or obj.ClassName == "NumberValue")) then
            gunInfo.ammo = obj
            gunInfo.tool = tool
            return gunInfo
        end
    end
    
    return nil
end

-- Функция для настройки отслеживания оружия
local function setupGunTracking(player)
    -- Очищаем текущие соединения
    for _, connection in ipairs(gunState.connections) do
        if connection then connection:Disconnect() end
    end
    gunState.connections = {}
    
    -- Если персонаж игрока не существует, создаем соединение на его появление
    if not player.Character then
        table.insert(gunState.connections, player.CharacterAdded:Connect(function(character)
            setupGunTracking(player)
        end))
        return
    end
    
    -- Отслеживаем добавление/удаление оружия
    table.insert(gunState.connections, player.Character.ChildAdded:Connect(function(child)
        if child:IsA("Tool") then
            local gun = getGun(player)
            if gun then
                gunState.current_tool = gun.tool
                gunState.previous_ammo = gun.ammo.Value
                
                -- Отслеживаем изменение количества патронов
                table.insert(gunState.connections, gun.ammo.Changed:Connect(function()
                    local new_ammo = gun.ammo.Value
                    if new_ammo < gunState.previous_ammo then
                        gunState.recently_shot = true
                        task.wait() -- Короткая пауза для обнаружения пули
                        gunState.recently_shot = false
                    end
                    gunState.previous_ammo = new_ammo
                end))
            end
        end
    end))
    
    table.insert(gunState.connections, player.Character.ChildRemoved:Connect(function(child)
        if child == gunState.current_tool then
            gunState.current_tool = nil
            gunState.previous_ammo = 0
        end
    end))
    
    -- Проверяем наличие оружия сразу
    local gun = getGun(player)
    if gun then
        gunState.current_tool = gun.tool
        gunState.previous_ammo = gun.ammo.Value
        
        -- Отслеживаем изменение количества патронов
        table.insert(gunState.connections, gun.ammo.Changed:Connect(function()
            local new_ammo = gun.ammo.Value
            if new_ammo < gunState.previous_ammo then
                gunState.recently_shot = true
                task.wait() -- Короткая пауза для обнаружения пули
                gunState.recently_shot = false
            end
            gunState.previous_ammo = new_ammo
        end))
    end
end

-- Основная функция для настройки эффектов пуль
local function setupBulletEffects()
    local gameData = detectGame()
    local bulletPath = getPath(workspace, gameData.BP) or workspace
    
    -- Настраиваем отслеживание оружия локального игрока
    setupGunTracking(game.Players.LocalPlayer)
    
    -- Отслеживаем добавление персонажа, если он еще не существует
    if not game.Players.LocalPlayer.Character then
        game.Players.LocalPlayer.CharacterAdded:Connect(function(character)
            setupGunTracking(game.Players.LocalPlayer)
        end)
    end
    
    -- Удаляем старые соединения, если они существуют
    if getgenv().bulletTracerConnection then
        getgenv().bulletTracerConnection:Disconnect()
        getgenv().bulletTracerConnection = nil
    end
    
    -- Следим за созданием новых пуль
    getgenv().bulletTracerConnection = bulletPath.ChildAdded:Connect(function(object)
        if not BulletTracersConfig.Enabled then return end
        
        -- Проверяем, чтобы это была пуля с правильным именем
        if object.Name == gameData.BN then
            task.spawn(function()
                local gunBeam = object:WaitForChild(gameData.BBN, 0.2)
                if not gunBeam then return end
                
                local startPos = object.Position
                local endPos = gunBeam.Attachment1.WorldPosition
                
                -- Удаляем оригинальный луч
                gunBeam:Destroy()
                
                -- Создаем трейсер
                createBeam(
                    startPos, 
                    endPos, 
                    BulletTracersConfig.Color1, 
                    BulletTracersConfig.Color2, 
                    BulletTracersConfig.Thickness,
                    BulletTracersConfig.Texture
                )
            end)
        end
    end)
    
    -- Добавляем дополнительное отслеживание для случаев, когда ChildAdded не срабатывает
    if getgenv().bulletTracerBackupConnection then
        getgenv().bulletTracerBackupConnection:Disconnect()
        getgenv().bulletTracerBackupConnection = nil
    end
    
    getgenv().bulletTracerBackupConnection = game:GetService("RunService").Heartbeat:Connect(function()
        if not BulletTracersConfig.Enabled then return end
        
        -- Проверяем все пули в рабочем пространстве
        for _, object in ipairs(bulletPath:GetChildren()) do
            if object.Name == gameData.BN and object:IsA("BasePart") then
                local gunBeam = object:FindFirstChild(gameData.BBN)
                if gunBeam and not gunBeam:GetAttribute("Processed") then
                    gunBeam:SetAttribute("Processed", true)
                    
                    task.spawn(function()
                        local startPos = object.Position
                        local endPos = gunBeam.Attachment1.WorldPosition
                        
                        -- Удаляем оригинальный луч
                        gunBeam:Destroy()
                        
                        -- Создаем трейсер
                        createBeam(
                            startPos, 
                            endPos, 
                            BulletTracersConfig.Color1, 
                            BulletTracersConfig.Color2, 
                            BulletTracersConfig.Thickness,
                            BulletTracersConfig.Texture
                        )
                    end)
                end
            end
        end
    end)
end

-- Добавляем тогл Bullet Tracers с попапом
local BulletTracersToggle = VisualsMainSection:Toggle({
    name = "Bullet Tracers",
    default = false,
    flag = "visuals_bullet_tracers",
    callback = function(value)
        BulletTracersConfig.Enabled = value
        
        -- Если включаем трейсеры, настраиваем их
        if value then
            setupBulletEffects()
        end
    end
})

-- Создаем попап для настроек трейсеров
local BulletTracersPopup = BulletTracersToggle:Popup({size = 200})

-- Добавляем колорпикер для начального цвета трейсера
BulletTracersPopup:Colorpicker({
    name = "Start Color",
    description = ">_<",
    default = Color3.fromRGB(255, 255, 255),
    flag = "bullet_tracers_color1",
    callback = function(color)
        if type(color) == "table" and color.c then
            BulletTracersConfig.Color1 = color.c
        else
            BulletTracersConfig.Color1 = color
        end
    end
})

-- Добавляем колорпикер для конечного цвета трейсера
BulletTracersPopup:Colorpicker({
    name = "End Color",
    description = ">_<",
    default = Color3.fromRGB(255, 255, 255),
    flag = "bullet_tracers_color2",
    callback = function(color)
        if type(color) == "table" and color.c then
            BulletTracersConfig.Color2 = color.c
        else
            BulletTracersConfig.Color2 = color
        end
    end
})

-- Добавляем слайдер для толщины трейсера
BulletTracersPopup:Slider({
    name = "Thickness",
    min = 0.1,
    max = 5,
    default = 1,
    float = 0.1,
    flag = "bullet_tracers_thickness",
    callback = function(value)
        BulletTracersConfig.Thickness = value
    end
})

-- Добавляем выпадающий список для текстуры трейсера
BulletTracersPopup:Dropdown({
    name = "Texture",
    values = {"Default", "Starhook", "Chain", "Lightning", "Beam", "Neon", "Laser"},
    value = "Starhook",
    flag = "bullet_tracers_texture",
    callback = function(value)
        local textures = {
            ["Default"] = "",
            ["Starhook"] = "rbxassetid://446111271",
            ["Chain"] = "rbxassetid://3029306948",
            ["Lightning"] = "rbxassetid://7216850022",
            ["Beam"] = "rbxassetid://1263079249",
            ["Neon"] = "rbxassetid://5864341017",
            ["Laser"] = "rbxassetid://5864341017"
        }
        BulletTracersConfig.Texture = textures[value] or ""
    end
})

-- Добавляем тогл MaterialChams с попапом
local MaterialChamsToggle = VisualsMainSection:Toggle({
    name = "Material Chams",
    default = false,
    flag = "visual_materialchams",
    callback = function(value)
        -- Обновляем состояние всех подтоглов в зависимости от главного тогла
        if not value then
            -- Если главный тогл выключен, выключаем все чамсы
            MaterialChamsConfig.Self.Enabled = false
            MaterialChamsConfig.Other.Enabled = false
            MaterialChamsConfig.Friend.Enabled = false
            removeSelfChams()
            removeOtherChams()
        else
            -- Если главный тогл включен, восстанавливаем состояния из флагов
            MaterialChamsConfig.Self.Enabled = Library.Flags["material_chams_self"] or false
            MaterialChamsConfig.Other.Enabled = Library.Flags["material_chams_other"] or false
            MaterialChamsConfig.Friend.Enabled = Library.Flags["material_chams_friend"] or false
        end
        
        -- Обновляем все чамсы
        updateAllChams()
    end
})

-- Создаем попап для MaterialChams
local MaterialChamsPopup = MaterialChamsToggle:Popup({size = 250})

-- Добавляем тогл Self с попапом
local SelfChamsToggle = MaterialChamsPopup:Toggle({
    name = "Self",
    default = false,
    flag = "material_chams_self",
    callback = function(value)
        MaterialChamsConfig.Self.Enabled = value
        
        -- Проверяем состояние главного тогла
        if not Library.Flags["visual_materialchams"] then
            return
        end
        
        if value then
            applySelfChams()
        else
            removeSelfChams()
        end
    end
})

-- Создаем попап для Self
local SelfChamsPopup = SelfChamsToggle:Popup({size = 200})

-- Устанавливаем материал ForceField для Self
MaterialChamsConfig.Self.Material = Enum.Material.ForceField

-- Добавляем колорпикер для цвета Self
SelfChamsPopup:Colorpicker({
    name = "Color",
    description = ">_<",
    default = Color3.fromRGB(0, 170, 255),
    flag = "self_chams_color",
    callback = function(color)
        if type(color) == "table" and color.c then
            MaterialChamsConfig.Self.Color = color.c
        else
            MaterialChamsConfig.Self.Color = color
        end
        
        -- Если включено, сразу применяем новый цвет
        if MaterialChamsConfig.Self.Enabled then
            applySelfChams()
        end
    end
})

-- Добавляем тогл Other с попапом
local OtherChamsToggle = MaterialChamsPopup:Toggle({
    name = "Other",
    default = false,
    flag = "material_chams_other",
    callback = function(value)
        MaterialChamsConfig.Other.Enabled = value
        
        -- Проверяем состояние главного тогла
        if not Library.Flags["visual_materialchams"] then
            return
        end
        
        if value then
            applyOtherChams()
        else
            removeOtherChams()
        end
    end
})

-- Создаем попап для Other
local OtherChamsPopup = OtherChamsToggle:Popup({size = 200})

-- Устанавливаем материал ForceField для Other
MaterialChamsConfig.Other.Material = Enum.Material.ForceField

-- Добавляем колорпикер для цвета Other
OtherChamsPopup:Colorpicker({
    name = "Color",
    description = ">_<",
    default = Color3.fromRGB(255, 0, 0),
    flag = "other_chams_color",
    callback = function(color)
        if type(color) == "table" and color.c then
            MaterialChamsConfig.Other.Color = color.c
        else
            MaterialChamsConfig.Other.Color = color
        end
        
        -- Если включено, сразу применяем новый цвет
        if MaterialChamsConfig.Other.Enabled then
            applyOtherChams()
        end
    end
})

-- Добавляем тогл Friend с попапом
local FriendChamsToggle = MaterialChamsPopup:Toggle({
    name = "Friend",
    default = false,
    flag = "material_chams_friend",
    callback = function(value)
        MaterialChamsConfig.Friend.Enabled = value
        
        -- Проверяем состояние главного тогла
        if not Library.Flags["visual_materialchams"] then
            return
        end
        
        if value then
            applyFriendChams()
        end
    end
})

-- Создаем попап для Friend
local FriendChamsPopup = FriendChamsToggle:Popup({size = 200})

-- Устанавливаем материал ForceField для Friend
MaterialChamsConfig.Friend.Material = Enum.Material.ForceField

-- Добавляем колорпикер для цвета Friend
FriendChamsPopup:Colorpicker({
    name = "Color",
    description = ">_<",
    default = Color3.fromRGB(0, 255, 0),
    flag = "friend_chams_color",
    callback = function(color)
        if type(color) == "table" and color.c then
            MaterialChamsConfig.Friend.Color = color.c
        else
            MaterialChamsConfig.Friend.Color = color
        end
        
        -- Если включено, сразу применяем новый цвет
        if MaterialChamsConfig.Friend.Enabled then
            applyFriendChams()
        end
    end
})

-- Создаем список игроков для добавления в друзья
local playersList = {}
for _, player in pairs(game:GetService("Players"):GetPlayers()) do
    if player ~= game:GetService("Players").LocalPlayer then
        table.insert(playersList, player.Name)
    end
end

-- Добавляем список игроков
local PlayersListBox = FriendChamsPopup:List({
    name = "Players",
    values = playersList,
    flag = "friend_players_list",
    callback = function(value)
        -- Сохраняем выбранного игрока
        FriendChamsPopup.selectedPlayer = value
    end
})

-- Добавляем тогл Chams Highlights с попапом
local HighlightChamsToggle = VisualsMainSection:Toggle({
    name = "Chams Highlights",
    default = false,
    flag = "visual_highlightchams",
    callback = function(value)
        -- Обновляем состояние всех подтоглов в зависимости от главного тогла
        if not value then
            -- Если главный тогл выключен, выключаем все хайлайты
            HighlightChamsConfig.Self.Enabled = false
            HighlightChamsConfig.Other.Enabled = false
            HighlightChamsConfig.Friend.Enabled = false
            removeSelfHighlight()
            removeOtherHighlight()
            removeFriendHighlight()
        else
            -- Если главный тогл включен, восстанавливаем состояния из флагов
            HighlightChamsConfig.Self.Enabled = Library.Flags["highlight_chams_self"] or false
            HighlightChamsConfig.Other.Enabled = Library.Flags["highlight_chams_other"] or false
            HighlightChamsConfig.Friend.Enabled = Library.Flags["highlight_chams_friend"] or false
        end
        
        -- Обновляем все хайлайты
        updateAllHighlights()
    end
})

-- Создаем попап для HighlightChams
local HighlightChamsPopup = HighlightChamsToggle:Popup({size = 250})

-- Добавляем тогл Self с попапом
local SelfHighlightToggle = HighlightChamsPopup:Toggle({
    name = "Self",
    default = false,
    flag = "highlight_chams_self",
    callback = function(value)
        HighlightChamsConfig.Self.Enabled = value
        
        -- Проверяем состояние главного тогла
        if not Library.Flags["visual_highlightchams"] then
            return
        end
        
        if value then
            applySelfHighlight()
        else
            removeSelfHighlight()
        end
    end
})

-- Создаем попап для Self
local SelfHighlightPopup = SelfHighlightToggle:Popup({size = 200})

-- Добавляем слайдер для прозрачности заливки
SelfHighlightPopup:Slider({
    name = "Fill Transparency",
    min = 0,
    max = 1,
    default = 0.5,
    float = 0.01,
    flag = "self_highlight_fill_transparency",
    callback = function(value)
        HighlightChamsConfig.Self.FillTransparency = value
        
        -- Если включено, сразу применяем
        if HighlightChamsConfig.Self.Enabled and Library.Flags["visual_highlightchams"] then
            if HighlightChamsConfig.Self.Highlight then
                HighlightChamsConfig.Self.Highlight.FillTransparency = value
            end
        end
    end
})

-- Добавляем слайдер для прозрачности обводки
SelfHighlightPopup:Slider({
    name = "Outline Transparency",
    min = 0,
    max = 1,
    default = 0,
    float = 0.01,
    flag = "self_highlight_outline_transparency",
    callback = function(value)
        HighlightChamsConfig.Self.OutlineTransparency = value
        
        -- Если включено, сразу применяем
        if HighlightChamsConfig.Self.Enabled and Library.Flags["visual_highlightchams"] then
            if HighlightChamsConfig.Self.Highlight then
                HighlightChamsConfig.Self.Highlight.OutlineTransparency = value
            end
        end
    end
})

-- Добавляем колорпикер для цвета заливки
SelfHighlightPopup:Colorpicker({
    name = "Fill Color",
    description = ">_<",
    default = Color3.fromRGB(0, 170, 255),
    flag = "self_highlight_fill_color",
    callback = function(color)
        if type(color) == "table" and color.c then
            HighlightChamsConfig.Self.FillColor = color.c
        else
            HighlightChamsConfig.Self.FillColor = color
        end
        
        -- Если включено, сразу применяем
        if HighlightChamsConfig.Self.Enabled and Library.Flags["visual_highlightchams"] then
            if HighlightChamsConfig.Self.Highlight then
                HighlightChamsConfig.Self.Highlight.FillColor = HighlightChamsConfig.Self.FillColor
            end
        end
    end
})

-- Добавляем колорпикер для цвета обводки
SelfHighlightPopup:Colorpicker({
    name = "Outline Color",
    description = ">_<",
    default = Color3.fromRGB(255, 255, 255),
    flag = "self_highlight_outline_color",
    callback = function(color)
        if type(color) == "table" and color.c then
            HighlightChamsConfig.Self.OutlineColor = color.c
        else
            HighlightChamsConfig.Self.OutlineColor = color
        end
        
        -- Если включено, сразу применяем
        if HighlightChamsConfig.Self.Enabled and Library.Flags["visual_highlightchams"] then
            if HighlightChamsConfig.Self.Highlight then
                HighlightChamsConfig.Self.Highlight.OutlineColor = HighlightChamsConfig.Self.OutlineColor
            end
        end
    end
})

-- Добавляем тогл Other с попапом
local OtherHighlightToggle = HighlightChamsPopup:Toggle({
    name = "Other",
    default = false,
    flag = "highlight_chams_other",
    callback = function(value)
        HighlightChamsConfig.Other.Enabled = value
        
        -- Проверяем состояние главного тогла
        if not Library.Flags["visual_highlightchams"] then
            return
        end
        
        if value then
            applyOtherHighlight()
        else
            removeOtherHighlight()
        end
    end
})

-- Создаем попап для Other
local OtherHighlightPopup = OtherHighlightToggle:Popup({size = 200})

-- Добавляем слайдер для прозрачности заливки
OtherHighlightPopup:Slider({
    name = "Fill Transparency",
    min = 0,
    max = 1,
    default = 0.5,
    float = 0.01,
    flag = "other_highlight_fill_transparency",
    callback = function(value)
        HighlightChamsConfig.Other.FillTransparency = value
        
        -- Если включено, сразу применяем
        if HighlightChamsConfig.Other.Enabled and Library.Flags["visual_highlightchams"] then
            applyOtherHighlight()
        end
    end
})

-- Добавляем слайдер для прозрачности обводки
OtherHighlightPopup:Slider({
    name = "Outline Transparency",
    min = 0,
    max = 1,
    default = 0,
    float = 0.01,
    flag = "other_highlight_outline_transparency",
    callback = function(value)
        HighlightChamsConfig.Other.OutlineTransparency = value
        
        -- Если включено, сразу применяем
        if HighlightChamsConfig.Other.Enabled and Library.Flags["visual_highlightchams"] then
            applyOtherHighlight()
        end
    end
})

-- Добавляем колорпикер для цвета заливки
OtherHighlightPopup:Colorpicker({
    name = "Fill Color",
    description = ">_<",
    default = Color3.fromRGB(255, 0, 0),
    flag = "other_highlight_fill_color",
    callback = function(color)
        if type(color) == "table" and color.c then
            HighlightChamsConfig.Other.FillColor = color.c
        else
            HighlightChamsConfig.Other.FillColor = color
        end
        
        -- Если включено, сразу применяем
        if HighlightChamsConfig.Other.Enabled and Library.Flags["visual_highlightchams"] then
            applyOtherHighlight()
        end
    end
})

-- Добавляем колорпикер для цвета обводки
OtherHighlightPopup:Colorpicker({
    name = "Outline Color",
    description = ">_<",
    default = Color3.fromRGB(255, 255, 255),
    flag = "other_highlight_outline_color",
    callback = function(color)
        if type(color) == "table" and color.c then
            HighlightChamsConfig.Other.OutlineColor = color.c
        else
            HighlightChamsConfig.Other.OutlineColor = color
        end
        
        -- Если включено, сразу применяем
        if HighlightChamsConfig.Other.Enabled and Library.Flags["visual_highlightchams"] then
            applyOtherHighlight()
        end
    end
})

-- Добавляем тогл Friend с попапом
local FriendHighlightToggle = HighlightChamsPopup:Toggle({
    name = "Friend",
    default = false,
    flag = "highlight_chams_friend",
    callback = function(value)
        HighlightChamsConfig.Friend.Enabled = value
        
        -- Проверяем состояние главного тогла
        if not Library.Flags["visual_highlightchams"] then
            return
        end
        
        if value then
            applyFriendHighlight()
        else
            removeFriendHighlight()
        end
    end
})

-- Создаем попап для Friend
local FriendHighlightPopup = FriendHighlightToggle:Popup({size = 200})

-- Добавляем слайдер для прозрачности заливки
FriendHighlightPopup:Slider({
    name = "Fill Transparency",
    min = 0,
    max = 1,
    default = 0.5,
    float = 0.01,
    flag = "friend_highlight_fill_transparency",
    callback = function(value)
        HighlightChamsConfig.Friend.FillTransparency = value
        
        -- Если включено, сразу применяем
        if HighlightChamsConfig.Friend.Enabled and Library.Flags["visual_highlightchams"] then
            applyFriendHighlight()
        end
    end
})

-- Добавляем слайдер для прозрачности обводки
FriendHighlightPopup:Slider({
    name = "Outline Transparency",
    min = 0,
    max = 1,
    default = 0,
    float = 0.01,
    flag = "friend_highlight_outline_transparency",
    callback = function(value)
        HighlightChamsConfig.Friend.OutlineTransparency = value
        
        -- Если включено, сразу применяем
        if HighlightChamsConfig.Friend.Enabled and Library.Flags["visual_highlightchams"] then
            applyFriendHighlight()
        end
    end
})

-- Добавляем колорпикер для цвета заливки
FriendHighlightPopup:Colorpicker({
    name = "Fill Color",
    description = ">_<",
    default = Color3.fromRGB(0, 255, 0),
    flag = "friend_highlight_fill_color",
    callback = function(color)
        if type(color) == "table" and color.c then
            HighlightChamsConfig.Friend.FillColor = color.c
        else
            HighlightChamsConfig.Friend.FillColor = color
        end
        
        -- Если включено, сразу применяем
        if HighlightChamsConfig.Friend.Enabled and Library.Flags["visual_highlightchams"] then
            applyFriendHighlight()
        end
    end
})

-- Добавляем колорпикер для цвета обводки
FriendHighlightPopup:Colorpicker({
    name = "Outline Color",
    description = ">_<",
    default = Color3.fromRGB(255, 255, 255),
    flag = "friend_highlight_outline_color",
    callback = function(color)
        if type(color) == "table" and color.c then
            HighlightChamsConfig.Friend.OutlineColor = color.c
        else
            HighlightChamsConfig.Friend.OutlineColor = color
        end
        
        -- Если включено, сразу применяем
        if HighlightChamsConfig.Friend.Enabled and Library.Flags["visual_highlightchams"] then
            applyFriendHighlight()
        end
    end
})

-- Обновление списка игроков при входе нового игрока
game:GetService("Players").PlayerAdded:Connect(function(player)
    if player ~= game:GetService("Players").LocalPlayer then
        table.insert(playersList, player.Name)
        pcall(function()
            PlayersListBox:Refresh(playersList)
        end)
    end
end)

-- Обновление списка игроков при выходе игрока
game:GetService("Players").PlayerRemoving:Connect(function(player)
    for i, name in pairs(playersList) do
        if name == player.Name then
            table.remove(playersList, i)
            break
        end
    end
    pcall(function()
        PlayersListBox:Refresh(playersList)
    end)
end)

-- Добавляем кнопку Add Friend
FriendChamsPopup:Button({
    name = "Add Friend",
    callback = function()
        if FriendChamsPopup.selectedPlayer then
            MaterialChamsConfig.Friend.Friends[FriendChamsPopup.selectedPlayer] = true
            saveFriends()
            
            -- Если включен Friend Chams, применяем к новому другу
            if MaterialChamsConfig.Friend.Enabled then
                applyFriendChams()
            end
            
            -- Если включен Other Chams, обновляем его, чтобы исключить нового друга
            if MaterialChamsConfig.Other.Enabled then
                applyOtherChams()
            end
        end
    end
})

-- Добавляем кнопку Remove Friend
FriendChamsPopup:Button({
    name = "Remove Friend",
    callback = function()
        if FriendChamsPopup.selectedPlayer and MaterialChamsConfig.Friend.Friends[FriendChamsPopup.selectedPlayer] then
            MaterialChamsConfig.Friend.Friends[FriendChamsPopup.selectedPlayer] = nil
            saveFriends()
            
            -- Если включен Other Chams, обновляем его, чтобы включить бывшего друга
            if MaterialChamsConfig.Other.Enabled then
                applyOtherChams()
            end
        end
    end
})

-- Создаем секцию Main во вкладке Player
PlayerMainSection = PlayerTab:Section({name = "Main", description = ">_<"})

-- Добавляем тогл Anti AFK
PlayerMainSection:Toggle({
    name = "Anti AFK",
    default = false,
    flag = "player_antiafk",
    callback = function(value)
        if value then
            -- Создаем и запускаем Anti AFK скрипт
            o.antiAFKConnection = o.lp.Idled:Connect(function()
                o.VirtualUser = o.GU
                o.VirtualUser:CaptureController()
                o.VirtualUser:ClickButton2(Vector2.new())
            end)
            
            -- Сохраняем соединение в Library.Flags для возможности отключения
            Library.Flags["antiafk_connection"] = o.antiAFKConnection
        else
            -- Отключаем Anti AFK если тогл выключен
            if o.antiAFKConnection then
                o.antiAFKConnection:Disconnect()
                o.antiAFKConnection = nil
                Library.Flags["antiafk_connection"] = nil
            end
        end
    end
})

-- Добавляем тогл FakeMacro (только с LeftControl)
PlayerMainSection:Toggle({
    name = "Fake Macro",
    default = false,
    flag = "player_fakemacro",
    callback = function(value)
        -- Включаем/выключаем FakeMacro
        Library.Flags["fakemacro_enabled"] = value
        
        -- Управляем соединениями
        if value then
            -- Создаем соединения, если их еще нет
            if not Library.Flags["fakemacro_connections"] then
                -- Глобальная переменная для отслеживания состояния
                o.toggleEnabled = false
                
                -- Соединение для отслеживания нажатия клавиши LeftControl
                o.fakeMacroInputBegan = o.uis.InputBegan:Connect(function(input, gameProcessed)
                    if input.KeyCode == Enum.KeyCode.LeftControl and not gameProcessed then
                        o.toggleEnabled = true
                    end
                end)
                
                -- Соединение для отслеживания отпускания клавиши LeftControl
                o.fakeMacroInputEnded = o.uis.InputEnded:Connect(function(input, gameProcessed)
                    if input.KeyCode == Enum.KeyCode.LeftControl and not gameProcessed then
                        o.toggleEnabled = false
                    end
                end)
                
                -- Соединение для обновления ориентации персонажа
                o.fakeMacroHeartbeat = o.rs.Heartbeat:Connect(function()
                    if o.toggleEnabled then
                        o.common_vars.char = o.lp.Character
                        if o.common_vars.char then
                            o.common_vars.hrp = o.common_vars.char:FindFirstChild("HumanoidRootPart")
                            if o.common_vars.hrp and o.camera then
                                o.common_vars.hrp.CFrame = o.funcs.cf(o.common_vars.hrp.Position) * 
                                    CFrame.Angles(0, math.atan2(-o.camera.CFrame.LookVector.X, -o.camera.CFrame.LookVector.Z), 0)
                            end
                        end
                    end
                end)
                
                -- Сохраняем соединения для возможности отключения
                Library.Flags["fakemacro_connections"] = {
                    inputBegan = o.fakeMacroInputBegan,
                    inputEnded = o.fakeMacroInputEnded,
                    heartbeat = o.fakeMacroHeartbeat
                }
            end
        else
            -- Отключаем соединения, если тогл выключен
            if Library.Flags["fakemacro_connections"] then
                if o.fakeMacroInputBegan then o.fakeMacroInputBegan:Disconnect() end
                if o.fakeMacroInputEnded then o.fakeMacroInputEnded:Disconnect() end
                if o.fakeMacroHeartbeat then o.fakeMacroHeartbeat:Disconnect() end
                Library.Flags["fakemacro_connections"] = nil
            end
        end
    end
})

-- Добавляем тогл No Collision
PlayerMainSection:Toggle({
    name = "No Collision",
    default = false,
    flag = "player_nocollision",
    callback = function(value)
        -- Получаем персонажа
        o.common_vars.char = o.lp.Character
        
        if o.common_vars.char then
            -- Используем функцию setNoClip для включения/выключения коллизий
            if not _G.setNoClip_defined and setNoClip then
                _G.setNoClip_defined = true
            end
            
            if _G.setNoClip_defined or setNoClip then
                setNoClip(o.common_vars.char, value)
            end
        end
        
        -- Если тогл включен, создаем соединение для новых персонажей
        if value then
            if not o.noCollisionConnection then
                o.noCollisionConnection = o.lp.CharacterAdded:Connect(function(character)
                    task.wait(0.5) -- Небольшая задержка для загрузки персонажа
                    if Library.Flags["player_nocollision"] then
                        if _G.setNoClip_defined or setNoClip then
                            setNoClip(character, true)
                        end
                    end
                end)
            end
        else
            -- Отключаем соединение при выключении тогла
            if o.noCollisionConnection then
                o.noCollisionConnection:Disconnect()
                o.noCollisionConnection = nil
            end
        end
    end
})

-- Добавляем тогл No Jump Cooldown
PlayerMainSection:Toggle({
    name = "No Jump Cooldown",
    default = false,
    flag = "player_nojumpcooldown",
    callback = function(value)
        -- Определяем hookmetamethod и checkcaller, если они не существуют
        if not _G.hookmetamethod_defined then
            _G.hookmetamethod_defined = true
            if not hookmetamethod then
                hookmetamethod = function(obj, metamethod, hook)
                    -- Заглушка для hookmetamethod
                    local original = obj[metamethod]
                    obj[metamethod] = hook
                    return original
                end
            end
            
            if not checkcaller then
                checkcaller = function()
                    -- Заглушка для checkcaller
                    return false
                end
            end
        end
        
        -- Сохраняем оригинальный хук, если он еще не сохранен
        if not o.originalJumpHook then
            o.originalJumpHook = hookmetamethod(game, "__newindex", function(self, Index, Value)
                -- Если тогл включен и это изменение JumpPower, блокируем его
                if Library.Flags["player_nojumpcooldown"] and not checkcaller() and self:IsA("Humanoid") and Index == "JumpPower" then 
                    return
                end
                
                -- Иначе пропускаем вызов
                return o.originalJumpHook(self, Index, Value)
            end)
        end
    end
})

-- Добавляем тогл Prediction Visualizer с попапом
o.VisualizeVelocityToggle = PlayerMainSection:Toggle({
    name = "Prediction Visualizer",
    default = false,
    flag = "player_visualizevel",
    callback = function(value)
        -- Инициализируем объекты для визуализации, если их еще нет
        if not o.velocityDrawings then
            o.velocityDrawings = {
                line = Drawing.new("Line"),
                circle = Drawing.new("Circle")
            }
            
            -- Настраиваем линию
            o.velocityDrawings.line.Thickness = 1
            o.velocityDrawings.line.Color = Color3.fromRGB(255, 0, 0)
            o.velocityDrawings.line.Transparency = 1
            o.velocityDrawings.line.ZIndex = 1
            
            -- Настраиваем круг для конечной точки
            o.velocityDrawings.circle.Thickness = 1
            o.velocityDrawings.circle.Color = Color3.fromRGB(255, 0, 0)
            o.velocityDrawings.circle.Transparency = 1
            o.velocityDrawings.circle.NumSides = 12
            o.velocityDrawings.circle.Radius = 3
            o.velocityDrawings.circle.Filled = true
            o.velocityDrawings.circle.ZIndex = 2
        end
        
        if value then
            -- Создаем соединение для обновления линии
            if not o.visualizeVelConnection then
                o.visualizeVelConnection = o.rs.RenderStepped:Connect(function()
                    o.common_vars.char = o.lp.Character
                    if not o.common_vars.char then 
                        o.velocityDrawings.line.Visible = false
                        o.velocityDrawings.circle.Visible = false
                        return 
                    end
                    
                    o.common_vars.hrp = o.common_vars.char:FindFirstChild("HumanoidRootPart")
                    if not o.common_vars.hrp then 
                        o.velocityDrawings.line.Visible = false
                        o.velocityDrawings.circle.Visible = false
                        return 
                    end
                    
                    -- Получаем текущую скорость
                    o.common_vars.vel = o.common_vars.hrp.Velocity
                    
                    -- Если скорость слишком мала, делаем линию невидимой
                    if o.common_vars.vel.Magnitude < 0.1 then
                        o.velocityDrawings.line.Visible = false
                        o.velocityDrawings.circle.Visible = false
                        return
                    end
                    
                    -- Устанавливаем прозрачность линии и круга
                    o.velocityDrawings.line.Transparency = 0.7
                    o.velocityDrawings.circle.Transparency = 0.7
                    
                    -- Устанавливаем цвет линии и круга
                    if Library.Flags["visualizevel_color"] then
                        if type(Library.Flags["visualizevel_color"]) == "table" and Library.Flags["visualizevel_color"].c then
                            o.velocityDrawings.line.Color = Library.Flags["visualizevel_color"].c
                            o.velocityDrawings.circle.Color = Library.Flags["visualizevel_color"].c
                        else
                            o.velocityDrawings.line.Color = Library.Flags["visualizevel_color"]
                            o.velocityDrawings.circle.Color = Library.Flags["visualizevel_color"]
                        end
                    end
                    
                    -- Масштабируем скорость для лучшей визуализации
                    o.common_vars.scale = Library.Flags["visualizevel_scale"] or 0.1
                    o.common_vars.scaledVel = o.common_vars.vel * o.common_vars.scale
                    
                    -- Получаем позиции для начала и конца линии
                    o.common_vars.startPos = o.common_vars.hrp.Position
                    o.common_vars.endPos = o.common_vars.startPos + o.common_vars.scaledVel
                    
                    -- Конвертируем 3D позиции в 2D для отображения на экране
                    o.common_vars.startPos2D = o.camera:WorldToViewportPoint(o.common_vars.startPos)
                    o.common_vars.endPos2D = o.camera:WorldToViewportPoint(o.common_vars.endPos)
                    
                    -- Проверяем, что обе точки видны на экране
                    if o.common_vars.startPos2D.Z > 0 and o.common_vars.endPos2D.Z > 0 then
                        -- Устанавливаем позиции линии
                        o.velocityDrawings.line.From = Vector2.new(o.common_vars.startPos2D.X, o.common_vars.startPos2D.Y)
                        o.velocityDrawings.line.To = Vector2.new(o.common_vars.endPos2D.X, o.common_vars.endPos2D.Y)
                        o.velocityDrawings.line.Visible = true
                        
                        -- Устанавливаем позицию круга
                        o.velocityDrawings.circle.Position = Vector2.new(o.common_vars.endPos2D.X, o.common_vars.endPos2D.Y)
                        o.velocityDrawings.circle.Visible = true
                    else
                        o.velocityDrawings.line.Visible = false
                        o.velocityDrawings.circle.Visible = false
                    end
                end)
            end
        else
            -- Отключаем соединение и скрываем визуализатор
            if o.visualizeVelConnection then
                o.visualizeVelConnection:Disconnect()
                o.visualizeVelConnection = nil
            end
            
            -- Скрываем визуализатор
            if o.velocityDrawings then
                o.velocityDrawings.line.Visible = false
                o.velocityDrawings.circle.Visible = false
            end
        end
    end
})

-- Создаем попап для Prediction Visualizer
o.VisualizeVelocityPopup = o.VisualizeVelocityToggle:Popup({size = 150})

-- Добавляем колорпикер для цвета линии
o.VisualizeVelocityPopup:Colorpicker({
    name = "Line Color",
    description = ">_<",
    default = Color3.fromRGB(255, 0, 0),
    flag = "visualizevel_color",
    callback = function(color)
        if o.velocityDrawings then
            if type(color) == "table" and color.c then
                o.velocityDrawings.line.Color = color.c
                o.velocityDrawings.circle.Color = color.c
            else
                o.velocityDrawings.line.Color = color
                o.velocityDrawings.circle.Color = color
            end
        end
    end
})

-- Добавляем слайдер для масштаба линии
o.VisualizeVelocityPopup:Slider({
    name = "Scale",
    min = 0.01,
    max = 1,
    default = 0.1,
    float = 0.01,
    flag = "visualizevel_scale",
    callback = function(value)
        Library.Flags["visualizevel_scale"] = value
    end
})

-- Добавляем тогл Velocity Anti Aim
PlayerMainSection:Toggle({
    name = "Velocity Anti Aim",
    default = false,
    flag = "player_velocityaa",
    callback = function(value)
        if value then
            -- Создаем соединение, если его еще нет
            if not o.velocityAAConnection then
                o.velocityAAConnection = o.rs.Heartbeat:Connect(function()
                    o.common_vars.char = o.lp.Character
                    if not o.common_vars.char then return end
                    
                    o.common_vars.hrp = o.common_vars.char:FindFirstChild("HumanoidRootPart")
                    if not o.common_vars.hrp then return end
                    
                    -- Сохраняем текущую скорость
                    o.common_vars.vel = o.common_vars.hrp.Velocity
                    
                    -- Устанавливаем анти-аим скорость
                    o.common_vars.hrp.Velocity = o.funcs.v3(0, 250, 0)
                    
                    -- Ждем рендер и возвращаем исходную скорость
                    o.rs.RenderStepped:Wait()
                    
                    -- Проверяем, что персонаж и HRP все еще существуют
                    if o.common_vars.char and o.common_vars.char.Parent and o.common_vars.hrp and o.common_vars.hrp.Parent then
                        o.common_vars.hrp.Velocity = o.common_vars.vel
                    end
                end)
            end
        else
            -- Отключаем соединение при выключении тогла
            if o.velocityAAConnection then
                o.velocityAAConnection:Disconnect()
                o.velocityAAConnection = nil
            end
        end
    end
})

-- Функция для изменения настроек отображения имен
function SetNameDisplay(enabled, mode)
    o.NameDisplayEnabled = enabled
    o.NameDisplayMode = mode or "display"
    
    -- Сохраняем режим в флагах для использования в других местах
    Library.Flags["name_display_actual_mode"] = o.NameDisplayMode
    
    -- Обновить все имена
    for _, player in ipairs(o.plrs:GetPlayers()) do
        if player.Character then
            o.common_vars.hum = player.Character:FindFirstChild("Humanoid")
            if o.common_vars.hum then
                -- Всегда сбрасываем параметры отображения к стандартным при выключении тогла
                if not o.NameDisplayEnabled then
                    -- Возвращаем исходное отображение имени
                    o.common_vars.hum.DisplayName = player.DisplayName
                    o.common_vars.hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Viewer
                    
                    -- Если были удалены BillboardGui на голове, восстановим систему имен
                    o.common_vars.head = player.Character:FindFirstChild("Head")
                    if o.common_vars.head then
                        -- Если никаких билбордов нет, это может означать, что они были удалены
                        o.common_vars.hasBillboard = false
                        for _, child in ipairs(o.common_vars.head:GetChildren()) do
                            if child:IsA("BillboardGui") then
                                o.common_vars.hasBillboard = true
                                break
                            end
                        end
                        
                        -- Принудительно обновляем персонажа для восстановления имен если нужно
                        if not o.common_vars.hasBillboard then
                            -- Обновляем настройки гуманоида для восстановления отображения имени
                            task.delay(0.1, function()
                                if o.common_vars.hum then
                                    o.common_vars.hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Subject
                                    task.delay(0.1, function()
                                        if o.common_vars.hum then
                                            o.common_vars.hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Viewer
                                        end
                                    end)
                                end
                            end)
                        end
                    end
                else
                    if o.NameDisplayMode == "display" then
                        o.common_vars.hum.DisplayName = player.DisplayName
                        o.common_vars.hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Viewer
                    elseif o.NameDisplayMode == "original" then
                        o.common_vars.hum.DisplayName = player.Name
                        o.common_vars.hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Viewer
                    elseif o.NameDisplayMode == "none" then
                        -- Полностью скрываем имя, устанавливая пустую строку И делая его прозрачным
                        o.common_vars.hum.DisplayName = ""
                        o.common_vars.hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
                        -- Для дополнительной надежности также пробуем другие методы скрытия имени
                        o.common_vars.head = player.Character:FindFirstChild("Head")
                        if o.common_vars.head then
                            -- Удаляем существующие текстовые метки над головой
                            for _, child in ipairs(o.common_vars.head:GetChildren()) do
                                if child:IsA("BillboardGui") then
                                    child:Destroy()
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    
    -- Настраиваем обработчики для новых игроков и персонажей
    if not Library.Flags["name_display_connection"] then
        o.nameDisplayConnection = o.plrs.PlayerAdded:Connect(function(player)
            player.CharacterAdded:Connect(function(character)
                o.common_vars.hum = character:FindFirstChild("Humanoid")
                if o.common_vars.hum then
                    if Library.Flags["player_alwaysshow"] then
                        o.common_vars.mode = Library.Flags["name_display_actual_mode"]
                        if o.common_vars.mode == "display" then
                            o.common_vars.hum.DisplayName = player.DisplayName
                            o.common_vars.hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Viewer
                        elseif o.common_vars.mode == "original" then
                            o.common_vars.hum.DisplayName = player.Name
                            o.common_vars.hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Viewer
                        elseif o.common_vars.mode == "none" then
                            o.common_vars.hum.DisplayName = ""
                            o.common_vars.hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
                            
                            -- Дополнительные методы для полного скрытия имени
                            task.delay(0.5, function() -- Небольшая задержка для гарантии загрузки головы
                                if player.Character and player.Character:FindFirstChild("Head") then
                                    for _, child in ipairs(player.Character.Head:GetChildren()) do
                                        if child:IsA("BillboardGui") then
                                            child:Destroy()
                                        end
                                    end
                                end
                            end)
                        end
                    else
                        -- Если тогл выключен, восстанавливаем имя
                        o.common_vars.hum.DisplayName = player.DisplayName
                        o.common_vars.hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Viewer
                    end
                end
            end)
        end)
        
        -- Сохраняем соединение для возможности отключения
        Library.Flags["name_display_connection"] = o.nameDisplayConnection
    end
end

-- Добавляем тогл Always Show с попапом для настройки отображения имен
PlayerMainSection:Toggle({
    name = "Always Show",
    default = false,
    flag = "player_alwaysshow",
    callback = function(value)
        -- Включаем/выключаем систему отображения имен
        SetNameDisplay(value, Library.Flags["name_display_actual_mode"])
    end
}):Popup({size = 150}):Dropdown({
    name = "Display Mode",
    values = {"Display Name", "Original Name", "No Name"},
    value = "Display Name",
    flag = "name_display_mode",
    callback = function(option)
        -- Определяем режим отображения на основе выбранного значения
        if option == "Display Name" then
            o.common_vars.mode = "display"
        elseif option == "Original Name" then
            o.common_vars.mode = "original"
        elseif option == "No Name" then
            o.common_vars.mode = "none"
        end
        
        -- Обновляем режим отображения имен, если система включена
        if Library.Flags["player_alwaysshow"] then
            SetNameDisplay(true, o.common_vars.mode)
        end
    end
})

-- Создаем секцию Movement во вкладке Player (справа)
PlayerMovementSection = PlayerTab:Section({name = "Movement", description = ">_<", side = "right"})

-- Создаем секцию Desynchronization во вкладке Player (справа)
PlayerDesyncSection = PlayerTab:Section({name = "Desynchronization", description = ">_<", side = "right"})

-- Определение объекта Desync
o.Desync = {
    Positions = {
        Old = nil,
        New = nil
    },
    Overwriten = nil,
    ClonedCharacter = nil,
    NewStatus = nil,
    LastActiveStatus = nil,
}

-- Проверка активности десинхронизации
function o.Desync:Active()
    o.common_vars.isActive = (self.NewStatus or Library.Flags["desync"] and Library.Flags["desync_key"]) and o.getHrp()
    
    -- Если статус десинка изменился, проверяем нужно ли обновить клон
    if self.LastActiveStatus ~= o.common_vars.isActive then
        self.LastActiveStatus = o.common_vars.isActive
        
        -- Проверяем, должен ли быть виден клон
        o.common_vars.shouldShowClone = o.common_vars.isActive and Library.Flags["desync_vis"]
        
        -- Управляем видимостью клона
        if o.common_vars.shouldShowClone and not self.ClonedCharacter then
            self:CloneCharacter()
        elseif not o.common_vars.shouldShowClone and self.ClonedCharacter then
            self:DestroyClonedCharacter()
        end
    end
    
    return o.common_vars.isActive
end

-- Установка статуса десинхронизации
function o.Desync:SetStatus(status)
    -- Запоминаем предыдущий статус
    o.common_vars.previousStatus = self.NewStatus
    
    -- Устанавливаем новый статус
    self.NewStatus = status
    
    -- Если статус изменился, обновляем клон
    if o.common_vars.previousStatus ~= status then
        -- Проверяем, должен ли быть виден клон
        o.common_vars.isActive = (status or Library.Flags["desync"] and Library.Flags["desync_key"]) and o.getHrp()
        o.common_vars.shouldShowClone = o.common_vars.isActive and Library.Flags["desync_vis"]
        
        -- Управляем видимостью клона
        if o.common_vars.shouldShowClone and not self.ClonedCharacter then
            self:CloneCharacter()
        elseif not o.common_vars.shouldShowClone and self.ClonedCharacter then
            self:DestroyClonedCharacter()
        end
    end
end

-- Получение позиций (старой и новой)
function o.Desync:GetPositions()
    o.common_vars.positions = self.Positions
    o.common_vars.status = self:Active()

    if not o.common_vars.status then
        return
    end

    return o.common_vars.positions.Old, o.common_vars.positions.New
end

-- Получение значения интерполяции
function o.Desync:GetLerpValue(pulse, min, max, speed)
    speed = speed or 1
    o.common_vars.normalizedSin = (math.sin(pulse * speed) + 1) / 2
    return min + o.common_vars.normalizedSin * (max - min)
end

-- Получение значения для конкретного типа позиции
function o.Desync:GetValue(pos_type)
    o.common_vars.clockPulse = os.clock()

    o.common_vars.mode = Library.Flags["desync_mode_" .. pos_type]
    o.common_vars.min = Library.Flags["desync_min_" .. pos_type] or tonumber(Library.Flags["desync_min_" .. pos_type .. "_text"]) or 0
    o.common_vars.max = Library.Flags["desync_max_" .. pos_type] or tonumber(Library.Flags["desync_max_" .. pos_type .. "_text"]) or 0
    o.common_vars.val = Library.Flags["desync_val_" .. pos_type] or tonumber(Library.Flags["desync_val_" .. pos_type .. "_text"]) or 0
    o.common_vars.speed = Library.Flags["desync_speed_" .. pos_type] or tonumber(Library.Flags["desync_speed_" .. pos_type .. "_text"]) or 1

    return 
        Library.Flags["desync_" .. pos_type] == true and 
            (o.common_vars.mode == "Static" and o.common_vars.val 
            or o.common_vars.mode == "Lerp" and self:GetLerpValue(o.common_vars.clockPulse, o.common_vars.min, o.common_vars.max, o.common_vars.speed)
            or o.common_vars.mode == "Random" and math.random(o.common_vars.min * 100, o.common_vars.max * 100) / 100)
        or not Library.Flags["desync_" .. pos_type] and 0
end

-- Перезапись позиции
function o.Desync:OverwritePosition(position)
    self.Overwriten = position
end

-- Удаление перезаписи позиции
function o.Desync:RemoveOverwrite()
    self.Overwriten = nil
end

-- Клонирование персонажа для визуализации
function o.Desync:CloneCharacter()
    o.common_vars.char = o.lp.Character

    if not o.common_vars.char then
        return
    end
    
    -- Уничтожаем предыдущий клон, если он существует
    self:DestroyClonedCharacter()

    o.common_vars.char.Archivable = true

    o.common_vars.clonedChar = o.common_vars.char:Clone()

    o.common_vars.clonedChar.Archivable = true
    o.common_vars.clonedChar.Name = "DesyncClone"
    o.common_vars.clonedChar.Parent = workspace

    o.common_vars.char.Archivable = false

    o.common_vars.hum = o.common_vars.clonedChar:FindFirstChildWhichIsA("Humanoid")
    o.common_vars.hrp = o.common_vars.clonedChar:FindFirstChild(o.r15.root)

    if not o.common_vars.hrp then
        o.common_vars.clonedChar:Destroy()
        return
    end

    -- Обработка всех частей клонированного персонажа
    for _, v in pairs(o.common_vars.clonedChar:GetDescendants()) do
        if v:IsA("Part") or v:IsA("MeshPart") or v:IsA("BasePart") then
            -- Настраиваем внешний вид частей
            if v.Transparency ~= 1 then
                o.common_vars.color = Library.Flags["desync_vis_color"] or {c = o.funcs.rgb(255, 0, 0), a = 0.5}
                
                -- Определяем материал
                o.common_vars.materialName = Library.Flags["desync_vis_material"] or "ForceField"
                o.common_vars.material = o.getMaterial(o.common_vars.materialName)
                
                v.Material = o.common_vars.material
                v.Color = o.common_vars.color.c
                v.Transparency = 0.5 -- Фиксированная прозрачность для лучшей видимости
            end
            
            -- Отключаем коллизии и делаем части якорными
            v.CanCollide = false
            v.Anchored = true
            
            -- Отключаем физику
            if v:IsA("BasePart") then
                v.Massless = true
                v.Velocity = o.funcs.v3(0, 0, 0)
                v.RotVelocity = o.funcs.v3(0, 0, 0)
            end
        elseif v:IsA("Accessory") or v:IsA("Clothing") or v:IsA("ShirtGraphic") or v:IsA("Script") or v:IsA("LocalScript") then
            -- Удаляем аксессуары, одежду и скрипты
            v:Destroy()
        end
    end

    -- Удаляем гуманоида
    if o.common_vars.hum then
        o.common_vars.hum:Destroy()
    end

    -- Сохраняем ссылку на клонированного персонажа
    self.ClonedCharacter = {
        Character = o.common_vars.clonedChar,
        RootPart = o.common_vars.hrp
    }
    
    -- Возвращаем созданный клон
    return self.ClonedCharacter
end

-- Обновление визуального представления персонажа
function o.Desync:UpdateCharacter()
    o.common_vars.clonedChar = self.ClonedCharacter

    if not o.common_vars.clonedChar or not o.common_vars.clonedChar.Character then
        -- Если клон не существует, создаем его
        if Library.Flags["desync_vis"] then
            self:CloneCharacter()
        end
        return
    end

    -- Получаем текущие настройки внешнего вида
    o.common_vars.color = Library.Flags["desync_vis_color"] or {c = o.funcs.rgb(255, 0, 0), a = 0.5}
    
    -- Определяем материал
    o.common_vars.materialName = Library.Flags["desync_vis_material"] or "ForceField"
    o.common_vars.material = o.getMaterial(o.common_vars.materialName)

    -- Обновляем внешний вид всех частей
    for _, v in pairs(o.common_vars.clonedChar.Character:GetDescendants()) do
        if v:IsA("Part") or v:IsA("MeshPart") or v:IsA("BasePart") then
            if v.Transparency ~= 1 then
                v.Material = o.common_vars.material
                v.Color = o.common_vars.color.c
                v.Transparency = 0.5 -- Фиксированная прозрачность для лучшей видимости
            end
            
            -- Убедимся, что части остаются якорными и не имеют коллизий
            v.CanCollide = false
            v.Anchored = true
        end
    end
    
    -- Проверяем, что RootPart существует и обновляем его позицию
    if o.common_vars.clonedChar.RootPart then
        o.common_vars.hrp = o.getHrp()
        if o.common_vars.hrp then
            o.common_vars.clonedChar.RootPart.CFrame = o.common_vars.hrp.CFrame
        end
    end
end

-- Уничтожение клонированного персонажа
function o.Desync:DestroyClonedCharacter()
    o.common_vars.clonedCharacter = self.ClonedCharacter

    if o.common_vars.clonedCharacter and o.common_vars.clonedCharacter.Character then
        o.common_vars.clonedCharacter.Character:Destroy()
        self.ClonedCharacter = nil
        return true
    end
    
    return false
end

-- Основная функция десинхронизации
function o.Desync:Think()
    o.common_vars.hrp = o.getHrp()
    if not o.common_vars.hrp then return end
    
    o.common_vars.isActive = self:Active()
    o.common_vars.positions = self.Positions
    o.common_vars.clonedChar = self.ClonedCharacter
    
    -- Проверяем, должен ли клон существовать (оба тогла должны быть включены и кейбинд активен)
    o.common_vars.shouldShowClone = Library.Flags["desync_vis"] and o.common_vars.isActive

    -- Управление клоном в зависимости от статуса визуализации и десинка
    if o.common_vars.shouldShowClone and not o.common_vars.clonedChar then
        self:CloneCharacter()
        o.common_vars.clonedChar = self.ClonedCharacter
    elseif not o.common_vars.shouldShowClone and o.common_vars.clonedChar then
        self:DestroyClonedCharacter()
        o.common_vars.clonedChar = nil
    end

    -- Если десинк не активен
    if not o.common_vars.isActive then
        o.common_vars.positions.Old = nil
        o.common_vars.positions.New = nil
        return
    end

    -- Запоминаем исходную позицию
    o.common_vars.positions.Old = o.common_vars.hrp.CFrame

    -- Применяем десинхронизацию
    if self.Overwriten then
        o.common_vars.hrp.CFrame = o.funcs.cf(self.Overwriten.X, self.Overwriten.Y, self.Overwriten.Z)
    else
        o.common_vars.desyncFactor = o.funcs.cf(
            self:GetValue("x"),
            self:GetValue("y"),
            self:GetValue("z")
        )

        o.common_vars.desyncFactor = o.common_vars.desyncFactor * CFrame.Angles(
            math.rad(self:GetValue("pitch")),
            math.rad(self:GetValue("yaw")),
            math.rad(self:GetValue("roll"))
        )

        o.common_vars.hrp.CFrame = o.common_vars.hrp.CFrame * o.common_vars.desyncFactor
    end

    -- Запоминаем новую позицию
    o.common_vars.positions.New = o.common_vars.hrp.CFrame

    -- Обновляем позицию клона, если он существует
    if o.common_vars.clonedChar and o.common_vars.clonedChar.RootPart then
        -- Устанавливаем позицию клона в позицию десинка
        o.common_vars.clonedChar.RootPart.CFrame = o.common_vars.positions.New
        
        -- Обновляем все части клона
        for _, part in pairs(o.common_vars.clonedChar.Character:GetDescendants()) do
            if part:IsA("BasePart") and part ~= o.common_vars.clonedChar.RootPart then
                -- Получаем относительное положение части в оригинальном персонаже
                o.common_vars.originalPart = o.lp.Character:FindFirstChild(part.Name)
                if o.common_vars.originalPart and o.common_vars.originalPart:IsA("BasePart") then
                    -- Вычисляем относительное положение к корню
                    o.common_vars.relativeOffset = o.common_vars.hrp.CFrame:ToObjectSpace(o.common_vars.originalPart.CFrame)
                    -- Применяем это же относительное положение к клону
                    part.CFrame = o.common_vars.positions.New:ToWorldSpace(o.common_vars.relativeOffset)
                end
            end
        end
    end

    -- Ждем кадр и возвращаем персонажа в исходную позицию
    o.rs.RenderStepped:Wait()
    o.common_vars.hrp.CFrame = o.common_vars.positions.Old
end

-- Создаем соединение для обновления десинка
if o.desyncConnection then
    o.desyncConnection:Disconnect()
    o.desyncConnection = nil
end

o.desyncConnection = o.rs.Heartbeat:Connect(function()
    o.Desync:Think()
end)

-- Хук для обработки десинхронизации
-- Примечание: hookmetamethod и checkcaller - это функции API эксплойта, не стандартные в Lua/Luau
o.OldIndex = nil

-- Определяем hookmetamethod и checkcaller, если они не существуют
if not _G.hookmetamethod_defined then
    _G.hookmetamethod_defined = true
    if not hookmetamethod then
        hookmetamethod = function(obj, metamethod, hook)
            -- Заглушка для hookmetamethod
            o.common_vars.original = obj[metamethod]
            obj[metamethod] = hook
            return o.common_vars.original
        end
    end
    
    if not checkcaller then
        checkcaller = function()
            -- Заглушка для checkcaller
            return false
        end
    end
end

if not hookmetamethod then
    o.OldIndex = function(self, prop)
        if prop == "CFrame" then
            if o.Desync:Active() and Library.Flags["desync_hook"] and self == o.getHrp() then
                o.common_vars.oldPosition = o.Desync:GetPositions()

                if o.common_vars.oldPosition then
                    return o.common_vars.oldPosition
                end
            end
        end
        
        return self[prop]
    end
else
    o.OldIndex = hookmetamethod(game, "__index", function(self, prop)
        if not checkcaller() then
            if prop == "CFrame" then
                if o.Desync:Active() and Library.Flags["desync_hook"] and self == o.getHrp() then
                    o.common_vars.oldPosition = o.Desync:GetPositions()

                    if o.common_vars.oldPosition then
                        return o.common_vars.oldPosition
                    end
                end
            end
        end

        return o.OldIndex(self, prop)
    end)
end

-- Добавляем тогл Enabled для десинка с кейбиндом
o.DesyncToggle = PlayerDesyncSection:Toggle({
    name = "Enabled",
    default = false,
    flag = "desync",
    callback = function(value)
        if not value then
            o.Desync:SetStatus(nil)
            o.Desync:RemoveOverwrite()
            
            -- Проверяем, нужно ли скрыть клон
            if o.Desync.ClonedCharacter and Library.Flags["desync_vis"] then
                -- Если Visualize включен, но Enabled выключен, удаляем клон
                o.Desync:DestroyClonedCharacter()
            end
        else
            -- Если включили Enabled и Visualize тоже включен, создаем клон
            if Library.Flags["desync_vis"] and not o.Desync.ClonedCharacter then
                o.Desync:CloneCharacter()
            end
        end
    end
})

-- Добавляем кейбинд для активации десинка
o.DesyncToggle:Keybind({
    flag = "desync_key",
    callback = function(key)
        -- Проверяем состояние кейбинда и тогла визуализации
        o.common_vars.isDesyncActive = Library.Flags["desync"] and Library.Flags["desync_key"]
        o.common_vars.shouldShowClone = o.common_vars.isDesyncActive and Library.Flags["desync_vis"]
        
        -- Управляем видимостью клона в зависимости от состояния десинка
        if o.common_vars.shouldShowClone and not o.Desync.ClonedCharacter then
            o.Desync:CloneCharacter()
        elseif not o.common_vars.shouldShowClone and o.Desync.ClonedCharacter then
            o.Desync:DestroyClonedCharacter()
        end
    end
})

-- Добавляем тогл Use Hook для десинка
PlayerDesyncSection:Toggle({
    name = "Use Hook",
    default = false,
    flag = "desync_hook"
})

-- Добавляем тогл X Position с попапом
o.XPositionToggle = PlayerDesyncSection:Toggle({
    name = "X Position",
    default = false,
    flag = "desync_x"
})

-- Создаем один попап для X Position
o.XPositionPopup = o.XPositionToggle:Popup({size = 150})

-- Добавляем выпадающий список для режима X Position
o.XPositionPopup:Dropdown({
    name = "Mode",
    values = {"Static", "Lerp", "Random"},
    value = "Static",
    flag = "desync_mode_x"
})

-- Добавляем текстбокс для значения X Position
o.XPositionPopup:Textbox({
    name = "Static Value",
    description = "Position offset in studs",
    placeholder = "0",
    default = "0",
    flag = "desync_val_x_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_val_x"] = o.common_vars.value
        end
    end
})

-- Добавляем текстбоксы для мин/макс значений X Position
o.XPositionPopup:Textbox({
    name = "Minimum",
    description = "Minimum position offset",
    placeholder = "-5",
    default = "-5",
    flag = "desync_min_x_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_min_x"] = o.common_vars.value
        end
    end
})

o.XPositionPopup:Textbox({
    name = "Maximum",
    description = "Maximum position offset",
    placeholder = "5",
    default = "5",
    flag = "desync_max_x_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_max_x"] = o.common_vars.value
        end
    end
})

-- Добавляем текстбокс для скорости Lerp X Position
o.XPositionPopup:Textbox({
    name = "Lerp Speed",
    description = "Animation speed for Lerp mode",
    placeholder = "1",
    default = "1",
    flag = "desync_speed_x_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_speed_x"] = o.common_vars.value
        end
    end
})

-- Добавляем тогл Y Position с попапом
o.YPositionToggle = PlayerDesyncSection:Toggle({
    name = "Y Position",
    default = false,
    flag = "desync_y"
})

-- Создаем один попап для Y Position
o.YPositionPopup = o.YPositionToggle:Popup({size = 150})

-- Добавляем выпадающий список для режима Y Position
o.YPositionPopup:Dropdown({
    name = "Mode",
    values = {"Static", "Lerp", "Random"},
    value = "Static",
    flag = "desync_mode_y"
})

-- Добавляем текстбокс для значения Y Position
o.YPositionPopup:Textbox({
    name = "Static Value",
    description = "Vertical offset in studs",
    placeholder = "0",
    default = "0",
    flag = "desync_val_y_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_val_y"] = o.common_vars.value
        end
    end
})

-- Добавляем текстбоксы для мин/макс значений Y Position
o.YPositionPopup:Textbox({
    name = "Minimum",
    description = "Minimum vertical offset",
    placeholder = "-5",
    default = "-5",
    flag = "desync_min_y_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_min_y"] = o.common_vars.value
        end
    end
})

o.YPositionPopup:Textbox({
    name = "Maximum",
    description = "Maximum vertical offset",
    placeholder = "5",
    default = "5",
    flag = "desync_max_y_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_max_y"] = o.common_vars.value
        end
    end
})

-- Добавляем текстбокс для скорости Lerp Y Position
o.YPositionPopup:Textbox({
    name = "Lerp Speed",
    description = "Animation speed for Lerp mode",
    placeholder = "1",
    default = "1",
    flag = "desync_speed_y_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_speed_y"] = o.common_vars.value
        end
    end
})

-- Добавляем тогл Z Position с попапом
o.ZPositionToggle = PlayerDesyncSection:Toggle({
    name = "Z Position",
    default = false,
    flag = "desync_z"
})

-- Создаем один попап для Z Position
o.ZPositionPopup = o.ZPositionToggle:Popup({size = 150})

-- Добавляем выпадающий список для режима Z Position
o.ZPositionPopup:Dropdown({
    name = "Mode",
    values = {"Static", "Lerp", "Random"},
    value = "Static",
    flag = "desync_mode_z"
})

-- Добавляем текстбокс для значения Z Position
o.ZPositionPopup:Textbox({
    name = "Static Value",
    description = "Forward/back offset in studs",
    placeholder = "0",
    default = "0",
    flag = "desync_val_z_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_val_z"] = o.common_vars.value
        end
    end
})

-- Добавляем текстбоксы для мин/макс значений Z Position
o.ZPositionPopup:Textbox({
    name = "Minimum",
    description = "Minimum forward/back offset",
    placeholder = "-5",
    default = "-5",
    flag = "desync_min_z_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_min_z"] = o.common_vars.value
        end
    end
})

o.ZPositionPopup:Textbox({
    name = "Maximum",
    description = "Maximum forward/back offset",
    placeholder = "5",
    default = "5",
    flag = "desync_max_z_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_max_z"] = o.common_vars.value
        end
    end
})

-- Добавляем текстбокс для скорости Lerp Z Position
o.ZPositionPopup:Textbox({
    name = "Lerp Speed",
    description = "Animation speed for Lerp mode",
    placeholder = "1",
    default = "1",
    flag = "desync_speed_z_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_speed_z"] = o.common_vars.value
        end
    end
})

-- Добавляем тогл Pitch Position с попапом
o.PitchPositionToggle = PlayerDesyncSection:Toggle({
    name = "Pitch Position",
    default = false,
    flag = "desync_pitch"
})

-- Создаем один попап для Pitch Position
o.PitchPositionPopup = o.PitchPositionToggle:Popup({size = 150})

-- Добавляем выпадающий список для режима Pitch Position
o.PitchPositionPopup:Dropdown({
    name = "Mode",
    values = {"Static", "Lerp", "Random"},
    value = "Static",
    flag = "desync_mode_pitch"
})

-- Добавляем текстбокс для значения Pitch Position
o.PitchPositionPopup:Textbox({
    name = "Static Value",
    description = "Up/down rotation in degrees",
    placeholder = "0",
    default = "0",
    flag = "desync_val_pitch_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_val_pitch"] = o.common_vars.value
        end
    end
})

-- Добавляем текстбоксы для мин/макс значений Pitch Position
o.PitchPositionPopup:Textbox({
    name = "Minimum",
    description = "Minimum pitch angle",
    placeholder = "-90",
    default = "-90",
    flag = "desync_min_pitch_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_min_pitch"] = o.common_vars.value
        end
    end
})

o.PitchPositionPopup:Textbox({
    name = "Maximum",
    description = "Maximum pitch angle",
    placeholder = "90",
    default = "90",
    flag = "desync_max_pitch_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_max_pitch"] = o.common_vars.value
        end
    end
})

-- Добавляем текстбокс для скорости Lerp Pitch Position
o.PitchPositionPopup:Textbox({
    name = "Lerp Speed",
    description = "Animation speed for Lerp mode",
    placeholder = "1",
    default = "1",
    flag = "desync_speed_pitch_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_speed_pitch"] = o.common_vars.value
        end
    end
})

-- Добавляем тогл Yaw Position с попапом
o.YawPositionToggle = PlayerDesyncSection:Toggle({
    name = "Yaw Position",
    default = false,
    flag = "desync_yaw"
})

-- Создаем один попап для Yaw Position
o.YawPositionPopup = o.YawPositionToggle:Popup({size = 150})

-- Добавляем выпадающий список для режима Yaw Position
o.YawPositionPopup:Dropdown({
    name = "Mode",
    values = {"Static", "Lerp", "Random"},
    value = "Static",
    flag = "desync_mode_yaw"
})

-- Добавляем текстбокс для значения Yaw Position
o.YawPositionPopup:Textbox({
    name = "Static Value",
    description = "Left/right rotation in degrees",
    placeholder = "0",
    default = "0",
    flag = "desync_val_yaw_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_val_yaw"] = o.common_vars.value
        end
    end
})

-- Добавляем текстбоксы для мин/макс значений Yaw Position
o.YawPositionPopup:Textbox({
    name = "Minimum",
    description = "Minimum yaw angle",
    placeholder = "-90",
    default = "-90",
    flag = "desync_min_yaw_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_min_yaw"] = o.common_vars.value
        end
    end
})

o.YawPositionPopup:Textbox({
    name = "Maximum",
    description = "Maximum yaw angle",
    placeholder = "90",
    default = "90",
    flag = "desync_max_yaw_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_max_yaw"] = o.common_vars.value
        end
    end
})

-- Добавляем текстбокс для скорости Lerp Yaw Position
o.YawPositionPopup:Textbox({
    name = "Lerp Speed",
    description = "Animation speed for Lerp mode",
    placeholder = "1",
    default = "1",
    flag = "desync_speed_yaw_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_speed_yaw"] = o.common_vars.value
        end
    end
})

-- Добавляем тогл Roll Position с попапом
o.RollPositionToggle = PlayerDesyncSection:Toggle({
    name = "Roll Position",
    default = false,
    flag = "desync_roll"
})

-- Создаем один попап для Roll Position
o.RollPositionPopup = o.RollPositionToggle:Popup({size = 150})

-- Добавляем выпадающий список для режима Roll Position
o.RollPositionPopup:Dropdown({
    name = "Mode",
    values = {"Static", "Lerp", "Random"},
    value = "Static",
    flag = "desync_mode_roll"
})

-- Добавляем текстбокс для значения Roll Position
o.RollPositionPopup:Textbox({
    name = "Static Value",
    description = "Tilt rotation in degrees",
    placeholder = "0",
    default = "0",
    flag = "desync_val_roll_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_val_roll"] = o.common_vars.value
        end
    end
})

-- Добавляем текстбоксы для мин/макс значений Roll Position
o.RollPositionPopup:Textbox({
    name = "Minimum",
    description = "Minimum roll angle",
    placeholder = "-90",
    default = "-90",
    flag = "desync_min_roll_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_min_roll"] = o.common_vars.value
        end
    end
})

o.RollPositionPopup:Textbox({
    name = "Maximum",
    description = "Maximum roll angle",
    placeholder = "90",
    default = "90",
    flag = "desync_max_roll_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_max_roll"] = o.common_vars.value
        end
    end
})

-- Добавляем текстбокс для скорости Lerp Roll Position
o.RollPositionPopup:Textbox({
    name = "Lerp Speed",
    description = "Animation speed for Lerp mode",
    placeholder = "1",
    default = "1",
    flag = "desync_speed_roll_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_speed_roll"] = o.common_vars.value
        end
    end
})

-- Добавляем тогл Void с кейбиндом
o.VoidToggle = PlayerDesyncSection:Toggle({
    name = "Void",
    default = false,
    flag = "desync_void",
    callback = function(value)
        if value and Library.Flags["desync_void_key"] then
            o.Desync:SetStatus(true)
            o.Desync:OverwritePosition(o.funcs.v3(9e9, -9e9, 9e9))
            
            -- Обновляем клон, если включена визуализация
            if Library.Flags["desync_vis"] and not o.Desync.ClonedCharacter then
                o.Desync:CloneCharacter()
            end
        else
            o.Desync:SetStatus(nil)
            o.Desync:RemoveOverwrite()
            
            -- Проверяем, нужно ли скрыть клон
            o.common_vars.isDesyncActive = Library.Flags["desync"] and Library.Flags["desync_key"]
            if not o.common_vars.isDesyncActive and o.Desync.ClonedCharacter then
                o.Desync:DestroyClonedCharacter()
            end
        end
    end
})

-- Добавляем кейбинд для Void
o.VoidToggle:Keybind({
    flag = "desync_void_key",
    callback = function(key)
        if key and Library.Flags["desync_void"] then
            o.Desync:SetStatus(true)
            o.Desync:OverwritePosition(o.funcs.v3(9e9, -9e9, 9e9))
        else
            o.Desync:SetStatus(nil)
            o.Desync:RemoveOverwrite()
        end
    end
})

-- Добавляем тогл Visualize с колорпикером
o.VisualizeToggle = PlayerDesyncSection:Toggle({
    name = "Visualize",
    default = false,
    flag = "desync_vis",
    callback = function(value)
        -- Проверяем, должен ли быть виден клон (оба тогла должны быть включены)
        o.common_vars.shouldShowClone = value and Library.Flags["desync"]
        
        if o.common_vars.shouldShowClone then
            -- Принудительно создаем клон при включении обоих тоглов
            if not o.Desync.ClonedCharacter then
                o.Desync:CloneCharacter()
            end
        else
            -- Принудительно удаляем клон при выключении любого из тоглов
            if o.Desync.ClonedCharacter then
                o.Desync:DestroyClonedCharacter()
            end
        end
    end
})

-- Создаем один попап для Visualize
o.VisualizePopup = o.VisualizeToggle:Popup({size = 150})

-- Добавляем колорпикер для цвета визуализации
o.VisualizePopup:Colorpicker({
    name = "Color",
    default = o.funcs.rgb(255, 0, 0),
    flag = "desync_vis_color",
    callback = function(color)
        -- Обновляем внешний вид клона при изменении цвета
        if o.Desync.ClonedCharacter then
            o.Desync:UpdateCharacter()
        end
    end
})

-- Добавляем выпадающий список для материала визуализации
o.VisualizePopup:Dropdown({
    name = "Material",
    values = {"ForceField", "Neon", "SmoothPlastic", "Glass"},
    value = "ForceField",
    flag = "desync_vis_material",
    callback = function(material)
        -- Обновляем внешний вид клона при изменении материала
        if o.Desync.ClonedCharacter then
            o.Desync:UpdateCharacter()
        end
    end
})

-- Конфигурация SpeedHack
o.SpeedhackConfig = {
    Enabled = false,
    Active = false,
    Speed = 50
}

-- Конфигурация Fly
o.FlyConfig = {
    Enabled = false,
    Active = false,
    UseCamera = false,     -- Режим следования за направлением камеры
    Speed = 1,             -- Базовая скорость
    SpeedMultiplier = 5,   -- Общий множитель скорости
    VerticalSpeedMultiplier = 0.3, -- Множитель для вертикального движения
    UpKey = nil,           -- Клавиша для движения вверх (по умолчанию не назначена)
    DownKey = nil          -- Клавиша для движения вниз (по умолчанию не назначена)
}

-- Функция для включения/выключения коллизий у персонажа
function setNoClip(character, state)
    if not character then return end
    
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA('BasePart') then
            if state then
                -- Сохраняем оригинальные значения
                if not part:GetAttribute('OriginalCollision') then
                    part:SetAttribute('OriginalCollision', part.CanCollide)
                    part:SetAttribute('OriginalTouch', part.CanTouch)
                    if part:GetAttribute('CanQuery') ~= nil then
                        part:SetAttribute('OriginalQuery', part.CanQuery)
                    end
                end
                -- Отключаем коллизии
                part.CanCollide = false
                part.CanTouch = false
                part.CanQuery = false
            else
                -- Восстанавливаем оригинальные значения
                if part:GetAttribute('OriginalCollision') ~= nil then
                    part.CanCollide = part:GetAttribute('OriginalCollision')
                    part.CanTouch = part:GetAttribute('OriginalTouch')
                    if part:GetAttribute('OriginalQuery') ~= nil then
                        part.CanQuery = part:GetAttribute('OriginalQuery')
                    end
                    -- Очищаем атрибуты
                    part:SetAttribute('OriginalCollision', nil)
                    part:SetAttribute('OriginalTouch', nil)
                    part:SetAttribute('OriginalQuery', nil)
                end
            end
        end
    end
end

-- Основная функция полета
function updateFly(character)
    if o.FlyLoop then
        o.FlyLoop:Disconnect()
        o.FlyLoop = nil
    end
    
    if not character or not (o.FlyConfig.Enabled and o.FlyConfig.Active) then 
        return 
    end
    
    -- Включаем NoClip
    setNoClip(character, true)
    
    -- Создаем основной цикл полета
    o.FlyLoop = o.rs.Stepped:Connect(function()
        o.common_vars.char = o.lp.Character
        if not o.common_vars.char then return end
        
        o.common_vars.hrp = o.common_vars.char:FindFirstChild(o.r15.root)
        o.common_vars.hum = o.common_vars.char:FindFirstChild('Humanoid')
        if not o.common_vars.hrp or not o.common_vars.hum then return end
        
        -- Рассчитываем скорость с учетом множителей
        o.common_vars.baseSpeed = o.FlyConfig.Speed * o.FlyConfig.SpeedMultiplier
        o.common_vars.verticalSpeed = o.common_vars.baseSpeed * o.FlyConfig.VerticalSpeedMultiplier
        o.common_vars.velocity = o.funcs.v3(0, 0, 0)
        
        o.common_vars.camCF = o.camera.CFrame
        o.common_vars.moveDir = o.funcs.v3()
        
        -- Обработка горизонтального движения (всегда с учетом направления камеры)
        if o.uis:IsKeyDown(Enum.KeyCode.W) then
            o.common_vars.moveDir = o.common_vars.moveDir + o.funcs.v3(o.common_vars.camCF.LookVector.X, 0, o.common_vars.camCF.LookVector.Z).Unit -- Вперед (только XZ)
        end
        if o.uis:IsKeyDown(Enum.KeyCode.A) then
            o.common_vars.moveDir = o.common_vars.moveDir - o.funcs.v3(o.common_vars.camCF.RightVector.X, 0, o.common_vars.camCF.RightVector.Z).Unit -- Влево (только XZ)
        end
        if o.uis:IsKeyDown(Enum.KeyCode.S) then
            o.common_vars.moveDir = o.common_vars.moveDir - o.funcs.v3(o.common_vars.camCF.LookVector.X, 0, o.common_vars.camCF.LookVector.Z).Unit -- Назад (только XZ)
        end
        if o.uis:IsKeyDown(Enum.KeyCode.D) then
            o.common_vars.moveDir = o.common_vars.moveDir + o.funcs.v3(o.common_vars.camCF.RightVector.X, 0, o.common_vars.camCF.RightVector.Z).Unit -- Вправо (только XZ)
        end
        
        -- Нормализация и применение скорости к горизонтальному движению
        if o.common_vars.moveDir.Magnitude > 0 then
            o.common_vars.moveDir = o.common_vars.moveDir.Unit * o.common_vars.baseSpeed
            o.common_vars.velocity = o.funcs.v3(o.common_vars.moveDir.X, o.common_vars.velocity.Y, o.common_vars.moveDir.Z)
        end
        
        -- Обработка вертикального движения в зависимости от режима
        if o.FlyConfig.UseCamera then
            -- Режим с учетом направления камеры
            if o.uis:IsKeyDown(Enum.KeyCode.W) then
                o.common_vars.velocity = o.common_vars.velocity + o.funcs.v3(0, o.common_vars.camCF.LookVector.Y * o.common_vars.baseSpeed, 0) -- Вертикальное движение по направлению камеры
            end
            if o.uis:IsKeyDown(Enum.KeyCode.S) then
                o.common_vars.velocity = o.common_vars.velocity - o.funcs.v3(0, o.common_vars.camCF.LookVector.Y * o.common_vars.baseSpeed, 0) -- Вертикальное движение по направлению камеры
            end
        end
        
        -- Дополнительные кнопки для вертикального движения (работают в обоих режимах)
        if o.FlyConfig.UpKey and o.uis:IsKeyDown(o.FlyConfig.UpKey) then
            o.common_vars.velocity = o.common_vars.velocity + o.funcs.v3(0, o.common_vars.verticalSpeed, 0) -- Вверх
        end
        if o.FlyConfig.DownKey and o.uis:IsKeyDown(o.FlyConfig.DownKey) then
            o.common_vars.velocity = o.common_vars.velocity - o.funcs.v3(0, o.common_vars.verticalSpeed, 0) -- Вниз
        end
        
        -- Применяем скорость
        o.common_vars.hrp.Velocity = o.common_vars.velocity
        o.common_vars.hum:ChangeState('Freefall')
    end)
end

-- Останавливает полет
function stopFly()
    if o.FlyLoop then
        o.FlyLoop:Disconnect()
        o.FlyLoop = nil
    end
    
    o.common_vars.char = o.lp.Character
    setNoClip(o.common_vars.char, false)
    
    if o.common_vars.char then
        o.common_vars.hrp = o.common_vars.char:FindFirstChild(o.r15.root)
        o.common_vars.hum = o.common_vars.char:FindFirstChild('Humanoid')
        
        -- Плавное падение при выключении
        if o.common_vars.hrp then
            o.common_vars.hrp.Velocity = o.funcs.v3(0, -2, 0)
            o.common_vars.tempConn = o.rs.Stepped:Connect(function()
                if not o.common_vars.hrp or not o.common_vars.hrp.Parent then
                    o.common_vars.tempConn:Disconnect()
                    return
                end
                o.common_vars.hrp.Velocity = o.funcs.v3(0, o.common_vars.hrp.Velocity.Y, 0)
                o.common_vars.tempConn:Disconnect()
            end)
        end
        
        if o.common_vars.hum then
            o.common_vars.hum:ChangeState('Landing')
        end
    end
end

-- Функция обновления SpeedHack
function updateSpeedHack(character)
    if not character then return end
    
    -- Используем функции из таблицы оптимизации для получения частей персонажа
    o.common_vars.rootPart = character:WaitForChild(o.r15.root)
    o.common_vars.humanoid = character:WaitForChild('Humanoid')
    
    -- Отключаем предыдущее соединение, если оно существует
    if o.speedHackConnection then
        o.speedHackConnection:Disconnect()
    end
    
    -- Создаем новое соединение с Heartbeat, используя o.rs из таблицы оптимизации
    o.speedHackConnection = o.rs.Heartbeat:Connect(function(dt)
        if o.SpeedhackConfig.Enabled and o.SpeedhackConfig.Active then
            o.common_vars.move = o.common_vars.humanoid.MoveDirection
            if o.common_vars.move.Magnitude > 0 then
                -- Используем функцию из таблицы оптимизации для создания CFrame
                o.common_vars.newPos = o.common_vars.rootPart.Position + (o.common_vars.move.Unit * o.SpeedhackConfig.Speed * dt)
                o.common_vars.rootPart.CFrame = o.funcs.cf(o.common_vars.newPos.X, o.common_vars.newPos.Y, o.common_vars.newPos.Z) * CFrame.Angles(0, math.atan2(-o.common_vars.move.X, -o.common_vars.move.Z), 0)
            end
        end
    end)
end

-- Добавляем тогл SpeedHack с попапом
o.SpeedHackToggle = PlayerMovementSection:Toggle({
    name = "Speed Hack",
    default = false,
    flag = "player_speedhack",
    callback = function(value)
        o.SpeedhackConfig.Enabled = value
        
        -- Обновляем SpeedHack при включении/выключении
        if value then
            if o.lp.Character then
                updateSpeedHack(o.lp.Character)
                -- Добавляем уведомление при включении
                Library.Notification({Name = "Speedhack", Description = "Press keybind to activate"})
            end
        else
            -- Отключаем соединение при выключении
            if o.speedHackConnection then
                o.speedHackConnection:Disconnect()
                o.speedHackConnection = nil
            end
            -- Сбрасываем флаг активности
            o.SpeedhackConfig.Active = false
        end
    end
})

-- Создаем один попап для настроек SpeedHack
o.SpeedHackPopup = o.SpeedHackToggle:Popup({size = 150})

-- Добавляем кейбинд в попап для SpeedHack
o.SpeedHackPopup:Keybind({
    name = "Activation Key",
    flag = "speedhack_key",
    callback = function()
        -- Переключаем активность SpeedHack только если включен тогл
        if o.SpeedhackConfig.Enabled then
            o.SpeedhackConfig.Active = not o.SpeedhackConfig.Active
            
            -- Показываем уведомление о текущем состоянии
            o.common_vars.status = o.SpeedhackConfig.Active and "on" or "off"
            Library.Notification({Name = "Speedhack", Description = o.common_vars.status})
        end
    end
})

-- Добавляем текстбокс для настройки скорости в попап
o.SpeedHackPopup:Textbox({
    name = "Speed",
    placeholder = "50",
    default = "50",
    flag = "speedhack_speed_text",
    callback = function(text)
        -- Преобразуем текст в число
        o.common_vars.speed = tonumber(text)
        
        -- Проверяем, что введено число
        if o.common_vars.speed then
            o.SpeedhackConfig.Speed = o.common_vars.speed
        end
    end
})

-- Добавляем тогл Fly с попапом
o.FlyToggle = PlayerMovementSection:Toggle({
    name = "Fly Hack",
    default = false,
    flag = "player_fly",
    callback = function(value)
        o.FlyConfig.Enabled = value
        
        if value then
            if o.lp.Character then
                -- Не активируем полет автоматически, только включаем возможность
                Library.Notification({Name = "Fly", Description = "Press keybind to activate"})
            end
        else
            -- При выключении тогла останавливаем полет
            o.FlyConfig.Active = false
            stopFly()
        end
    end
})

-- Создаем один попап для настроек Fly
o.FlyPopup = o.FlyToggle:Popup({size = 150})

-- Добавляем кейбинд для активации в попап для Fly
o.FlyPopup:Keybind({
    name = "Activation Key",
    flag = "fly_key",
    callback = function()
        -- Переключаем активность Fly только если включен тогл
        if o.FlyConfig.Enabled then
            o.FlyConfig.Active = not o.FlyConfig.Active
            
            -- Показываем уведомление о текущем состоянии
            o.common_vars.status = o.FlyConfig.Active and "on" or "off"
            Library.Notification({Name = "Fly", Description = o.common_vars.status})
            
            -- Обновляем состояние полета
            if o.FlyConfig.Active then
                updateFly(o.lp.Character)
            else
                stopFly()
            end
        end
    end
})

-- Добавляем тогл UseCamera в попап
o.FlyPopup:Toggle({
    name = "UseCamera",
    default = false,
    flag = "fly_usecamera",
    callback = function(value)
        o.FlyConfig.UseCamera = value
    end
})

-- Добавляем кейбинд для движения вверх
o.FlyPopup:Keybind({
    name = "Up Key",
    flag = "fly_up_key",
    callback = function(key)
        -- Сохраняем ключ в конфигурации
        o.FlyConfig.UpKey = key == Enum.KeyCode.Unknown and nil or key
    end
})

-- Добавляем кейбинд для движения вниз
o.FlyPopup:Keybind({
    name = "Down Key",
    flag = "fly_down_key",
    callback = function(key)
        -- Сохраняем ключ в конфигурации
        o.FlyConfig.DownKey = key == Enum.KeyCode.Unknown and nil or key
    end
})

-- Добавляем текстбокс для настройки множителя скорости
o.FlyPopup:Textbox({
    name = "Speed",
    placeholder = "5",
    default = "5",
    flag = "fly_speed_text",
    callback = function(text)
        -- Преобразуем текст в число
        o.common_vars.speed = tonumber(text)
        
        -- Проверяем, что введено число
        if o.common_vars.speed then
            o.FlyConfig.SpeedMultiplier = o.common_vars.speed
        end
    end
})

-- Подключение к событию изменения персонажа
o.lp.CharacterAdded:Connect(function(char)
    if o.SpeedhackConfig.Enabled then
        updateSpeedHack(char)
    end
    
    -- Также проверяем Fly
    if o.FlyConfig.Enabled and o.FlyConfig.Active then
        updateFly(char)
    end
end)

-- Конфигурации
o.ConfigSection = ConfigTab:Section({name = "Configurations", description = ">_<"})
o.ConfigFolder = "BrandNew/Games/Universal/Configs"

-- Создание папок для конфигураций
pcall(function()
    if not isfolder("BrandNew") then
        makefolder("BrandNew")
    end
    
    if not isfolder("BrandNew/Games") then
        makefolder("BrandNew/Games")
    end
    
    if not isfolder("BrandNew/Games/Universal") then
        makefolder("BrandNew/Games/Universal")
    end
    
    if not isfolder(o.ConfigFolder) then
        makefolder(o.ConfigFolder)
    end
end)

-- Функция получения файлов конфигурации
function GetConfigFiles()
    local files = {}
    
    pcall(function()
        if isfolder(o.ConfigFolder) then
            local fileList = listfiles(o.ConfigFolder)
            for _, file in ipairs(fileList) do
                if type(file) == "string" and file:sub(-5) == ".json" then
                    local configName = file:match("([^/\\]+)%.json$")
                    if configName and type(configName) == "string" then
                        table.insert(files, configName)
                    end
                end
            end
        end
    end)
    
    -- Если нет файлов, добавляем значение по умолчанию
    if #files == 0 then
        table.insert(files, "default")
    end
    
    return files
end

-- Поле ввода имени конфига
o.ConfigName = o.ConfigSection:Textbox({
    name = "Config Name",
    placeholder = "Enter config name...",
    default = "default",
    flag = "config_name"
})

-- Список конфигов
o.ConfigList = o.ConfigSection:List({
    name = "Configs",
    values = GetConfigFiles(),
    value = GetConfigFiles()[1] or "default",
    size = 200,
    flag = "config_list",
    callback = function(value)
        if value and type(value) == "string" then
            Library.Flags["config_name"] = value
            if o.ConfigName and o.ConfigName.Set then
                pcall(function()
                    o.ConfigName:Set(value)
                end)
            end
        end
    end
})

-- Функция для обновления списка конфигов с нуля
function RefreshConfigList()
    local configFiles = GetConfigFiles()
    
    -- Создаем новый список конфигов
    if o.ConfigList and o.ConfigList.Objects and o.ConfigList.Objects.Content then
        -- Очищаем существующие элементы
        for _, child in pairs(o.ConfigList.Objects.Content:GetChildren()) do
            if child:IsA("TextButton") then
                child:Destroy()
            end
        end
        
        -- Сбрасываем список элементов
        o.ConfigList.Items = {}
        
        -- Добавляем новые элементы
        for _, itemName in ipairs(configFiles) do
            if type(itemName) == "string" then
                o.ConfigList.Add(itemName)
            end
        end
    end
end

-- Функция для безопасного сохранения конфига (без циклических ссылок)
function SafeGetConfig()
    -- Создаем копию флагов без циклических ссылок
    local safeFlags = {}
    
    -- Обрабатываем каждый флаг отдельно
    for flag, value in pairs(Library.Flags) do
        -- Пропускаем функции, userdata, thread и nil
        if type(value) == "nil" or type(value) == "function" or type(value) == "userdata" or type(value) == "thread" then
            -- Пропускаем
        
        -- Обработка булевых значений (тогглы)
        elseif type(value) == "boolean" then
            safeFlags[flag] = value
            
        -- Обработка чисел
        elseif type(value) == "number" then
            safeFlags[flag] = value
            
        -- Обработка строк
        elseif type(value) == "string" then
            safeFlags[flag] = value
            
        -- Обработка таблиц (цвета, кейбинды и т.д.)
        elseif type(value) == "table" then
            -- Проверяем, является ли это цветом
            if value.r and value.g and value.b then
                safeFlags[flag] = {r = value.r, g = value.g, b = value.b}
                if value.a then 
                    safeFlags[flag].a = value.a 
                end
            
            -- Проверяем, является ли это кейбиндом
            elseif value.key or value.mode or value.value ~= nil then
                local keyData = {}
                
                if value.key then
                    -- Сохраняем только имя клавиши, а не объект
                    if typeof(value.key) == "EnumItem" then
                        keyData.key = value.key.Name
                    else
                        keyData.key = tostring(value.key)
                    end
                end
                
                if value.mode then
                    keyData.mode = value.mode
                end
                
                if value.value ~= nil then
                    keyData.value = value.value
                end
                
                safeFlags[flag] = keyData
            
            -- Проверяем, является ли это массивом строк (для списков)
            elseif #value > 0 and type(value[1]) == "string" then
                safeFlags[flag] = value
                
            -- Для других типов таблиц сохраняем только простые значения
            else
                local simpleTable = {}
                for k, v in pairs(value) do
                    if type(v) ~= "function" and type(v) ~= "userdata" and type(v) ~= "thread" and type(v) ~= "table" then
                        simpleTable[k] = v
                    end
                end
                safeFlags[flag] = simpleTable
            end
        end
    end
    
    -- Преобразуем в JSON
    local success, result = pcall(function()
        return game:GetService("HttpService"):JSONEncode(safeFlags)
    end)
    
    if success then
        return result
    else
        -- В случае ошибки возвращаем пустой JSON
        warn("Ошибка при сохранении конфига: " .. tostring(result))
        return "{}"
    end
end

-- Кнопка сохранения
o.ConfigSection:Button({
    name = "Save Config",
    description = "Save current settings",
    callback = function()
        local configName = Library.Flags["config_name"]
        if not configName or configName == "" or type(configName) ~= "string" then
            configName = "default"
        end
        
        if not isfolder(o.ConfigFolder) then
            makefolder(o.ConfigFolder)
        end
        
        local path = o.ConfigFolder.."/"..configName..".json"
        local configData = SafeGetConfig() -- Используем нашу безопасную функцию вместо Library.GetConfig()
        
        pcall(function()
            writefile(path, configData)
            print("Config saved: " .. path)
            
            -- Показываем уведомление
            if Library.Notification then
                Library.Notification({ 
                    name = "Config Saved", 
                    description = "Configuration '" .. configName .. "' has been saved." 
                })
            end
            
            -- Используем нашу новую функцию обновления списка
            pcall(RefreshConfigList)
            
            -- Устанавливаем выбранное значение после обновления
            task.wait(0.1) -- Небольшая задержка для обновления UI
            if o.ConfigList and o.ConfigList.Set and type(configName) == "string" then
                pcall(function()
                    o.ConfigList:Set(configName)
                end)
            end
        end)
    end
})

-- Функция для безопасной загрузки конфига
function SafeLoadConfig(jsonData)
    local success, data = pcall(function()
        return game:GetService("HttpService"):JSONDecode(jsonData)
    end)
    
    if not success then
        warn("Ошибка при декодировании JSON: " .. tostring(data))
        return false
    end
    
    -- Применяем каждый флаг по отдельности
    for flag, value in pairs(data) do
        -- Проверяем, существует ли такой флаг
        if Library.ConfigFlags[flag] then
            pcall(function()
                Library.ConfigFlags[flag](value)
            end)
        end
    end
    
    return true
end

-- Кнопка загрузки
o.ConfigSection:Button({
    name = "Load Config",
    description = "Load selected config",
    callback = function()
        local configName = Library.Flags["config_list"]
        if not configName or configName == "" or type(configName) ~= "string" then
            return
        end
        
        local path = o.ConfigFolder.."/"..configName..".json"
        
        pcall(function()
            if isfile(path) then
                local data = readfile(path)
                -- Безопасная загрузка конфига
                local success = SafeLoadConfig(data)
                if success then
                    print("Config loaded: " .. path)
                end
                
                -- Показываем уведомление
                if success and Library.Notification then
                    Library.Notification({ 
                        name = "Config Loaded", 
                        description = "Configuration '" .. configName .. "' has been loaded." 
                    })
                elseif not success and Library.Notification then
                    Library.Notification({ 
                        name = "Error", 
                        description = "Failed to load configuration '" .. configName .. "'" 
                    })
                end
            else
                print("Config file not found: " .. path)
                
                -- Показываем уведомление об ошибке
                if Library.Notification then
                    Library.Notification({ 
                        name = "Error", 
                        description = "Config file not found: " .. configName 
                    })
                end
                
                -- Используем нашу новую функцию обновления списка
                pcall(RefreshConfigList)
            end
        end)
    end
})

-- Кнопка удаления
o.ConfigSection:Button({
    name = "Delete Config",
    description = "Delete selected config",
    callback = function()
        local configName = Library.Flags["config_list"]
        if not configName or configName == "" or type(configName) ~= "string" then
            return
        end
        
        local path = o.ConfigFolder.."/"..configName..".json"
        
        pcall(function()
            if isfile(path) then
                delfile(path)
                print("Config deleted: " .. path)
                
                -- Показываем уведомление
                if Library.Notification then
                    Library.Notification({ 
                        name = "Config Deleted", 
                        description = "Configuration '" .. configName .. "' has been deleted." 
                    })
                end
            else
                -- Показываем уведомление об ошибке
                if Library.Notification then
                    Library.Notification({ 
                        name = "Error", 
                        description = "Config file not found: " .. configName 
                    })
                end
            end
            
            -- Используем нашу новую функцию обновления списка
            pcall(RefreshConfigList)
            
            -- Выбираем первый конфиг в списке после удаления
            task.wait(0.1) -- Небольшая задержка для обновления UI
            local newConfigFiles = GetConfigFiles()
            if #newConfigFiles > 0 and o.ConfigList and o.ConfigList.Set then
                pcall(function()
                    o.ConfigList:Set(newConfigFiles[1])
                end)
            end
        end)
    end
})

-- Кнопка обновления списка
o.ConfigSection:Button({
    name = "Refresh List",
    description = "Update config list",
    callback = function()
        -- Используем нашу новую функцию обновления списка
        pcall(RefreshConfigList)
        
        -- Показываем уведомление
        if Library.Notification then
            Library.Notification({ 
                name = "Config List", 
                description = "Config list has been refreshed." 
            })
        end
    end
})

-- Периодическое обновление списка конфигов
spawn(function()
    while task.wait(5) do
        if Window and Window.Visible then
            -- Используем нашу новую функцию обновления списка
            pcall(function()
                -- Сохраняем текущее выбранное значение
                local currentSelected = Library.Flags["config_list"]
                
                -- Обновляем список
                RefreshConfigList()
                
                -- Восстанавливаем выбранное значение, если оно существует
                if currentSelected and type(currentSelected) == "string" and o.ConfigList and o.ConfigList.Set then
                    -- Проверяем, существует ли такой конфиг в обновленном списке
                    local configFiles = GetConfigFiles()
                    local exists = false
                    for _, name in ipairs(configFiles) do
                        if name == currentSelected then
                            exists = true
                            break
                        end
                    end
                    
                    if exists then
                        pcall(function()
                            o.ConfigList:Set(currentSelected)
                        end)
                    end
                end
            end)
        end
    end
end)

-- Дополнительные настройки
ExtraSection = ConfigTab:Section({name = "Extra", description = ">_<", side = "right"})

-- Привязка меню к клавише
ExtraSection:Keybind({
    name = "MenuKeybind", 
    key = Enum.KeyCode.RightControl,
    mode = "Toggle",
    callback = function() Window.Open() end
})

-- Глобальные переменные для ватермарки
o.watermarkEnabled = false
o.watermarkGui = nil
o.watermarkFrame = nil
o.watermarkStrokeColor = Color3.fromRGB(0, 81, 255) -- Цвет по умолчанию
o.drag = {
    dragging = false,
    dragInput = nil,
    dragStart = nil,
    startPos = nil
}

-- Функция создания/обновления ватермарки
function CreateWatermark(enabled)
    -- Удаляем старый ватермарк, если он существует
    if o.watermarkGui then
        o.watermarkGui:Destroy()
        o.watermarkGui = nil
        o.watermarkFrame = nil
    end
    
    -- Если ватермарк отключен, просто выходим
    if not enabled then
        return
    end
    
    -- Создаем ScreenGui
    o.watermarkGui = Instance.new("ScreenGui")
    o.watermarkGui.Name = "BrandNewWatermark"
    o.watermarkGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    o.watermarkGui.Parent = o.lp:WaitForChild("PlayerGui")
    
    -- Создаем элементы UI
    o.watermarkFrame = Instance.new("Frame")
    o.watermarkUICorner = Instance.new("UICorner")
    o.watermarkText = Instance.new("TextLabel")
    o.watermarkTopStroke = Instance.new("Frame")
    
    o.watermarkFrame.Name = "WaterMark"
    o.watermarkFrame.Parent = o.watermarkGui
    o.watermarkFrame.BackgroundColor3 = Color3.fromRGB(26, 25, 25)
    o.watermarkFrame.BorderColor3 = Color3.fromRGB(0, 0, 0)
    o.watermarkFrame.BorderSizePixel = 0
    o.watermarkFrame.Position = UDim2.new(0.09700948, 0, 0.107579462, 0)
    o.watermarkFrame.Size = UDim2.new(0, 300, 0, 25)
    
    o.watermarkUICorner.CornerRadius = UDim.new(0, 3)
    o.watermarkUICorner.Parent = o.watermarkFrame
    
    o.watermarkText.Name = "Text"
    o.watermarkText.Parent = o.watermarkFrame
    o.watermarkText.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    o.watermarkText.BackgroundTransparency = 1.000
    o.watermarkText.BorderColor3 = Color3.fromRGB(0, 0, 0)
    o.watermarkText.BorderSizePixel = 0
    o.watermarkText.Position = UDim2.new(0.0333333351, 0, 0.11, 0)
    o.watermarkText.Size = UDim2.new(0, 280, 1, 0)
    o.watermarkText.Font = Enum.Font.Sarpanch
    o.watermarkText.Text = "BrandNew | skidded | " .. o.lp.Name .. " | " .. o.MS:GetProductInfo(game.PlaceId).Name
    o.watermarkText.TextColor3 = Color3.fromRGB(255, 255, 255)
    o.watermarkText.TextSize = 12
    o.watermarkText.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    o.watermarkText.TextStrokeTransparency = 0.64
    o.watermarkText.TextXAlignment = Enum.TextXAlignment.Left
    o.watermarkText.TextYAlignment = Enum.TextYAlignment.Center
    
    o.watermarkTopStroke.Name = "TopStroke"
    o.watermarkTopStroke.Parent = o.watermarkFrame
    o.watermarkTopStroke.BackgroundColor3 = o.watermarkStrokeColor -- Используем глобальную переменную для цвета
    o.watermarkTopStroke.BorderColor3 = Color3.fromRGB(0, 0, 0)
    o.watermarkTopStroke.BorderSizePixel = 0
    o.watermarkTopStroke.Size = UDim2.new(0, 300, 0, 1)
    
    -- Добавляем UIStroke к TopStroke
    o.watermarkStrokeUIStroke = Instance.new("UIStroke")
    o.watermarkStrokeUIStroke.Parent = o.watermarkTopStroke
    o.watermarkStrokeUIStroke.Color = Color3.fromRGB(0, 0, 0)
    o.watermarkStrokeUIStroke.Thickness = 1
    o.watermarkStrokeUIStroke.LineJoinMode = Enum.LineJoinMode.Miter
    
    -- Функция для обновления размера WaterMark в зависимости от текста
    function updateWatermarkSize()
        o.common_vars.textSize = o.watermarkText.TextBounds.X
        o.common_vars.newWidth = o.common_vars.textSize + 40
        
        o.ts:Create(o.watermarkFrame, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
            {Size = UDim2.new(0, o.common_vars.newWidth, 0, 25)}):Play()
        
        o.ts:Create(o.watermarkTopStroke, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
            {Size = UDim2.new(0, o.common_vars.newWidth, 0, 1)}):Play()
    end
    
    o.watermarkText:GetPropertyChangedSignal("Text"):Connect(updateWatermarkSize)
    updateWatermarkSize()
    
    -- Функция для обновления позиции при перетаскивании
    function o.updateDrag(input)
        o.common_vars.delta = input.Position - o.drag.dragStart
        o.common_vars.newPosition = UDim2.new(o.drag.startPos.X.Scale, o.drag.startPos.X.Offset + o.common_vars.delta.X, 
            o.drag.startPos.Y.Scale, o.drag.startPos.Y.Offset + o.common_vars.delta.Y)
        
        o.ts:Create(o.watermarkFrame, TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
            {Position = o.common_vars.newPosition}):Play()
    end
    
    o.watermarkFrame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            o.drag.dragging = true
            o.drag.dragStart = input.Position
            o.drag.startPos = o.watermarkFrame.Position
            
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    o.drag.dragging = false
                end
            end)
        end
    end)
    
    o.watermarkFrame.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            o.drag.dragInput = input
        end
    end)
    
    o.uis.InputChanged:Connect(function(input)
        if input == o.drag.dragInput and o.drag.dragging then
            o.updateDrag(input)
        end
    end)
end

-- Тогл ватермарки с привязанным попапом и колорпикером
ExtraSection:Toggle({
    name = "Watermark", 
    default = false,
    flag = "watermark_enabled",
    callback = function(value)
        o.watermarkEnabled = value
        CreateWatermark(o.watermarkEnabled)
    end
}):Popup({size = 150}):Colorpicker({
    name = "Watermark Color",
    description = ">_<",
    default = Color3.fromRGB(0, 81, 255),
    flag = "watermark_color",
    callback = function(color)
        -- Проверяем тип переданного значения
        if type(color) == "table" and color.c then
            o.watermarkStrokeColor = color.c
        else
            o.watermarkStrokeColor = color
        end
        
        -- Обновляем цвет, если ватермарка активна
        if o.watermarkEnabled and o.watermarkFrame and o.watermarkFrame:FindFirstChild("TopStroke") then
            o.watermarkFrame.TopStroke.BackgroundColor3 = o.watermarkStrokeColor
        end
    end
})

-- Привязка переключения UI к клавише
o.uis.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == Enum.KeyCode.RightControl then
        Window.Open()
    end
end)

-- Установка вкладки по умолчанию
LegitBotTab.Set(true)
