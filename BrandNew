-- BrandNew UI Script

--[[
ВАЖНО: Игнорируйте ошибки линтера, связанные с функциями API эксплойта:
- hookmetamethod, checkcaller - функции для работы с метатаблицами
- setNoClip - функция для отключения коллизий
- isfolder, makefolder, listfiles, writefile, readfile, isfile, delfile - функции для работы с файловой системой

Эти функции предоставляются средой выполнения эксплойта и не являются стандартными функциями Luau.
Код работает корректно в среде эксплойта, несмотря на предупреждения линтера.
]]

loadstring(game:HttpGet('https://pastebin.com/raw/gimbTwW1'))() --bypass ac dont touch

-- Загрузка таблицы оптимизации
OptURL = "https://raw.githubusercontent.com/ZXCdswqezxc/BrandNew/refs/heads/main/optimization"
o = loadstring(game:HttpGet(OptURL))() or {}

-- Загрузка UI библиотеки
URL = "https://raw.githubusercontent.com/ZXCdswqezxc/BrandNew/refs/heads/main/jerk"
Library = loadstring(game:HttpGet(URL))()

-- Примечание: Игнорируйте ошибки линтера, связанные с функциями API эксплойта, такими как:
-- hookmetamethod, checkcaller, setNoClip, isfolder, makefolder, listfiles, writefile, readfile, isfile, delfile
-- Эти функции предоставляются средой выполнения эксплойта и не являются стандартными функциями Luau.

-- Темная тема
Library.Theme = {
    Inline = Color3.fromRGB(52, 52, 52),
    Background = Color3.fromRGB(36, 36, 36),
    ["Page Background"] = Color3.fromRGB(22, 22, 22),
    ["Section Background"] = Color3.fromRGB(26, 25, 25),
    ["Dark Background"] = Color3.fromRGB(19, 19, 19),
    Accent = Color3.fromRGB(220, 220, 220),
    ["Dark Text"] = Color3.fromRGB(120, 120, 120),
    ["Light Text"] = Color3.fromRGB(160, 160, 160),
    Text = Color3.fromRGB(220, 220, 220),
}

-- Главное окно
Window = Library:Window({name = "BrandNew", size = UDim2.fromOffset(800, 660), open = true})

-- Вкладки
LegitBotTab = Window:Tab({name = "LegitBot", icon = "rbxassetid://6034996695"})
RageBotTab = Window:Tab({name = "RageBot", icon = "rbxassetid://7733715400"})
VisualsTab = Window:Tab({name = "Visuals", icon = "rbxassetid://6031075931"})
MiscTab = Window:Tab({name = "Misc", icon = "rbxassetid://6031094678"})
PlayerTab = Window:Tab({name = "Player", icon = "rbxassetid://6031068427"})
ConfigTab = Window:Tab({name = "Config", icon = "rbxassetid://6031280882"})

-- Создаем секцию Main во вкладке Visuals
VisualsMainSection = VisualsTab:Section({name = "Main", description = ">_<", side = "right"})

-- Конфигурация трейсеров
BulletTracersConfig = {
    Enabled = false,  -- Включить/выключить трейсеры (true/false)
    Color1 = Color3.new(1, 1, 1),  -- Начальный цвет трейсера
    Color2 = Color3.new(1, 1, 1),  -- Конечный цвет трейсера
    Thickness = 1,  -- Толщина трейсера
    Texture = "rbxassetid://446111271",  -- Текстура трейсера (Starhook)
    Duration = 2,  -- Длительность отображения трейсера (в секундах)
    FadeEnabled = true  -- Включить эффект затухания
}

-- Таблица для отслеживания и очистки трейсеров
BulletTracersCleanup = {}

-- Функция для очистки старых трейсеров
function cleanupBulletTracers()
    if not BulletTracersConfig.Enabled or #BulletTracersCleanup == 0 then return end
    
    indicesToRemove = {}
    
    -- Находим трейсеры для удаления
    for i, data in ipairs(BulletTracersCleanup) do
        if os.time() - data.created > BulletTracersConfig.Duration + 1 then
            -- Отключаем соединение и уничтожаем часть
            if data.conn then data.conn:Disconnect(); data.conn = nil end
            if data.part and data.part:IsDescendantOf(game) then data.part:Destroy() end
            table.insert(indicesToRemove, i)
        end
    end
    
    -- Удаляем записи из таблицы (в обратном порядке)
    for i = #indicesToRemove, 1, -1 do
        table.remove(BulletTracersCleanup, indicesToRemove[i])
    end
end

-- Конфигурация MaterialChams
MaterialChamsConfig = {
    Self = {
        Enabled = false,
        Material = Enum.Material.ForceField,
        Color = Color3.fromRGB(0, 170, 255),
        OriginalMaterials = {},
        OriginalColors = {}
    },
    Other = {
        Enabled = false,
        Material = Enum.Material.ForceField,
        Color = Color3.fromRGB(255, 0, 0),
        Players = {}
    },
    Friend = {
        Enabled = false,
        Material = Enum.Material.ForceField,
        Color = Color3.fromRGB(0, 255, 0),
        Friends = {}
    }
}

-- Конфигурация HighlightChams
HighlightChamsConfig = {
    Self = {
        Enabled = false,
        FillColor = Color3.fromRGB(0, 170, 255),
        OutlineColor = Color3.fromRGB(255, 255, 255),
        FillTransparency = 0.5,
        OutlineTransparency = 0,
        DepthMode = Enum.HighlightDepthMode.AlwaysOnTop,
        Highlight = nil
    },
    Other = {
        Enabled = false,
        FillColor = Color3.fromRGB(255, 0, 0),
        OutlineColor = Color3.fromRGB(255, 255, 255),
        FillTransparency = 0.5,
        OutlineTransparency = 0,
        DepthMode = Enum.HighlightDepthMode.AlwaysOnTop,
        Players = {}
    },
    Friend = {
        Enabled = false,
        FillColor = Color3.fromRGB(0, 255, 0),
        OutlineColor = Color3.fromRGB(255, 255, 255),
        FillTransparency = 0.5,
        OutlineTransparency = 0,
        DepthMode = Enum.HighlightDepthMode.AlwaysOnTop,
        Friends = {}
    }
}

-- Загрузка списка друзей
function loadFriends()
    if not isfile or not readfile then return {} end
    
    if isfile("BrandNew/friends.json") then
        success, result = pcall(function()
            return game:GetService("HttpService"):JSONDecode(readfile("BrandNew/friends.json"))
        end)
        
        if success then
            return result
        end
    end
    
    return {}
end

-- Сохранение списка друзей
function saveFriends()
    if not writefile or not makefolder then return end
    
    if not isfolder("BrandNew") then
        makefolder("BrandNew")
    end
    
    success, result = pcall(function()
        return game:GetService("HttpService"):JSONEncode(MaterialChamsConfig.Friend.Friends)
    end)
    
    if success then
        writefile("BrandNew/friends.json", result)
    end
end

-- Загружаем друзей при запуске
MaterialChamsConfig.Friend.Friends = loadFriends()

-- Функция для применения SelfChams
function applySelfChams()
    Character = o.lp.Character
    if not Character then return end
    
    -- Используем pcall для безопасного выполнения
    pcall(function()
        -- Кэшируем конфиг для быстрого доступа
        config = MaterialChamsConfig.Self
        material = config.Material
        color = config.Color
        
        -- Сохраняем и изменяем материал для всех частей тела
        for _, part in pairs(Character:GetChildren()) do
            if part and part:IsA("BasePart") then
                -- Сохраняем оригинальный материал и цвет, если еще не сохранены
                if not config.OriginalMaterials[part] then
                    config.OriginalMaterials[part] = part.Material
                    config.OriginalColors[part] = part.Color
                end
                
                -- Применяем новый материал и цвет
                part.Material = material
                part.Color = color
            end
            
            -- Обрабатываем аксессуары
            if part and part:IsA("Accessory") then
                handle = part:FindFirstChild("Handle")
                if handle then
                    if not config.OriginalMaterials[handle] then
                        config.OriginalMaterials[handle] = handle.Material
                        config.OriginalColors[handle] = handle.Color
                    end
                    
                    handle.Material = material
                    handle.Color = color
                end
            end
        end
    end)
end

-- Функция для применения SelfHighlight
function applySelfHighlight()
    Character = o.lp.Character
    if not Character then return end
    
    -- Используем pcall для безопасного выполнения
    pcall(function()
        -- Кэшируем конфиг для быстрого доступа
        config = HighlightChamsConfig.Self
        highlight = config.Highlight
        
        -- Если Highlight уже существует, просто обновим его настройки вместо пересоздания
        if highlight and highlight.Parent and highlight.Parent:IsDescendantOf(game) then
            -- Обновляем настройки существующего Highlight
            highlight.FillColor = config.FillColor
            highlight.OutlineColor = config.OutlineColor
            highlight.FillTransparency = config.FillTransparency
            highlight.OutlineTransparency = config.OutlineTransparency
            highlight.DepthMode = config.DepthMode
            
            -- Если Adornee изменился (новый персонаж), обновляем его
            if highlight.Adornee ~= Character then
                highlight.Adornee = Character
            end
        else
            -- Удаляем старый хайлайт, если есть
            if highlight and highlight:IsA("Highlight") then
                highlight:Destroy()
                config.Highlight = nil
            end
            
            -- Создаем новый хайлайт
            newHighlight = Instance.new("Highlight")
            newHighlight.Name = "SelfHighlight"
            newHighlight.FillColor = config.FillColor
            newHighlight.OutlineColor = config.OutlineColor
            newHighlight.FillTransparency = config.FillTransparency
            newHighlight.OutlineTransparency = config.OutlineTransparency
            newHighlight.DepthMode = config.DepthMode
            newHighlight.Adornee = Character
            newHighlight.Parent = Character
            
            -- Сохраняем ссылку на хайлайт
            config.Highlight = newHighlight
        end
    end)
end

-- Функция для отключения SelfChams
function removeSelfChams()
    -- Используем pcall для безопасного выполнения
    pcall(function()
        -- Кэшируем конфиг для быстрого доступа
        config = MaterialChamsConfig.Self
        
        -- Восстанавливаем оригинальные материалы и цвета
        for part, material in pairs(config.OriginalMaterials) do
            if part and part:IsDescendantOf(game) then
                pcall(function()
                    part.Material = material
                    
                    -- Восстанавливаем оригинальный цвет, если он был сохранен
                    if config.OriginalColors[part] then
                        part.Color = config.OriginalColors[part]
                    end
                end)
            end
        end
        
        -- Очищаем сохраненные материалы и цвета
        config.OriginalMaterials = {}
        config.OriginalColors = {}
    end)
end

-- Функция для отключения SelfHighlight
function removeSelfHighlight()
    -- Используем pcall для безопасного выполнения
    pcall(function()
        -- Кэшируем конфиг для быстрого доступа
        config = HighlightChamsConfig.Self
        
        -- Удаляем хайлайт, если он существует
        if config.Highlight and config.Highlight:IsA("Highlight") then
            config.Highlight:Destroy()
            config.Highlight = nil
        end
    end)
end

-- Функция для применения Chams к другим игрокам
function applyOtherChams()
    Players = o.plrs
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= o.lp and player.Character then
            -- Пропускаем друзей, если включен Friend Chams
            if MaterialChamsConfig.Friend.Enabled and MaterialChamsConfig.Friend.Friends[player.Name] then
                -- Пропускаем этого игрока
            else
                character = player.Character
                config = MaterialChamsConfig.Other
            
            -- Сохраняем ссылку на персонажа для обновления
            config.Players[player.Name] = character
            
            -- Применяем материал и цвет ко всем частям тела
            for _, part in pairs(character:GetChildren()) do
                if part and part:IsA("BasePart") then
                    part.Material = config.Material
                    part.Color = config.Color
                end
                
                -- Обрабатываем аксессуары
                if part and part:IsA("Accessory") then
                        handle = part:FindFirstChild("Handle")
                    if handle then
                        handle.Material = config.Material
                        handle.Color = config.Color
                    end
                end
            end
        end
        end
    end
end

-- Функция для применения Highlight к другим игрокам
function applyOtherHighlight()
    Players = o.plrs
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= o.lp and player.Character then
            -- Пропускаем друзей, если включен Friend Highlight
            if HighlightChamsConfig.Friend.Enabled and MaterialChamsConfig.Friend.Friends[player.Name] then
                -- Пропускаем этого игрока
            else
            
            character = player.Character
            config = HighlightChamsConfig.Other
            
            -- Проверяем существующий хайлайт
            existingData = config.Players[player.Name]
            existingHighlight = existingData and existingData.Highlight
            
            -- Если хайлайт уже существует и привязан к тому же персонажу, обновляем настройки
            if existingHighlight and existingHighlight.Parent and existingHighlight.Parent:IsDescendantOf(game) and 
               existingData.Character == character then
                -- Обновляем настройки существующего хайлайта
                existingHighlight.FillColor = config.FillColor
                existingHighlight.OutlineColor = config.OutlineColor
                existingHighlight.FillTransparency = config.FillTransparency
                existingHighlight.OutlineTransparency = config.OutlineTransparency
                existingHighlight.DepthMode = config.DepthMode
            else
                -- Удаляем старый хайлайт, если есть
                if existingHighlight and existingHighlight:IsA("Highlight") then
                    existingHighlight:Destroy()
                end
                
                -- Создаем новый хайлайт
                highlight = Instance.new("Highlight")
                highlight.Name = "OtherHighlight_" .. player.Name
                highlight.FillColor = config.FillColor
                highlight.OutlineColor = config.OutlineColor
                highlight.FillTransparency = config.FillTransparency
                highlight.OutlineTransparency = config.OutlineTransparency
                highlight.DepthMode = config.DepthMode
                highlight.Adornee = character
                highlight.Parent = character
                
                -- Сохраняем ссылку на хайлайт
                config.Players[player.Name] = {
                    Character = character,
                    Highlight = highlight
                }
            end
        end
        end
    end
end

-- Функция для отключения Chams у других игроков
function removeOtherChams()
    config = MaterialChamsConfig.Other
    
    for playerName, character in pairs(config.Players) do
        if character and character:IsDescendantOf(game) then
            for _, part in pairs(character:GetChildren()) do
                if part and part:IsA("BasePart") then
                    pcall(function()
                        part.Material = Enum.Material.Plastic
                        part.Color = Color3.new(1, 1, 1)
                    end)
                end
                
                if part and part:IsA("Accessory") then
                    handle = part:FindFirstChild("Handle")
                    if handle then
                        pcall(function()
                            handle.Material = Enum.Material.Plastic
                            handle.Color = Color3.new(1, 1, 1)
                        end)
                    end
                end
            end
        end
    end
    
    config.Players = {}
end

-- Функция для отключения Highlight у других игроков
function removeOtherHighlight()
    config = HighlightChamsConfig.Other
    
    for playerName, data in pairs(config.Players) do
        if data and data.Highlight and data.Highlight:IsA("Highlight") then
            pcall(function()
                data.Highlight:Destroy()
            end)
        end
    end
    
    config.Players = {}
end

-- Функция для применения Chams к друзьям
function applyFriendChams()
    Players = o.plrs
    config = MaterialChamsConfig.Friend
    
    for playerName, _ in pairs(config.Friends) do
        player = Players:FindFirstChild(playerName)
        if player and player.Character then
            character = player.Character
            
            -- Применяем материал и цвет ко всем частям тела
            for _, part in pairs(character:GetChildren()) do
                if part and part:IsA("BasePart") then
                    part.Material = config.Material
                    part.Color = config.Color
                end
                
                -- Обрабатываем аксессуары
                if part and part:IsA("Accessory") then
                    handle = part:FindFirstChild("Handle")
                    if handle then
                        handle.Material = config.Material
                        handle.Color = config.Color
                    end
                end
            end
        end
    end
end

-- Функция для применения Highlight к друзьям
function applyFriendHighlight()
    Players = o.plrs
    config = HighlightChamsConfig.Friend
    
    -- Инициализируем Friends, если они еще не инициализированы
    if not config.Friends then
        config.Friends = {}
    end
    
    for playerName, _ in pairs(MaterialChamsConfig.Friend.Friends) do
        player = Players:FindFirstChild(playerName)
        if player and player.Character then
            character = player.Character
            
            -- Проверяем существующий хайлайт
            existingData = config.Friends[playerName]
            existingHighlight = existingData and existingData.Highlight
            
            -- Если хайлайт уже существует и привязан к тому же персонажу, обновляем настройки
            if existingHighlight and existingHighlight.Parent and existingHighlight.Parent:IsDescendantOf(game) and 
               existingData.Character == character then
                -- Обновляем настройки существующего хайлайта
                existingHighlight.FillColor = config.FillColor
                existingHighlight.OutlineColor = config.OutlineColor
                existingHighlight.FillTransparency = config.FillTransparency
                existingHighlight.OutlineTransparency = config.OutlineTransparency
                existingHighlight.DepthMode = config.DepthMode
            else
                -- Удаляем старый хайлайт, если есть
                if existingHighlight and existingHighlight:IsA("Highlight") then
                    existingHighlight:Destroy()
                end
                
                -- Создаем новый хайлайт
                highlight = Instance.new("Highlight")
                highlight.Name = "FriendHighlight_" .. playerName
                highlight.FillColor = config.FillColor
                highlight.OutlineColor = config.OutlineColor
                highlight.FillTransparency = config.FillTransparency
                highlight.OutlineTransparency = config.OutlineTransparency
                highlight.DepthMode = config.DepthMode
                highlight.Adornee = character
                highlight.Parent = character
                
                -- Сохраняем ссылку на хайлайт
                config.Friends[playerName] = {
                    Character = character,
                    Highlight = highlight
                }
            end
        end
    end
end

-- Функция для отключения Highlight у друзей
function removeFriendHighlight()
    config = HighlightChamsConfig.Friend
    
    for playerName, data in pairs(config.Friends) do
        if data and data.Highlight and data.Highlight:IsA("Highlight") then
            pcall(function()
                data.Highlight:Destroy()
            end)
        end
    end
    
    config.Friends = {}
end

-- Функция для обновления всех Chams
function updateAllChams()
    -- Обновляем Self Chams
    if MaterialChamsConfig.Self.Enabled then
        applySelfChams()
    else
        removeSelfChams()
    end
    
    -- Обновляем Friend Chams
    if MaterialChamsConfig.Friend.Enabled then
        applyFriendChams()
    end
    
    -- Обновляем Other Chams
    if MaterialChamsConfig.Other.Enabled then
        applyOtherChams()
    else
        removeOtherChams()
    end
end

-- Функция для обновления всех Highlights
function updateAllHighlights()
    -- Обновляем Self Highlight
    if HighlightChamsConfig.Self.Enabled then
        applySelfHighlight()
    else
        removeSelfHighlight()
    end
    
    -- Обновляем Friend Highlight
    if HighlightChamsConfig.Friend.Enabled then
        applyFriendHighlight()
    else
        removeFriendHighlight()
    end
    
    -- Обновляем Other Highlight
    if HighlightChamsConfig.Other.Enabled then
        applyOtherHighlight()
    else
        removeOtherHighlight()
    end
end

-- Обновление при смене персонажа
game:GetService('Players').LocalPlayer.CharacterAdded:Connect(function(character)
    -- Небольшая задержка, чтобы персонаж полностью загрузился
    task.wait(0.5)
    updateAllChams()
    updateAllHighlights()
    
    -- Отслеживаем смерть персонажа для обновления чамсов и хайлайтов
    character:WaitForChild("Humanoid").Died:Connect(function()
        -- Сохраняем текущие состояния MaterialChams
        selfMaterialEnabled = MaterialChamsConfig.Self.Enabled
        otherMaterialEnabled = MaterialChamsConfig.Other.Enabled
        friendMaterialEnabled = MaterialChamsConfig.Friend.Enabled
        
        -- Сохраняем текущие состояния HighlightChams
        selfHighlightEnabled = HighlightChamsConfig.Self.Enabled
        otherHighlightEnabled = HighlightChamsConfig.Other.Enabled
        friendHighlightEnabled = HighlightChamsConfig.Friend.Enabled
        
        -- Очищаем чамсы и хайлайты
        removeSelfChams()
        removeSelfHighlight()
        
        -- Ждем возрождения персонажа
        task.wait(1)
        
        -- Восстанавливаем состояния MaterialChams, если главный тогл включен
        if Library.Flags["visual_materialchams"] then
            MaterialChamsConfig.Self.Enabled = selfMaterialEnabled
            MaterialChamsConfig.Other.Enabled = otherMaterialEnabled
            MaterialChamsConfig.Friend.Enabled = friendMaterialEnabled
            
            -- Применяем чамсы заново
            updateAllChams()
        end
        
        -- Восстанавливаем состояния HighlightChams, если главный тогл включен
        if Library.Flags["visual_highlightchams"] then
            HighlightChamsConfig.Self.Enabled = selfHighlightEnabled
            HighlightChamsConfig.Other.Enabled = otherHighlightEnabled
            HighlightChamsConfig.Friend.Enabled = friendHighlightEnabled
            
            -- Применяем хайлайты заново
            updateAllHighlights()
        end
    end)
end)

-- Добавляем обработчик для текущего персонажа
currentCharacter = game:GetService('Players').LocalPlayer.Character
if currentCharacter then
    currentCharacter:WaitForChild("Humanoid").Died:Connect(function()
        -- Сохраняем текущие состояния MaterialChams
        selfMaterialEnabled = MaterialChamsConfig.Self.Enabled
        otherMaterialEnabled = MaterialChamsConfig.Other.Enabled
        friendMaterialEnabled = MaterialChamsConfig.Friend.Enabled
        
        -- Сохраняем текущие состояния HighlightChams
        selfHighlightEnabled = HighlightChamsConfig.Self.Enabled
        otherHighlightEnabled = HighlightChamsConfig.Other.Enabled
        friendHighlightEnabled = HighlightChamsConfig.Friend.Enabled
        
        -- Очищаем чамсы и хайлайты
        removeSelfChams()
        removeSelfHighlight()
        
        -- Ждем возрождения персонажа
        task.wait(1)
        
        -- Восстанавливаем состояния MaterialChams, если главный тогл включен
        if Library.Flags["visual_materialchams"] then
            MaterialChamsConfig.Self.Enabled = selfMaterialEnabled
            MaterialChamsConfig.Other.Enabled = otherMaterialEnabled
            MaterialChamsConfig.Friend.Enabled = friendMaterialEnabled
            
            -- Применяем чамсы заново
            updateAllChams()
        end
        
        -- Восстанавливаем состояния HighlightChams, если главный тогл включен
        if Library.Flags["visual_highlightchams"] then
            HighlightChamsConfig.Self.Enabled = selfHighlightEnabled
            HighlightChamsConfig.Other.Enabled = otherHighlightEnabled
            HighlightChamsConfig.Friend.Enabled = friendHighlightEnabled
            
            -- Применяем хайлайты заново
            updateAllHighlights()
        end
    end)
end

-- Состояние оружия
gunState = {
    current_tool = nil,
    previous_ammo = 0,
    recently_shot = false,
    connections = {}
}

-- Определение игры и путей к пулям
function detectGame()
    gameData = {
        -- Da Hood
        [2788229376] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored.Siren.Radius" },
        [71189885129233] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored" },
        [5602055394] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored" },
        [17403265390] = { BN = "Part", BBN = "gb", BP = "" },
        [17403166075] = { BN = "Part", BBN = "gb", BP = "" },
        [18111448661] = { BN = "Part", BBN = "gb", BP = "" },
        [15186202290] = { BN = "Part", BBN = "gb", BP = "" },
        [11143225577] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "" },
        [15763494605] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "" },
        [15166543806] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "" },
        [17897702920] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "" },
        [16033173781] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored.Siren.Radius" },
        [7213786345] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored.Siren.Radius" },
        [9825515356] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored" },
        [16859411452] = { BN = "bulletray", BBN = "beam", BP = "Ignored" },
        [14277620939] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored" },
        [0] = { BN = "BULLET_RAYS", BBN = "GunBeam", BP = "Ignored" }
    }
    
    return gameData[game.PlaceId] or gameData[0]
end

-- Получение пути к пулям
function getPath(root, path)
    if not root or path == "" then return root end
    parts = string.split(path, ".")
    current = root
    
    for _, part in ipairs(parts) do
        current = current:FindFirstChild(part)
        if not current then return nil end
    end
    
    return current
end

-- Создание луча (beam)
function createBeam(from, to, color1, color2, thickness, texture)
    beam = {
        tweenConn = nil,
        totalTime = 0,
        duration = BulletTracersConfig.Duration,
        mainPart = Instance.new("Part")
    }
    
    -- Создаем основную часть
    beam.mainPart.Name = "BulletTracer"
    beam.mainPart.Parent = workspace
    beam.mainPart.Size = o.funcs.v3(0, 0, 0)
    beam.mainPart.Massless = true
    beam.mainPart.Transparency = 1
    beam.mainPart.CanCollide = false
    beam.mainPart.Position = from
    beam.mainPart.Anchored = true

    -- Создаем части для прикрепления луча
    part0 = Instance.new("Part")
    part0.Parent = beam.mainPart
    part0.Size = o.funcs.v3(0, 0, 0)
    part0.Massless = true
    part0.Transparency = 1
    part0.CanCollide = false
    part0.Position = from
    part0.Anchored = true
    
    part1 = Instance.new("Part")
    part1.Parent = beam.mainPart
    part1.Size = o.funcs.v3(0, 0, 0)
    part1.Massless = true
    part1.Transparency = 1
    part1.CanCollide = false
    part1.Position = to
    part1.Anchored = true
    
    -- Создаем точки прикрепления
    attachment0 = Instance.new("Attachment")
    attachment0.Parent = part0
    attachment1 = Instance.new("Attachment")
    attachment1.Parent = part1
    
    -- Создаем луч
    beam.visual = Instance.new("Beam")
    beam.visual.Texture = texture
    beam.visual.TextureMode = Enum.TextureMode.Wrap
    beam.visual.TextureLength = 10
    beam.visual.LightEmission = 1
    beam.visual.LightInfluence = 1
    beam.visual.FaceCamera = true
    beam.visual.ZOffset = -1
    beam.visual.Transparency = BulletTracersConfig.FadeEnabled and NumberSequence.new({NumberSequenceKeypoint.new(0, 0), NumberSequenceKeypoint.new(1, 0.2)}) or NumberSequence.new(0)
    beam.visual.Color = ColorSequence.new({ColorSequenceKeypoint.new(0, color1), ColorSequenceKeypoint.new(1, color2)})
    beam.visual.Attachment0 = attachment0
    beam.visual.Attachment1 = attachment1
    beam.visual.Width0 = thickness
    beam.visual.Width1 = thickness
    beam.visual.Enabled = true
    beam.visual.Parent = beam.mainPart

    -- Добавляем эффект затухания, если он включен
    if BulletTracersConfig.FadeEnabled then
        beam.tweenConn = o.rs.Heartbeat:Connect(function(deltaTime)
            beam.totalTime = beam.totalTime + deltaTime
            progress = beam.totalTime / beam.duration
            beam.visual.Transparency = NumberSequence.new({
                NumberSequenceKeypoint.new(0, o.ts:GetValue(progress, Enum.EasingStyle.Quad, Enum.EasingDirection.In)),
                NumberSequenceKeypoint.new(1, math.min(o.ts:GetValue(progress, Enum.EasingStyle.Quad, Enum.EasingDirection.In) + 0.2, 1)),
            })
        end)
    end

    -- Настраиваем автоматическое удаление через указанное время
    task.delay(beam.duration, function()
        if beam.tweenConn then beam.tweenConn:Disconnect() end
        if beam.mainPart and beam.mainPart:IsDescendantOf(game) then
            o.ts:Create(beam.visual, TweenInfo.new(0.2, Enum.EasingStyle.Quad), {Transparency = NumberSequence.new(1)}):Play()
            task.delay(0.2, function()
                if beam.mainPart and beam.mainPart:IsDescendantOf(game) then beam.mainPart:Destroy() end
            end)
        end
    end)
    
    -- Добавляем в список для очистки
    table.insert(BulletTracersCleanup, {part = beam.mainPart, conn = beam.tweenConn, created = os.time(), beam = beam})
end

-- Функция для получения оружия локального игрока
function getGun(player)
    if not player or not player.Character then return nil end
    
    tool = player.Character:FindFirstChildWhichIsA("Tool")
    if not tool then return nil end
    
    gunInfo = {tool = tool}
    
    -- Ищем значение патронов в оружии
    for _, obj in ipairs(tool:GetDescendants()) do
        objName = string.lower(obj.Name)
        if objName:find("ammo") and not objName:find("max") and 
           (obj.ClassName == "IntValue" or obj.ClassName == "NumberValue") then
            gunInfo.ammo = obj
            return gunInfo
        end
    end
    
    return nil
end

-- Функция для настройки отслеживания оружия
function setupGunTracking(player)
    if not BulletTracersConfig.Enabled or not player then return end
    
    -- Очищаем текущие соединения
    for _, connection in ipairs(gunState.connections) do
        if connection then connection:Disconnect() end
    end
    gunState.connections = {}
    
    -- Если персонаж игрока не существует, создаем соединение на его появление
    if not player.Character then
        table.insert(gunState.connections, player.CharacterAdded:Connect(function()
            if BulletTracersConfig.Enabled then setupGunTracking(player) end
        end))
        return
    end
    
    -- Функция для настройки отслеживания патронов
    function setupAmmoTracking(gun)
        if not gun or not gun.ammo then return end
        
                gunState.current_tool = gun.tool
                gunState.previous_ammo = gun.ammo.Value
                
                -- Отслеживаем изменение количества патронов
                table.insert(gunState.connections, gun.ammo.Changed:Connect(function()
            if not BulletTracersConfig.Enabled then return end
            
            ammoValue = gun.ammo.Value
            if ammoValue < gunState.previous_ammo then
                        gunState.recently_shot = true
                        task.wait() -- Короткая пауза для обнаружения пули
                        gunState.recently_shot = false
                    end
            gunState.previous_ammo = ammoValue
                end))
            end
    
    -- Отслеживаем добавление/удаление оружия
    table.insert(gunState.connections, player.Character.ChildAdded:Connect(function(child)
        if not BulletTracersConfig.Enabled then return end
        if child:IsA("Tool") then setupAmmoTracking(getGun(player)) end
    end))
    
    table.insert(gunState.connections, player.Character.ChildRemoved:Connect(function(child)
        if child == gunState.current_tool then
            gunState.current_tool = nil
            gunState.previous_ammo = 0
        end
    end))
    
    -- Проверяем наличие оружия сразу
    setupAmmoTracking(getGun(player))
end

-- Основная функция для настройки эффектов пуль
function setupBulletEffects()
    -- Если трейсеры отключены, не выполняем настройку
    if not BulletTracersConfig.Enabled then return end
    
    gameData = detectGame()
    bulletPath = getPath(workspace, gameData.BP) or workspace
    
    -- Настраиваем отслеживание оружия локального игрока
    setupGunTracking(o.lp)
    
    -- Отслеживаем добавление персонажа, если он еще не существует
    if not o.lp.Character then
        o.lp.CharacterAdded:Connect(function()
            if BulletTracersConfig.Enabled then
                setupGunTracking(o.lp)
            end
        end)
    end
    
    -- Удаляем старые соединения, если они существуют
    if getgenv().bulletTracerConnection then
        getgenv().bulletTracerConnection:Disconnect()
        getgenv().bulletTracerConnection = nil
    end
    
    -- Следим за созданием новых пуль
    getgenv().bulletTracerConnection = bulletPath.ChildAdded:Connect(function(object)
        if not BulletTracersConfig.Enabled then return end
        
        -- Проверяем, чтобы это была пуля с правильным именем и выпущена локальным игроком
        if object.Name == gameData.BN and gunState.recently_shot then
            task.spawn(function()
                beam = object:WaitForChild(gameData.BBN, 0.2)
                if not beam then return end
                
                -- Создаем трейсер
                createBeam(
                    object.Position, 
                    beam.Attachment1.WorldPosition, 
                    BulletTracersConfig.Color1, 
                    BulletTracersConfig.Color2, 
                    BulletTracersConfig.Thickness,
                    BulletTracersConfig.Texture
                )
                
                -- Удаляем оригинальный луч
                beam:Destroy()
            end)
        end
    end)
    
    -- Создаем соединение для очистки трейсеров
    if getgenv().bulletTracerCleanupConnection then
        getgenv().bulletTracerCleanupConnection:Disconnect()
        getgenv().bulletTracerCleanupConnection = nil
    end
    
    getgenv().bulletTracerCleanupConnection = o.rs.Heartbeat:Connect(function()
        -- Очищаем старые трейсеры только если функция включена
        if BulletTracersConfig.Enabled then
            cleanupBulletTracers()
        end
    end)
    
    -- Создаем резервное соединение для случаев, когда ChildAdded не срабатывает
    if getgenv().bulletTracerBackupConnection then
        getgenv().bulletTracerBackupConnection:Disconnect()
        getgenv().bulletTracerBackupConnection = nil
    end
    
    getgenv().bulletTracerBackupConnection = o.rs.Heartbeat:Connect(function()
        if not BulletTracersConfig.Enabled or not gunState.recently_shot then return end
        
        -- Проверяем все пули в рабочем пространстве
        for _, object in ipairs(bulletPath:GetChildren()) do
            if object.Name == gameData.BN and object:IsA("BasePart") then
                beam = object:FindFirstChild(gameData.BBN)
                if beam and not beam:GetAttribute("Processed") then
                    beam:SetAttribute("Processed", true)
                        
                        -- Создаем трейсер
                        createBeam(
                        object.Position, 
                        beam.Attachment1.WorldPosition, 
                            BulletTracersConfig.Color1, 
                            BulletTracersConfig.Color2, 
                            BulletTracersConfig.Thickness,
                            BulletTracersConfig.Texture
                        )
                    
                    -- Удаляем оригинальный луч
                    beam:Destroy()
                end
            end
        end
    end)
end

-- Добавляем тогл Bullet Tracers с попапом
BulletTracersToggle = VisualsMainSection:Toggle({
    name = "Bullet Tracers",
    default = false,
    flag = "visuals_bullet_tracers",
    callback = function(value)
        BulletTracersConfig.Enabled = value
        
        -- Отключаем все соединения при выключении
        if getgenv().bulletTracerConnection then
            getgenv().bulletTracerConnection:Disconnect()
            getgenv().bulletTracerConnection = nil
        end
        if getgenv().bulletTracerCleanupConnection then
            getgenv().bulletTracerCleanupConnection:Disconnect()
            getgenv().bulletTracerCleanupConnection = nil
        end
        if getgenv().bulletTracerBackupConnection then
            getgenv().bulletTracerBackupConnection:Disconnect()
            getgenv().bulletTracerBackupConnection = nil
        end
        
        -- Очищаем соединения отслеживания оружия
        for _, connection in ipairs(gunState.connections) do
            if connection then connection:Disconnect() end
        end
        gunState.connections = {}
        
        -- Если включаем трейсеры, настраиваем их
        if value then
            setupBulletEffects()
        end
    end
})

-- Создаем попап для настроек трейсеров
BulletTracersPopup = BulletTracersToggle:Popup({size = 200})

-- Добавляем колорпикер для начального цвета трейсера
BulletTracersPopup:Colorpicker({
    name = "Start Color",
    description = ">_<",
    default = Color3.fromRGB(255, 255, 255),
    flag = "bullet_tracers_color1",
    callback = function(color)
        if type(color) == "table" and color.c then
            BulletTracersConfig.Color1 = color.c
        else
            BulletTracersConfig.Color1 = color
        end
    end
})

-- Добавляем колорпикер для конечного цвета трейсера
BulletTracersPopup:Colorpicker({
    name = "End Color",
    description = ">_<",
    default = Color3.fromRGB(255, 255, 255),
    flag = "bullet_tracers_color2",
    callback = function(color)
        if type(color) == "table" and color.c then
            BulletTracersConfig.Color2 = color.c
        else
            BulletTracersConfig.Color2 = color
        end
    end
})

-- Добавляем слайдер для толщины трейсера
BulletTracersPopup:Slider({
    name = "Thickness",
    min = 0.1,
    max = 5,
    default = 1,
    float = 0.1,
    flag = "bullet_tracers_thickness",
    callback = function(value)
        BulletTracersConfig.Thickness = value
    end
})

-- Добавляем выпадающий список для текстуры трейсера
BulletTracersPopup:Dropdown({
    name = "Texture",
    values = {"Default", "Starhook", "Chain", "Lightning", "Beam", "Neon", "Laser", "32vision", "RandomBeam", "AnotherBeam"},
    value = "Starhook",
    flag = "bullet_tracers_texture",
    callback = function(value)
        textures = {
            ["Default"] = "",
            ["Starhook"] = "rbxassetid://446111271",
            ["Chain"] = "rbxassetid://3029306948",
            ["Lightning"] = "rbxassetid://7216850022",
            ["Beam"] = "rbxassetid://1263079249",
            ["Neon"] = "rbxassetid://5864341017",
            ["Laser"] = "rbxassetid://5864341017",
            ["32vision"] = "rbxassetid://76260924043402",
            ["RandomBeam"] = "rbxassetid://7135001292",
            ["AnotherBeam"] = "rbxassetid://15000399181"
        }
        BulletTracersConfig.Texture = textures[value] or ""
    end
})

-- Добавляем слайдер для длительности трейсера
BulletTracersPopup:Slider({
    name = "Duration",
    min = 1,
    max = 10,
    default = 2,
    float = 0.5,
    flag = "bullet_tracers_duration",
    callback = function(value)
        BulletTracersConfig.Duration = value
        -- Обновляем длительность для всех активных трейсеров
        for _, data in ipairs(BulletTracersCleanup) do
            if data.beam and data.beam.duration then data.beam.duration = value end
        end
    end
})

-- Добавляем тогл для включения/выключения эффекта затухания
BulletTracersPopup:Toggle({
    name = "Fade Effect",
    default = true,
    flag = "bullet_tracers_fade",
    callback = function(value)
        BulletTracersConfig.FadeEnabled = value
    end
})

-- Добавляем тогл MaterialChams с попапом
MaterialChamsToggle = VisualsMainSection:Toggle({
    name = "Material Chams",
    default = false,
    flag = "visual_materialchams",
    callback = function(value)
        -- Обновляем состояние всех подтоглов в зависимости от главного тогла
        if not value then
            -- Если главный тогл выключен, выключаем все чамсы
            MaterialChamsConfig.Self.Enabled = false
            MaterialChamsConfig.Other.Enabled = false
            MaterialChamsConfig.Friend.Enabled = false
            removeSelfChams()
            removeOtherChams()
        else
            -- Если главный тогл включен, восстанавливаем состояния из флагов
            MaterialChamsConfig.Self.Enabled = Library.Flags["material_chams_self"] or false
            MaterialChamsConfig.Other.Enabled = Library.Flags["material_chams_other"] or false
            MaterialChamsConfig.Friend.Enabled = Library.Flags["material_chams_friend"] or false
        end
        
        -- Обновляем все чамсы
        updateAllChams()
    end
})

-- Создаем попап для MaterialChams
MaterialChamsPopup = MaterialChamsToggle:Popup({size = 250})

-- Добавляем тогл Self с попапом
SelfChamsToggle = MaterialChamsPopup:Toggle({
    name = "Self",
    default = false,
    flag = "material_chams_self",
    callback = function(value)
        MaterialChamsConfig.Self.Enabled = value
        
        -- Проверяем состояние главного тогла
        if not Library.Flags["visual_materialchams"] then
            return
        end
        
        if value then
            applySelfChams()
        else
            removeSelfChams()
        end
    end
})

-- Создаем попап для Self
SelfChamsPopup = SelfChamsToggle:Popup({size = 200})

-- Устанавливаем материал ForceField для Self
MaterialChamsConfig.Self.Material = Enum.Material.ForceField

-- Добавляем колорпикер для цвета Self
SelfChamsPopup:Colorpicker({
    name = "Color",
    description = ">_<",
    default = Color3.fromRGB(0, 170, 255),
    flag = "self_chams_color",
    callback = function(color)
        if type(color) == "table" and color.c then
            MaterialChamsConfig.Self.Color = color.c
        else
            MaterialChamsConfig.Self.Color = color
        end
        
        -- Если включено, сразу применяем новый цвет
        if MaterialChamsConfig.Self.Enabled then
            applySelfChams()
        end
    end
})

-- Добавляем тогл Other с попапом
OtherChamsToggle = MaterialChamsPopup:Toggle({
    name = "Other",
    default = false,
    flag = "material_chams_other",
    callback = function(value)
        MaterialChamsConfig.Other.Enabled = value
        
        -- Проверяем состояние главного тогла
        if not Library.Flags["visual_materialchams"] then
            return
        end
        
        if value then
            applyOtherChams()
        else
            removeOtherChams()
        end
    end
})

-- Создаем попап для Other
OtherChamsPopup = OtherChamsToggle:Popup({size = 200})

-- Устанавливаем материал ForceField для Other
MaterialChamsConfig.Other.Material = Enum.Material.ForceField

-- Добавляем колорпикер для цвета Other
OtherChamsPopup:Colorpicker({
    name = "Color",
    description = ">_<",
    default = Color3.fromRGB(255, 0, 0),
    flag = "other_chams_color",
    callback = function(color)
        if type(color) == "table" and color.c then
            MaterialChamsConfig.Other.Color = color.c
        else
            MaterialChamsConfig.Other.Color = color
        end
        
        -- Если включено, сразу применяем новый цвет
        if MaterialChamsConfig.Other.Enabled then
            applyOtherChams()
        end
    end
})

-- Добавляем тогл Friend с попапом
FriendChamsToggle = MaterialChamsPopup:Toggle({
    name = "Friend",
    default = false,
    flag = "material_chams_friend",
    callback = function(value)
        MaterialChamsConfig.Friend.Enabled = value
        
        -- Проверяем состояние главного тогла
        if not Library.Flags["visual_materialchams"] then
            return
        end
        
        if value then
            applyFriendChams()
        end
    end
})

-- Создаем попап для Friend
FriendChamsPopup = FriendChamsToggle:Popup({size = 200})

-- Устанавливаем материал ForceField для Friend
MaterialChamsConfig.Friend.Material = Enum.Material.ForceField

-- Добавляем колорпикер для цвета Friend
FriendChamsPopup:Colorpicker({
    name = "Color",
    description = ">_<",
    default = Color3.fromRGB(0, 255, 0),
    flag = "friend_chams_color",
    callback = function(color)
        if type(color) == "table" and color.c then
            MaterialChamsConfig.Friend.Color = color.c
        else
            MaterialChamsConfig.Friend.Color = color
        end
        
        -- Если включено, сразу применяем новый цвет
        if MaterialChamsConfig.Friend.Enabled then
            applyFriendChams()
        end
    end
})



-- Добавляем тогл Chams Highlights с попапом
HighlightChamsToggle = VisualsMainSection:Toggle({
    name = "Chams Highlights",
    default = false,
    flag = "visual_highlightchams",
    callback = function(value)
        -- Обновляем состояние всех подтоглов в зависимости от главного тогла
        if not value then
            -- Если главный тогл выключен, выключаем все хайлайты
            HighlightChamsConfig.Self.Enabled = false
            HighlightChamsConfig.Other.Enabled = false
            HighlightChamsConfig.Friend.Enabled = false
            removeSelfHighlight()
            removeOtherHighlight()
            removeFriendHighlight()
        else
            -- Если главный тогл включен, восстанавливаем состояния из флагов
            HighlightChamsConfig.Self.Enabled = Library.Flags["highlight_chams_self"] or false
            HighlightChamsConfig.Other.Enabled = Library.Flags["highlight_chams_other"] or false
            HighlightChamsConfig.Friend.Enabled = Library.Flags["highlight_chams_friend"] or false
        end
        
        -- Обновляем все хайлайты
        updateAllHighlights()
    end
})

-- Создаем попап для HighlightChams
HighlightChamsPopup = HighlightChamsToggle:Popup({size = 250})

-- Добавляем тогл Self с попапом
SelfHighlightToggle = HighlightChamsPopup:Toggle({
    name = "Self",
    default = false,
    flag = "highlight_chams_self",
    callback = function(value)
        HighlightChamsConfig.Self.Enabled = value
        
        -- Проверяем состояние главного тогла
        if not Library.Flags["visual_highlightchams"] then
            return
        end
        
        if value then
            applySelfHighlight()
        else
            removeSelfHighlight()
        end
    end
})

-- Создаем попап для Self
SelfHighlightPopup = SelfHighlightToggle:Popup({size = 200})

-- Добавляем слайдер для прозрачности заливки
SelfHighlightPopup:Slider({
    name = "Fill Transparency",
    min = 0,
    max = 1,
    default = 0.5,
    float = 0.01,
    flag = "self_highlight_fill_transparency",
    callback = function(value)
        HighlightChamsConfig.Self.FillTransparency = value
        
        -- Если включено, сразу применяем
        if HighlightChamsConfig.Self.Enabled and Library.Flags["visual_highlightchams"] then
            if HighlightChamsConfig.Self.Highlight then
                HighlightChamsConfig.Self.Highlight.FillTransparency = value
            end
        end
    end
})

-- Добавляем слайдер для прозрачности обводки
SelfHighlightPopup:Slider({
    name = "Outline Transparency",
    min = 0,
    max = 1,
    default = 0,
    float = 0.01,
    flag = "self_highlight_outline_transparency",
    callback = function(value)
        HighlightChamsConfig.Self.OutlineTransparency = value
        
        -- Если включено, сразу применяем
        if HighlightChamsConfig.Self.Enabled and Library.Flags["visual_highlightchams"] then
            if HighlightChamsConfig.Self.Highlight then
                HighlightChamsConfig.Self.Highlight.OutlineTransparency = value
            end
        end
    end
})

-- Добавляем колорпикер для цвета заливки
SelfHighlightPopup:Colorpicker({
    name = "Fill Color",
    description = ">_<",
    default = Color3.fromRGB(0, 170, 255),
    flag = "self_highlight_fill_color",
    callback = function(color)
        if type(color) == "table" and color.c then
            HighlightChamsConfig.Self.FillColor = color.c
        else
            HighlightChamsConfig.Self.FillColor = color
        end
        
        -- Если включено, сразу применяем
        if HighlightChamsConfig.Self.Enabled and Library.Flags["visual_highlightchams"] then
            if HighlightChamsConfig.Self.Highlight then
                HighlightChamsConfig.Self.Highlight.FillColor = HighlightChamsConfig.Self.FillColor
            end
        end
    end
})

-- Добавляем колорпикер для цвета обводки
SelfHighlightPopup:Colorpicker({
    name = "Outline Color",
    description = ">_<",
    default = Color3.fromRGB(255, 255, 255),
    flag = "self_highlight_outline_color",
    callback = function(color)
        if type(color) == "table" and color.c then
            HighlightChamsConfig.Self.OutlineColor = color.c
        else
            HighlightChamsConfig.Self.OutlineColor = color
        end
        
        -- Если включено, сразу применяем
        if HighlightChamsConfig.Self.Enabled and Library.Flags["visual_highlightchams"] then
            if HighlightChamsConfig.Self.Highlight then
                HighlightChamsConfig.Self.Highlight.OutlineColor = HighlightChamsConfig.Self.OutlineColor
            end
        end
    end
})

-- Добавляем тогл Other с попапом
OtherHighlightToggle = HighlightChamsPopup:Toggle({
    name = "Other",
    default = false,
    flag = "highlight_chams_other",
    callback = function(value)
        HighlightChamsConfig.Other.Enabled = value
        
        -- Проверяем состояние главного тогла
        if not Library.Flags["visual_highlightchams"] then
            return
        end
        
        if value then
            applyOtherHighlight()
        else
            removeOtherHighlight()
        end
    end
})

-- Создаем попап для Other
OtherHighlightPopup = OtherHighlightToggle:Popup({size = 200})

-- Добавляем слайдер для прозрачности заливки
OtherHighlightPopup:Slider({
    name = "Fill Transparency",
    min = 0,
    max = 1,
    default = 0.5,
    float = 0.01,
    flag = "other_highlight_fill_transparency",
    callback = function(value)
        HighlightChamsConfig.Other.FillTransparency = value
        
        -- Если включено, сразу применяем
        if HighlightChamsConfig.Other.Enabled and Library.Flags["visual_highlightchams"] then
            applyOtherHighlight()
        end
    end
})

-- Добавляем слайдер для прозрачности обводки
OtherHighlightPopup:Slider({
    name = "Outline Transparency",
    min = 0,
    max = 1,
    default = 0,
    float = 0.01,
    flag = "other_highlight_outline_transparency",
    callback = function(value)
        HighlightChamsConfig.Other.OutlineTransparency = value
        
        -- Если включено, сразу применяем
        if HighlightChamsConfig.Other.Enabled and Library.Flags["visual_highlightchams"] then
            applyOtherHighlight()
        end
    end
})

-- Добавляем колорпикер для цвета заливки
OtherHighlightPopup:Colorpicker({
    name = "Fill Color",
    description = ">_<",
    default = Color3.fromRGB(255, 0, 0),
    flag = "other_highlight_fill_color",
    callback = function(color)
        if type(color) == "table" and color.c then
            HighlightChamsConfig.Other.FillColor = color.c
        else
            HighlightChamsConfig.Other.FillColor = color
        end
        
        -- Если включено, сразу применяем
        if HighlightChamsConfig.Other.Enabled and Library.Flags["visual_highlightchams"] then
            applyOtherHighlight()
        end
    end
})

-- Добавляем колорпикер для цвета обводки
OtherHighlightPopup:Colorpicker({
    name = "Outline Color",
    description = ">_<",
    default = Color3.fromRGB(255, 255, 255),
    flag = "other_highlight_outline_color",
    callback = function(color)
        if type(color) == "table" and color.c then
            HighlightChamsConfig.Other.OutlineColor = color.c
        else
            HighlightChamsConfig.Other.OutlineColor = color
        end
        
        -- Если включено, сразу применяем
        if HighlightChamsConfig.Other.Enabled and Library.Flags["visual_highlightchams"] then
            applyOtherHighlight()
        end
    end
})

-- Добавляем тогл Friend с попапом
FriendHighlightToggle = HighlightChamsPopup:Toggle({
    name = "Friend",
    default = false,
    flag = "highlight_chams_friend",
    callback = function(value)
        HighlightChamsConfig.Friend.Enabled = value
        
        -- Проверяем состояние главного тогла
        if not Library.Flags["visual_highlightchams"] then
            return
        end
        
        if value then
            applyFriendHighlight()
        else
            removeFriendHighlight()
        end
    end
})

-- Создаем попап для Friend
FriendHighlightPopup = FriendHighlightToggle:Popup({size = 200})

-- Добавляем слайдер для прозрачности заливки
FriendHighlightPopup:Slider({
    name = "Fill Transparency",
    min = 0,
    max = 1,
    default = 0.5,
    float = 0.01,
    flag = "friend_highlight_fill_transparency",
    callback = function(value)
        HighlightChamsConfig.Friend.FillTransparency = value
        
        -- Если включено, сразу применяем
        if HighlightChamsConfig.Friend.Enabled and Library.Flags["visual_highlightchams"] then
            applyFriendHighlight()
        end
    end
})

-- Добавляем слайдер для прозрачности обводки
FriendHighlightPopup:Slider({
    name = "Outline Transparency",
    min = 0,
    max = 1,
    default = 0,
    float = 0.01,
    flag = "friend_highlight_outline_transparency",
    callback = function(value)
        HighlightChamsConfig.Friend.OutlineTransparency = value
        
        -- Если включено, сразу применяем
        if HighlightChamsConfig.Friend.Enabled and Library.Flags["visual_highlightchams"] then
            applyFriendHighlight()
        end
    end
})

-- Добавляем колорпикер для цвета заливки
FriendHighlightPopup:Colorpicker({
    name = "Fill Color",
    description = ">_<",
    default = Color3.fromRGB(0, 255, 0),
    flag = "friend_highlight_fill_color",
    callback = function(color)
        if type(color) == "table" and color.c then
            HighlightChamsConfig.Friend.FillColor = color.c
        else
            HighlightChamsConfig.Friend.FillColor = color
        end
        
        -- Если включено, сразу применяем
        if HighlightChamsConfig.Friend.Enabled and Library.Flags["visual_highlightchams"] then
            applyFriendHighlight()
        end
    end
})

-- Добавляем колорпикер для цвета обводки
FriendHighlightPopup:Colorpicker({
    name = "Outline Color",
    description = ">_<",
    default = Color3.fromRGB(255, 255, 255),
    flag = "friend_highlight_outline_color",
    callback = function(color)
        if type(color) == "table" and color.c then
            HighlightChamsConfig.Friend.OutlineColor = color.c
        else
            HighlightChamsConfig.Friend.OutlineColor = color
        end
        
        -- Если включено, сразу применяем
        if HighlightChamsConfig.Friend.Enabled and Library.Flags["visual_highlightchams"] then
            applyFriendHighlight()
        end
    end
})

-- === Конфигурация трейсеров ESP ===
TracersConfig = {
    Enabled = false,
    Players = {
        Enabled = false,
        Color = Color3.fromRGB(255, 255, 255),
        Thickness = 1,
        Origin = "Bottom", -- Bottom, Top, Mouse
        TargetPart = "Head" -- Head, HumanoidRootPart, Torso
    },
    Friends = {
        Enabled = false,
        Color = Color3.fromRGB(0, 255, 0),
        Thickness = 1,
        Origin = "Bottom", -- Bottom, Top, Mouse
        TargetPart = "Head" -- Head, HumanoidRootPart, Torso
    }
}

-- Таблица для хранения трейсеров
TracersDrawings = {}

-- Переменная для отслеживания положения мыши
mousePosition = Vector2.new(0, 0)
o.uis.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement then
        mousePosition = Vector2.new(input.Position.X, input.Position.Y)
    end
end)

-- Обновляем позицию мыши каждый кадр для точности
o.rs.Heartbeat:Connect(function()
    mousePosition = o.uis:GetMouseLocation()
end)

-- Функция для получения начальной точки трейсера
function getTracerOrigin(originType)
    camera = o.camera
    viewportSize = camera.ViewportSize
    
    if originType == "Bottom" then
        return Vector2.new(viewportSize.X / 2, viewportSize.Y)
    elseif originType == "Top" then
        return Vector2.new(viewportSize.X / 2, 0)
    elseif originType == "Mouse" then
        -- Получаем точную позицию мыши
        mousePos = o.uis:GetMouseLocation()
        return mousePos
    else
        return Vector2.new(viewportSize.X / 2, viewportSize.Y) -- По умолчанию снизу
    end
end

-- Функция для создания трейсера для игрока
function createTracer(player)
    if not TracersDrawings[player] then
        TracersDrawings[player] = {
            tracer = Drawing.new("Line"),
            player = player
        }
    end
    
    tracer = TracersDrawings[player].tracer
    tracer.Thickness = 1
    tracer.Color = Color3.fromRGB(255, 255, 255)
    tracer.Transparency = 1
    tracer.Visible = false
    
    return tracer
end

-- Функция для обновления трейсера
function updateTracer(player, tracerType)
    if not TracersConfig.Enabled then return end
    
    -- Проверяем, включен ли соответствующий тип трейсеров
    if tracerType == "Players" and not TracersConfig.Players.Enabled then return end
    if tracerType == "Friends" and not TracersConfig.Friends.Enabled then return end
    
    -- Получаем настройки для данного типа
    config = tracerType == "Players" and TracersConfig.Players or TracersConfig.Friends
    
    -- Проверяем, является ли игрок другом
    if tracerType == "Friends" and not MaterialChamsConfig.Friend.Friends[player.Name] then
        return
    end
    
    -- Проверяем, является ли игрок не другом для Players трейсеров
    if tracerType == "Players" and MaterialChamsConfig.Friend.Friends[player.Name] then
        return
    end
    
    -- Создаем трейсер, если его нет
    if not TracersDrawings[player] then
        createTracer(player)
    end
    
    tracer = TracersDrawings[player].tracer
    
    -- Проверяем, что игрок существует и имеет персонажа
    if not player.Character then
        tracer.Visible = false
        return
    end
    
    -- Получаем целевую часть тела
    targetPart = player.Character:FindFirstChild(config.TargetPart)
    if not targetPart then
        tracer.Visible = false
        return
    end
    
    -- Получаем позицию на экране
    screenPos, onScreen = o.camera:WorldToViewportPoint(targetPart.Position)
    
    if onScreen then
        -- Получаем начальную точку трейсера
        origin = getTracerOrigin(config.Origin)
        
        -- Обновляем трейсер
        tracer.From = origin
        tracer.To = Vector2.new(screenPos.X, screenPos.Y)
        tracer.Thickness = config.Thickness
        tracer.Color = config.Color
        tracer.Transparency = 1
        tracer.Visible = true
    else
        tracer.Visible = false
    end
end

-- Функция для удаления трейсера
function removeTracer(player)
    if TracersDrawings[player] then
        if TracersDrawings[player].tracer then
            TracersDrawings[player].tracer:Remove()
        end
        TracersDrawings[player] = nil
    end
end

-- Функция для обновления всех трейсеров
function updateAllTracers()
    for player, drawing in pairs(TracersDrawings) do
        if player and player.Parent then
            updateTracer(player, "Players")
            updateTracer(player, "Friends")
        else
            removeTracer(player)
        end
    end
end

-- Функция для применения трейсеров Players
function applyPlayersTracers()
    for _, player in pairs(o.plrs:GetPlayers()) do
        if player ~= o.lp then
            updateTracer(player, "Players")
        end
    end
end

-- Функция для применения трейсеров Friends
function applyFriendsTracers()
    for _, player in pairs(o.plrs:GetPlayers()) do
        if player ~= o.lp and MaterialChamsConfig.Friend.Friends[player.Name] then
            updateTracer(player, "Friends")
        end
    end
end

-- Функция для удаления трейсеров Players
function removePlayersTracers()
    for player, drawing in pairs(TracersDrawings) do
        if drawing.tracer then
            drawing.tracer.Visible = false
        end
    end
end

-- Функция для удаления трейсеров Friends
function removeFriendsTracers()
    for player, drawing in pairs(TracersDrawings) do
        if drawing.tracer then
            drawing.tracer.Visible = false
        end
    end
end

-- Добавляем тогл Tracers с попапом в существующую секцию VisualsMainSection
TracersToggle = VisualsMainSection:Toggle({
    name = "Tracers",
    default = false,
    flag = "visual_tracers",
    callback = function(value)
        TracersConfig.Enabled = value
        
        -- Обновляем состояние всех подтоглов в зависимости от главного тогла
        if not value then
            -- Если главный тогл выключен, выключаем все трейсеры
            TracersConfig.Players.Enabled = false
            TracersConfig.Friends.Enabled = false
            removePlayersTracers()
            removeFriendsTracers()
        else
            -- Если главный тогл включен, восстанавливаем состояния из флагов
            TracersConfig.Players.Enabled = Library.Flags["tracers_players"] or false
            TracersConfig.Friends.Enabled = Library.Flags["tracers_friends"] or false
        end
        
        -- Обновляем все трейсеры
        updateAllTracers()
    end
})

-- Создаем попап для Tracers
TracersPopup = TracersToggle:Popup({size = 250})

-- Добавляем тогл Players с попапом
PlayersTracersToggle = TracersPopup:Toggle({
    name = "Players",
    default = false,
    flag = "tracers_players",
    callback = function(value)
        TracersConfig.Players.Enabled = value
        
        -- Проверяем состояние главного тогла
        if not Library.Flags["visual_tracers"] then
            return
        end
        
        if value then
            applyPlayersTracers()
        else
            removePlayersTracers()
        end
    end
})

-- Создаем попап для Players
PlayersTracersPopup = PlayersTracersToggle:Popup({size = 200})

-- Добавляем колорпикер для цвета Players
PlayersTracersPopup:Colorpicker({
    name = "Color",
    description = ">_<",
    default = Color3.fromRGB(255, 255, 255),
    flag = "players_tracers_color",
    callback = function(color)
        if type(color) == "table" and color.c then
            TracersConfig.Players.Color = color.c
        else
            TracersConfig.Players.Color = color
        end
        
        -- Если включено, сразу применяем
        if TracersConfig.Players.Enabled and Library.Flags["visual_tracers"] then
            applyPlayersTracers()
        end
    end
})

-- Добавляем слайдер для толщины Players
PlayersTracersPopup:Slider({
    name = "Thickness",
    min = 1,
    max = 5,
    default = 1,
    float = 1,
    flag = "players_tracers_thickness",
    callback = function(value)
        TracersConfig.Players.Thickness = value
        
        -- Если включено, сразу применяем
        if TracersConfig.Players.Enabled and Library.Flags["visual_tracers"] then
            applyPlayersTracers()
        end
    end
})

-- Добавляем выпадающий список для точки начала Players
PlayersTracersPopup:Dropdown({
    name = "Origin",
    values = {"Bottom", "Top", "Mouse"},
    value = "Bottom",
    flag = "players_tracers_origin",
    callback = function(value)
        TracersConfig.Players.Origin = value
        
        -- Если включено, сразу применяем
        if TracersConfig.Players.Enabled and Library.Flags["visual_tracers"] then
            applyPlayersTracers()
        end
    end
})

-- Добавляем выпадающий список для целевой части тела Players
PlayersTracersPopup:Dropdown({
    name = "Target Part",
    values = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso"},
    value = "Head",
    flag = "players_tracers_target",
    callback = function(value)
        TracersConfig.Players.TargetPart = value
        
        -- Если включено, сразу применяем
        if TracersConfig.Players.Enabled and Library.Flags["visual_tracers"] then
            applyPlayersTracers()
        end
    end
})

-- Добавляем тогл Friends с попапом
FriendsTracersToggle = TracersPopup:Toggle({
    name = "Friends",
    default = false,
    flag = "tracers_friends",
    callback = function(value)
        TracersConfig.Friends.Enabled = value
        
        -- Проверяем состояние главного тогла
        if not Library.Flags["visual_tracers"] then
            return
        end
        
        if value then
            applyFriendsTracers()
        else
            removeFriendsTracers()
        end
    end
})

-- Создаем попап для Friends
FriendsTracersPopup = FriendsTracersToggle:Popup({size = 200})

-- Добавляем колорпикер для цвета Friends
FriendsTracersPopup:Colorpicker({
    name = "Color",
    description = ">_<",
    default = Color3.fromRGB(0, 255, 0),
    flag = "friends_tracers_color",
    callback = function(color)
        if type(color) == "table" and color.c then
            TracersConfig.Friends.Color = color.c
        else
            TracersConfig.Friends.Color = color
        end
        
        -- Если включено, сразу применяем
        if TracersConfig.Friends.Enabled and Library.Flags["visual_tracers"] then
            applyFriendsTracers()
        end
    end
})

-- Добавляем слайдер для толщины Friends
FriendsTracersPopup:Slider({
    name = "Thickness",
    min = 1,
    max = 5,
    default = 1,
    float = 1,
    flag = "friends_tracers_thickness",
    callback = function(value)
        TracersConfig.Friends.Thickness = value
        
        -- Если включено, сразу применяем
        if TracersConfig.Friends.Enabled and Library.Flags["visual_tracers"] then
            applyFriendsTracers()
        end
    end
})

-- Добавляем выпадающий список для точки начала Friends
FriendsTracersPopup:Dropdown({
    name = "Origin",
    values = {"Bottom", "Top", "Mouse"},
    value = "Bottom",
    flag = "friends_tracers_origin",
    callback = function(value)
        TracersConfig.Friends.Origin = value
        
        -- Если включено, сразу применяем
        if TracersConfig.Friends.Enabled and Library.Flags["visual_tracers"] then
            applyFriendsTracers()
        end
    end
})

-- Добавляем выпадающий список для целевой части тела Friends
FriendsTracersPopup:Dropdown({
    name = "Target Part",
    values = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso"},
    value = "Head",
    flag = "friends_tracers_target",
    callback = function(value)
        TracersConfig.Friends.TargetPart = value
        
        -- Если включено, сразу применяем
        if TracersConfig.Friends.Enabled and Library.Flags["visual_tracers"] then
            applyFriendsTracers()
        end
    end
})

-- Создаем соединение для обновления трейсеров
if not o.tracersConnection then
    o.tracersConnection = o.rs.Heartbeat:Connect(function()
        if TracersConfig.Enabled then
            updateAllTracers()
        end
    end)
end

-- Создаем соединение для добавления новых игроков
if not o.tracersPlayerAddedConnection then
    o.tracersPlayerAddedConnection = o.plrs.PlayerAdded:Connect(function(player)
        if TracersConfig.Enabled then
            createTracer(player)
        end
    end)
end

-- Создаем соединение для удаления игроков
if not o.tracersPlayerRemovingConnection then
    o.tracersPlayerRemovingConnection = o.plrs.PlayerRemoving:Connect(function(player)
        removeTracer(player)
    end)
end

-- Создаем секцию Main во вкладке Player
PlayerMainSection = PlayerTab:Section({name = "Main", description = ">_<"})

-- Добавляем тогл Anti AFK
PlayerMainSection:Toggle({
    name = "Anti AFK",
    default = false,
    flag = "player_antiafk",
    callback = function(value)
        if value then
            -- Создаем и запускаем Anti AFK скрипт
            o.antiAFKConnection = o.lp.Idled:Connect(function()
                o.VirtualUser = o.GU
                o.VirtualUser:CaptureController()
                o.VirtualUser:ClickButton2(Vector2.new())
            end)
            
            -- Сохраняем соединение в Library.Flags для возможности отключения
            Library.Flags["antiafk_connection"] = o.antiAFKConnection
        else
            -- Отключаем Anti AFK если тогл выключен
            if o.antiAFKConnection then
                o.antiAFKConnection:Disconnect()
                o.antiAFKConnection = nil
                Library.Flags["antiafk_connection"] = nil
            end
        end
    end
})

-- Добавляем тогл FakeMacro (только с LeftControl)
PlayerMainSection:Toggle({
    name = "Fake Macro",
    default = false,
    flag = "player_fakemacro",
    callback = function(value)
        -- Включаем/выключаем FakeMacro
        Library.Flags["fakemacro_enabled"] = value
        
        -- Управляем соединениями
        if value then
            -- Создаем соединения, если их еще нет
            if not Library.Flags["fakemacro_connections"] then
                -- Глобальная переменная для отслеживания состояния
                o.toggleEnabled = false
                
                -- Соединение для отслеживания нажатия клавиши LeftControl
                o.fakeMacroInputBegan = o.uis.InputBegan:Connect(function(input, gameProcessed)
                    if input.KeyCode == Enum.KeyCode.LeftControl and not gameProcessed then
                        o.toggleEnabled = true
                    end
                end)
                
                -- Соединение для отслеживания отпускания клавиши LeftControl
                o.fakeMacroInputEnded = o.uis.InputEnded:Connect(function(input, gameProcessed)
                    if input.KeyCode == Enum.KeyCode.LeftControl and not gameProcessed then
                        o.toggleEnabled = false
                    end
                end)
                
                -- Соединение для обновления ориентации персонажа
                o.fakeMacroHeartbeat = o.rs.Heartbeat:Connect(function()
                    if o.toggleEnabled then
                        o.common_vars.char = o.lp.Character
                        if o.common_vars.char then
                            o.common_vars.hrp = o.common_vars.char:FindFirstChild("HumanoidRootPart")
                            if o.common_vars.hrp and o.common_vars.hrp:IsDescendantOf(game) and o.camera then
                                pcall(function()
                                o.common_vars.hrp.CFrame = o.funcs.cf(o.common_vars.hrp.Position) * 
                                    CFrame.Angles(0, math.atan2(-o.camera.CFrame.LookVector.X, -o.camera.CFrame.LookVector.Z), 0)
                                end)
                            end
                        end
                    end
                end)
                
                -- Сохраняем соединения для возможности отключения
                Library.Flags["fakemacro_connections"] = {
                    inputBegan = o.fakeMacroInputBegan,
                    inputEnded = o.fakeMacroInputEnded,
                    heartbeat = o.fakeMacroHeartbeat
                }
            end
        else
            -- Отключаем соединения, если тогл выключен
            if Library.Flags["fakemacro_connections"] then
                if o.fakeMacroInputBegan then o.fakeMacroInputBegan:Disconnect() end
                if o.fakeMacroInputEnded then o.fakeMacroInputEnded:Disconnect() end
                if o.fakeMacroHeartbeat then o.fakeMacroHeartbeat:Disconnect() end
                Library.Flags["fakemacro_connections"] = nil
            end
        end
    end
})

-- Добавляем тогл No Collision
PlayerMainSection:Toggle({
    name = "No Collision",
    default = false,
    flag = "player_nocollision",
    callback = function(value)
        -- Получаем персонажа
        o.common_vars.char = o.lp.Character
        
        if o.common_vars.char then
            -- Используем функцию setNoClip для включения/выключения коллизий
            if not _G.setNoClip_defined and setNoClip then
                _G.setNoClip_defined = true
            end
            
            if _G.setNoClip_defined or setNoClip then
                setNoClip(o.common_vars.char, value)
            end
        end
        
        -- Если тогл включен, создаем соединение для новых персонажей
        if value then
            if not o.noCollisionConnection then
                o.noCollisionConnection = o.lp.CharacterAdded:Connect(function(character)
                    task.wait(0.5) -- Небольшая задержка для загрузки персонажа
                    if Library.Flags["player_nocollision"] then
                        if _G.setNoClip_defined or setNoClip then
                            setNoClip(character, true)
                        end
                    end
                end)
            end
        else
            -- Отключаем соединение при выключении тогла
            if o.noCollisionConnection then
                o.noCollisionConnection:Disconnect()
                o.noCollisionConnection = nil
            end
        end
    end
})

-- Добавляем тогл No Jump Cooldown
PlayerMainSection:Toggle({
    name = "No Jump Cooldown",
    default = false,
    flag = "player_nojumpcooldown",
    callback = function(value)
        -- Определяем hookmetamethod и checkcaller, если они не существуют
        if not _G.hookmetamethod_defined then
            _G.hookmetamethod_defined = true
            if not hookmetamethod then
                hookmetamethod = function(obj, metamethod, hook)
                    -- Заглушка для hookmetamethod
                    local original = obj[metamethod]
                    obj[metamethod] = hook
                    return original
                end
            end
            
            if not checkcaller then
                checkcaller = function()
                    -- Заглушка для checkcaller
                    return false
                end
            end
        end
        
        -- Сохраняем оригинальный хук, если он еще не сохранен
        if not o.originalJumpHook then
            o.originalJumpHook = hookmetamethod(game, "__newindex", function(self, Index, Value)
                -- Если тогл включен и это изменение JumpPower, блокируем его
                if Library.Flags["player_nojumpcooldown"] and not checkcaller() and self:IsA("Humanoid") and Index == "JumpPower" then 
                    return
                end
                
                -- Иначе пропускаем вызов
                return o.originalJumpHook(self, Index, Value)
            end)
        end
    end
})

-- Добавляем тогл Prediction Visualizer с попапом
o.VisualizeVelocityToggle = PlayerMainSection:Toggle({
    name = "Prediction Visualizer",
    default = false,
    flag = "player_visualizevel",
    callback = function(value)
        -- Инициализируем объекты для визуализации, если их еще нет
        if not o.velocityDrawings then
            o.velocityDrawings = {
                line = Drawing.new("Line"),
                circle = Drawing.new("Circle")
            }
            
            -- Настраиваем линию
            o.velocityDrawings.line.Thickness = 1
            o.velocityDrawings.line.Color = Color3.fromRGB(255, 0, 0)
            o.velocityDrawings.line.Transparency = 1
            o.velocityDrawings.line.ZIndex = 1
            
            -- Настраиваем круг для конечной точки
            o.velocityDrawings.circle.Thickness = 1
            o.velocityDrawings.circle.Color = Color3.fromRGB(255, 0, 0)
            o.velocityDrawings.circle.Transparency = 1
            o.velocityDrawings.circle.NumSides = 12
            o.velocityDrawings.circle.Radius = 3
            o.velocityDrawings.circle.Filled = true
            o.velocityDrawings.circle.ZIndex = 2
        end
        
        if value then
            -- Создаем соединение для обновления линии
            if not o.visualizeVelConnection then
                o.visualizeVelConnection = o.rs.RenderStepped:Connect(function()
                    o.common_vars.char = o.lp.Character
                    if not o.common_vars.char then 
                        o.velocityDrawings.line.Visible = false
                        o.velocityDrawings.circle.Visible = false
                        return 
                    end
                    
                    o.common_vars.hrp = o.common_vars.char:FindFirstChild("HumanoidRootPart")
                    if not o.common_vars.hrp then 
                        o.velocityDrawings.line.Visible = false
                        o.velocityDrawings.circle.Visible = false
                        return 
                    end
                    
                    -- Получаем текущую скорость
                    o.common_vars.vel = o.common_vars.hrp.Velocity
                    
                    -- Если скорость слишком мала, делаем линию невидимой
                    if o.common_vars.vel.Magnitude < 0.1 then
                        o.velocityDrawings.line.Visible = false
                        o.velocityDrawings.circle.Visible = false
                        return
                    end
                    
                    -- Устанавливаем прозрачность линии и круга
                    o.velocityDrawings.line.Transparency = 0.7
                    o.velocityDrawings.circle.Transparency = 0.7
                    
                    -- Устанавливаем цвет линии и круга
                    if Library.Flags["visualizevel_color"] then
                        if type(Library.Flags["visualizevel_color"]) == "table" and Library.Flags["visualizevel_color"].c then
                            o.velocityDrawings.line.Color = Library.Flags["visualizevel_color"].c
                            o.velocityDrawings.circle.Color = Library.Flags["visualizevel_color"].c
                        else
                            o.velocityDrawings.line.Color = Library.Flags["visualizevel_color"]
                            o.velocityDrawings.circle.Color = Library.Flags["visualizevel_color"]
                        end
                    end
                    
                    -- Масштабируем скорость для лучшей визуализации
                    o.common_vars.scale = Library.Flags["visualizevel_scale"] or 0.1
                    o.common_vars.scaledVel = o.common_vars.vel * o.common_vars.scale
                    
                    -- Получаем позиции для начала и конца линии
                    o.common_vars.startPos = o.common_vars.hrp.Position
                    o.common_vars.endPos = o.common_vars.startPos + o.common_vars.scaledVel
                    
                    -- Конвертируем 3D позиции в 2D для отображения на экране
                    o.common_vars.startPos2D = o.camera:WorldToViewportPoint(o.common_vars.startPos)
                    o.common_vars.endPos2D = o.camera:WorldToViewportPoint(o.common_vars.endPos)
                    
                    -- Проверяем, что обе точки видны на экране
                    if o.common_vars.startPos2D.Z > 0 and o.common_vars.endPos2D.Z > 0 then
                        -- Устанавливаем позиции линии
                        o.velocityDrawings.line.From = Vector2.new(o.common_vars.startPos2D.X, o.common_vars.startPos2D.Y)
                        o.velocityDrawings.line.To = Vector2.new(o.common_vars.endPos2D.X, o.common_vars.endPos2D.Y)
                        o.velocityDrawings.line.Visible = true
                        
                        -- Устанавливаем позицию круга
                        o.velocityDrawings.circle.Position = Vector2.new(o.common_vars.endPos2D.X, o.common_vars.endPos2D.Y)
                        o.velocityDrawings.circle.Visible = true
                    else
                        o.velocityDrawings.line.Visible = false
                        o.velocityDrawings.circle.Visible = false
                    end
                end)
            end
        else
            -- Отключаем соединение и скрываем визуализатор
            if o.visualizeVelConnection then
                o.visualizeVelConnection:Disconnect()
                o.visualizeVelConnection = nil
            end
            
            -- Скрываем визуализатор
            if o.velocityDrawings then
                o.velocityDrawings.line.Visible = false
                o.velocityDrawings.circle.Visible = false
            end
        end
    end
})

-- Создаем попап для Prediction Visualizer
o.VisualizeVelocityPopup = o.VisualizeVelocityToggle:Popup({size = 150})

-- Добавляем колорпикер для цвета линии
o.VisualizeVelocityPopup:Colorpicker({
    name = "Line Color",
    description = ">_<",
    default = Color3.fromRGB(255, 0, 0),
    flag = "visualizevel_color",
    callback = function(color)
        if o.velocityDrawings then
            if type(color) == "table" and color.c then
                o.velocityDrawings.line.Color = color.c
                o.velocityDrawings.circle.Color = color.c
            else
                o.velocityDrawings.line.Color = color
                o.velocityDrawings.circle.Color = color
            end
        end
    end
})

-- Добавляем слайдер для масштаба линии
o.VisualizeVelocityPopup:Slider({
    name = "Scale",
    min = 0.01,
    max = 1,
    default = 0.1,
    float = 0.01,
    flag = "visualizevel_scale",
    callback = function(value)
        Library.Flags["visualizevel_scale"] = value
    end
})

-- Добавляем тогл Velocity Anti Aim
PlayerMainSection:Toggle({
    name = "Velocity Anti Aim",
    default = false,
    flag = "player_velocityaa",
    callback = function(value)
        if value then
            -- Создаем соединение, если его еще нет
            if not o.velocityAAConnection then
                o.velocityAAConnection = o.rs.Heartbeat:Connect(function()
                    o.common_vars.char = o.lp.Character
                    if not o.common_vars.char then return end
                    
                    o.common_vars.hrp = o.common_vars.char:FindFirstChild("HumanoidRootPart")
                    if not o.common_vars.hrp then return end
                    
                    -- Сохраняем текущую скорость
                    o.common_vars.vel = o.common_vars.hrp.Velocity
                    
                    -- Устанавливаем анти-аим скорость
                    o.common_vars.hrp.Velocity = o.funcs.v3(0, 250, 0)
                    
                    -- Ждем рендер и возвращаем исходную скорость
                    o.rs.RenderStepped:Wait()
                    
                    -- Проверяем, что персонаж и HRP все еще существуют
                    if o.common_vars.char and o.common_vars.char.Parent and o.common_vars.hrp and o.common_vars.hrp.Parent then
                        o.common_vars.hrp.Velocity = o.common_vars.vel
                    end
                end)
            end
        else
            -- Отключаем соединение при выключении тогла
            if o.velocityAAConnection then
                o.velocityAAConnection:Disconnect()
                o.velocityAAConnection = nil
            end
        end
    end
})

-- Функция для изменения настроек отображения имен
function SetNameDisplay(enabled, mode)
    o.NameDisplayEnabled = enabled
    o.NameDisplayMode = mode or "display"
    
    -- Сохраняем режим в флагах для использования в других местах
    Library.Flags["name_display_actual_mode"] = o.NameDisplayMode
    
    -- Обновить все имена
    for _, player in ipairs(o.plrs:GetPlayers()) do
        if player.Character then
            o.common_vars.hum = player.Character:FindFirstChild("Humanoid")
            if o.common_vars.hum then
                -- Всегда сбрасываем параметры отображения к стандартным при выключении тогла
                if not o.NameDisplayEnabled then
                    -- Возвращаем исходное отображение имени
                    o.common_vars.hum.DisplayName = player.DisplayName
                    o.common_vars.hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Viewer
                    
                    -- Если были удалены BillboardGui на голове, восстановим систему имен
                    o.common_vars.head = player.Character:FindFirstChild("Head")
                    if o.common_vars.head then
                        -- Если никаких билбордов нет, это может означать, что они были удалены
                        o.common_vars.hasBillboard = false
                        for _, child in ipairs(o.common_vars.head:GetChildren()) do
                            if child:IsA("BillboardGui") then
                                o.common_vars.hasBillboard = true
                                break
                            end
                        end
                        
                        -- Принудительно обновляем персонажа для восстановления имен если нужно
                        if not o.common_vars.hasBillboard then
                            -- Обновляем настройки гуманоида для восстановления отображения имени
                            task.delay(0.1, function()
                                if o.common_vars.hum then
                                    o.common_vars.hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Subject
                                    task.delay(0.1, function()
                                        if o.common_vars.hum then
                                            o.common_vars.hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Viewer
                                        end
                                    end)
                                end
                            end)
                        end
                    end
                else
                    if o.NameDisplayMode == "display" then
                        o.common_vars.hum.DisplayName = player.DisplayName
                        o.common_vars.hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Viewer
                    elseif o.NameDisplayMode == "original" then
                        o.common_vars.hum.DisplayName = player.Name
                        o.common_vars.hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Viewer
                    elseif o.NameDisplayMode == "none" then
                        -- Полностью скрываем имя, устанавливая пустую строку И делая его прозрачным
                        o.common_vars.hum.DisplayName = ""
                        o.common_vars.hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
                        -- Для дополнительной надежности также пробуем другие методы скрытия имени
                        o.common_vars.head = player.Character:FindFirstChild("Head")
                        if o.common_vars.head then
                            -- Удаляем существующие текстовые метки над головой
                            for _, child in ipairs(o.common_vars.head:GetChildren()) do
                                if child:IsA("BillboardGui") then
                                    child:Destroy()
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    
    -- Настраиваем обработчики для новых игроков и персонажей
    if not Library.Flags["name_display_connection"] then
        o.nameDisplayConnection = o.plrs.PlayerAdded:Connect(function(player)
            player.CharacterAdded:Connect(function(character)
                o.common_vars.hum = character:FindFirstChild("Humanoid")
                if o.common_vars.hum then
                    if Library.Flags["player_alwaysshow"] then
                        o.common_vars.mode = Library.Flags["name_display_actual_mode"]
                        if o.common_vars.mode == "display" then
                            o.common_vars.hum.DisplayName = player.DisplayName
                            o.common_vars.hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Viewer
                        elseif o.common_vars.mode == "original" then
                            o.common_vars.hum.DisplayName = player.Name
                            o.common_vars.hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Viewer
                        elseif o.common_vars.mode == "none" then
                            o.common_vars.hum.DisplayName = ""
                            o.common_vars.hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
                            
                            -- Дополнительные методы для полного скрытия имени
                            task.delay(0.5, function() -- Небольшая задержка для гарантии загрузки головы
                                if player.Character and player.Character:FindFirstChild("Head") then
                                    for _, child in ipairs(player.Character.Head:GetChildren()) do
                                        if child:IsA("BillboardGui") then
                                            child:Destroy()
                                        end
                                    end
                                end
                            end)
                        end
                    else
                        -- Если тогл выключен, восстанавливаем имя
                        o.common_vars.hum.DisplayName = player.DisplayName
                        o.common_vars.hum.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Viewer
                    end
                end
            end)
        end)
        
        -- Сохраняем соединение для возможности отключения
        Library.Flags["name_display_connection"] = o.nameDisplayConnection
    end
end

-- Добавляем тогл Always Show с попапом для настройки отображения имен
PlayerMainSection:Toggle({
    name = "Always Show",
    default = false,
    flag = "player_alwaysshow",
    callback = function(value)
        -- Включаем/выключаем систему отображения имен
        SetNameDisplay(value, Library.Flags["name_display_actual_mode"])
    end
}):Popup({size = 150}):Dropdown({
    name = "Display Mode",
    values = {"Display Name", "Original Name", "No Name"},
    value = "Display Name",
    flag = "name_display_mode",
    callback = function(option)
        -- Определяем режим отображения на основе выбранного значения
        if option == "Display Name" then
            o.common_vars.mode = "display"
        elseif option == "Original Name" then
            o.common_vars.mode = "original"
        elseif option == "No Name" then
            o.common_vars.mode = "none"
        end
        
        -- Обновляем режим отображения имен, если система включена
        if Library.Flags["player_alwaysshow"] then
            SetNameDisplay(true, o.common_vars.mode)
        end
    end
})

-- Создаем секцию Movement во вкладке Player (справа)
PlayerMovementSection = PlayerTab:Section({name = "Movement", description = ">_<", side = "right"})

-- Создаем секцию Desynchronization во вкладке Player (справа)
PlayerDesyncSection = PlayerTab:Section({name = "Desynchronization", description = ">_<", side = "right"})

-- Определение объекта Desync
o.Desync = {
    Positions = {
        Old = nil,
        New = nil
    },
    Overwriten = nil,
    ClonedCharacter = nil,
    NewStatus = nil,
    LastActiveStatus = nil,
}

-- Проверка активности десинхронизации
function o.Desync:Active()
    local hrp = o.getHrp()
    o.common_vars.isActive = (self.NewStatus or Library.Flags["desync"] and Library.Flags["desync_key"]) and hrp and hrp:IsDescendantOf(game)
    
    -- Если статус десинка изменился, проверяем нужно ли обновить клон
    if self.LastActiveStatus ~= o.common_vars.isActive then
        self.LastActiveStatus = o.common_vars.isActive
        
        -- Проверяем, должен ли быть виден клон
        o.common_vars.shouldShowClone = o.common_vars.isActive and Library.Flags["desync_vis"]
        
        -- Управляем видимостью клона
        if o.common_vars.shouldShowClone and not self.ClonedCharacter then
            self:CloneCharacter()
        elseif not o.common_vars.shouldShowClone and self.ClonedCharacter then
            self:DestroyClonedCharacter()
        end
    end
    
    return o.common_vars.isActive
end

-- Установка статуса десинхронизации
function o.Desync:SetStatus(status)
    -- Запоминаем предыдущий статус
    o.common_vars.previousStatus = self.NewStatus
    
    -- Устанавливаем новый статус
    self.NewStatus = status
    
    -- Если статус изменился, обновляем клон
    if o.common_vars.previousStatus ~= status then
        -- Проверяем, должен ли быть виден клон
        o.common_vars.isActive = (status or Library.Flags["desync"] and Library.Flags["desync_key"]) and o.getHrp()
        o.common_vars.shouldShowClone = o.common_vars.isActive and Library.Flags["desync_vis"]
        
        -- Управляем видимостью клона
        if o.common_vars.shouldShowClone and not self.ClonedCharacter then
            self:CloneCharacter()
        elseif not o.common_vars.shouldShowClone and self.ClonedCharacter then
            self:DestroyClonedCharacter()
        end
    end
end

-- Получение позиций (старой и новой)
function o.Desync:GetPositions()
    o.common_vars.positions = self.Positions
    o.common_vars.status = self:Active()

    if not o.common_vars.status then
        return
    end

    return o.common_vars.positions.Old, o.common_vars.positions.New
end

-- Получение значения интерполяции
function o.Desync:GetLerpValue(pulse, min, max, speed)
    speed = speed or 1
    o.common_vars.normalizedSin = (math.sin(pulse * speed) + 1) / 2
    return min + o.common_vars.normalizedSin * (max - min)
end

-- Получение значения для конкретного типа позиции
function o.Desync:GetValue(pos_type)
    o.common_vars.clockPulse = os.clock()

    o.common_vars.mode = Library.Flags["desync_mode_" .. pos_type]
    o.common_vars.min = Library.Flags["desync_min_" .. pos_type] or tonumber(Library.Flags["desync_min_" .. pos_type .. "_text"]) or 0
    o.common_vars.max = Library.Flags["desync_max_" .. pos_type] or tonumber(Library.Flags["desync_max_" .. pos_type .. "_text"]) or 0
    o.common_vars.val = Library.Flags["desync_val_" .. pos_type] or tonumber(Library.Flags["desync_val_" .. pos_type .. "_text"]) or 0
    o.common_vars.speed = Library.Flags["desync_speed_" .. pos_type] or tonumber(Library.Flags["desync_speed_" .. pos_type .. "_text"]) or 1

    return 
        Library.Flags["desync_" .. pos_type] == true and 
            (o.common_vars.mode == "Static" and o.common_vars.val 
            or o.common_vars.mode == "Lerp" and self:GetLerpValue(o.common_vars.clockPulse, o.common_vars.min, o.common_vars.max, o.common_vars.speed)
            or o.common_vars.mode == "Random" and math.random(o.common_vars.min * 100, o.common_vars.max * 100) / 100)
        or not Library.Flags["desync_" .. pos_type] and 0
end

-- Перезапись позиции
function o.Desync:OverwritePosition(position)
    self.Overwriten = position
end

-- Удаление перезаписи позиции
function o.Desync:RemoveOverwrite()
    self.Overwriten = nil
end

-- Клонирование персонажа для визуализации
function o.Desync:CloneCharacter()
    o.common_vars.char = o.lp.Character

    if not o.common_vars.char then
        return
    end
    
    -- Уничтожаем предыдущий клон, если он существует
    self:DestroyClonedCharacter()

    o.common_vars.char.Archivable = true

    o.common_vars.clonedChar = o.common_vars.char:Clone()

    o.common_vars.clonedChar.Archivable = true
    o.common_vars.clonedChar.Name = "DesyncClone"
    o.common_vars.clonedChar.Parent = workspace

    o.common_vars.char.Archivable = false

    o.common_vars.hum = o.common_vars.clonedChar:FindFirstChildWhichIsA("Humanoid")
    o.common_vars.hrp = o.common_vars.clonedChar:FindFirstChild(o.r15.root)

    if not o.common_vars.hrp then
        o.common_vars.clonedChar:Destroy()
        return
    end

    -- Обработка всех частей клонированного персонажа
    for _, v in pairs(o.common_vars.clonedChar:GetDescendants()) do
        if v:IsA("Part") or v:IsA("MeshPart") or v:IsA("BasePart") then
            -- Настраиваем внешний вид частей
            if v.Transparency ~= 1 then
                o.common_vars.color = Library.Flags["desync_vis_color"] or {c = o.funcs.rgb(255, 0, 0), a = 0.5}
                
                -- Определяем материал
                o.common_vars.materialName = Library.Flags["desync_vis_material"] or "ForceField"
                o.common_vars.material = o.getMaterial(o.common_vars.materialName)
                
                v.Material = o.common_vars.material
                v.Color = o.common_vars.color.c
                v.Transparency = 0.5 -- Фиксированная прозрачность для лучшей видимости
            end
            
            -- Отключаем коллизии и делаем части якорными
            v.CanCollide = false
            v.Anchored = true
            
            -- Отключаем физику
            if v:IsA("BasePart") then
                v.Massless = true
                v.Velocity = o.funcs.v3(0, 0, 0)
                v.RotVelocity = o.funcs.v3(0, 0, 0)
            end
        elseif v:IsA("Accessory") or v:IsA("Clothing") or v:IsA("ShirtGraphic") or v:IsA("Script") or v:IsA("LocalScript") then
            -- Удаляем аксессуары, одежду и скрипты
            v:Destroy()
        end
    end

    -- Удаляем гуманоида
    if o.common_vars.hum then
        o.common_vars.hum:Destroy()
    end

    -- Сохраняем ссылку на клонированного персонажа
    self.ClonedCharacter = {
        Character = o.common_vars.clonedChar,
        RootPart = o.common_vars.hrp
    }
    
    -- Возвращаем созданный клон
    return self.ClonedCharacter
end

-- Обновление визуального представления персонажа
function o.Desync:UpdateCharacter()
    o.common_vars.clonedChar = self.ClonedCharacter

    if not o.common_vars.clonedChar or not o.common_vars.clonedChar.Character then
        -- Если клон не существует, создаем его
        if Library.Flags["desync_vis"] then
            self:CloneCharacter()
        end
        return
    end

    -- Получаем текущие настройки внешнего вида
    o.common_vars.color = Library.Flags["desync_vis_color"] or {c = o.funcs.rgb(255, 0, 0), a = 0.5}
    
    -- Определяем материал
    o.common_vars.materialName = Library.Flags["desync_vis_material"] or "ForceField"
    o.common_vars.material = o.getMaterial(o.common_vars.materialName)

    -- Обновляем внешний вид всех частей
    for _, v in pairs(o.common_vars.clonedChar.Character:GetDescendants()) do
        if v:IsA("Part") or v:IsA("MeshPart") or v:IsA("BasePart") then
            if v.Transparency ~= 1 then
                v.Material = o.common_vars.material
                v.Color = o.common_vars.color.c
                v.Transparency = 0.5 -- Фиксированная прозрачность для лучшей видимости
            end
            
            -- Убедимся, что части остаются якорными и не имеют коллизий
            v.CanCollide = false
            v.Anchored = true
        end
    end
    
    -- Проверяем, что RootPart существует и обновляем его позицию
    if o.common_vars.clonedChar.RootPart then
        o.common_vars.hrp = o.getHrp()
        if o.common_vars.hrp then
            o.common_vars.clonedChar.RootPart.CFrame = o.common_vars.hrp.CFrame
        end
    end
end

-- Уничтожение клонированного персонажа
function o.Desync:DestroyClonedCharacter()
    o.common_vars.clonedCharacter = self.ClonedCharacter

    if o.common_vars.clonedCharacter and o.common_vars.clonedCharacter.Character then
        o.common_vars.clonedCharacter.Character:Destroy()
        self.ClonedCharacter = nil
        return true
    end
    
    return false
end

-- Основная функция десинхронизации
function o.Desync:Think()
    o.common_vars.hrp = o.getHrp()
    if not o.common_vars.hrp then return end
    
    o.common_vars.isActive = self:Active()
    o.common_vars.positions = self.Positions
    o.common_vars.clonedChar = self.ClonedCharacter
    
    -- Проверяем, должен ли клон существовать (оба тогла должны быть включены и кейбинд активен)
    o.common_vars.shouldShowClone = Library.Flags["desync_vis"] and o.common_vars.isActive

    -- Управление клоном в зависимости от статуса визуализации и десинка
    if o.common_vars.shouldShowClone and not o.common_vars.clonedChar then
        self:CloneCharacter()
        o.common_vars.clonedChar = self.ClonedCharacter
    elseif not o.common_vars.shouldShowClone and o.common_vars.clonedChar then
        self:DestroyClonedCharacter()
        o.common_vars.clonedChar = nil
    end

    -- Если десинк не активен
    if not o.common_vars.isActive then
        o.common_vars.positions.Old = nil
        o.common_vars.positions.New = nil
        return
    end

    -- Проверяем, что HRP все еще существует (мог быть удален между проверками)
    if not o.common_vars.hrp or not o.common_vars.hrp:IsDescendantOf(game) then
        return
    end

    -- Запоминаем исходную позицию
    o.common_vars.positions.Old = o.common_vars.hrp.CFrame

    -- Применяем десинхронизацию
    if self.Overwriten then
        o.common_vars.hrp.CFrame = o.funcs.cf(self.Overwriten.X, self.Overwriten.Y, self.Overwriten.Z)
    else
        o.common_vars.desyncFactor = o.funcs.cf(
            self:GetValue("x"),
            self:GetValue("y"),
            self:GetValue("z")
        )

        o.common_vars.desyncFactor = o.common_vars.desyncFactor * CFrame.Angles(
            math.rad(self:GetValue("pitch")),
            math.rad(self:GetValue("yaw")),
            math.rad(self:GetValue("roll"))
        )

        -- Проверяем, что HRP все еще существует перед изменением CFrame
        if o.common_vars.hrp and o.common_vars.hrp:IsDescendantOf(game) then
        o.common_vars.hrp.CFrame = o.common_vars.hrp.CFrame * o.common_vars.desyncFactor
        else
            return
        end
    end

    -- Запоминаем новую позицию
    o.common_vars.positions.New = o.common_vars.hrp.CFrame

    -- Обновляем позицию клона, если он существует
    if o.common_vars.clonedChar and o.common_vars.clonedChar.RootPart then
        -- Устанавливаем позицию клона в позицию десинка
        o.common_vars.clonedChar.RootPart.CFrame = o.common_vars.positions.New
        
        -- Проверяем, что персонаж все еще существует
        if o.lp.Character then
        -- Обновляем все части клона
        for _, part in pairs(o.common_vars.clonedChar.Character:GetDescendants()) do
            if part:IsA("BasePart") and part ~= o.common_vars.clonedChar.RootPart then
                -- Получаем относительное положение части в оригинальном персонаже
                o.common_vars.originalPart = o.lp.Character:FindFirstChild(part.Name)
                    if o.common_vars.originalPart and o.common_vars.originalPart:IsA("BasePart") and o.common_vars.hrp then
                    -- Вычисляем относительное положение к корню
                    o.common_vars.relativeOffset = o.common_vars.hrp.CFrame:ToObjectSpace(o.common_vars.originalPart.CFrame)
                    -- Применяем это же относительное положение к клону
                    part.CFrame = o.common_vars.positions.New:ToWorldSpace(o.common_vars.relativeOffset)
                    end
                end
            end
        end
    end

    -- Ждем кадр и возвращаем персонажа в исходную позицию
    o.rs.RenderStepped:Wait()
    
    -- Проверяем, что HRP все еще существует перед возвратом к исходной позиции
    if o.common_vars.hrp and o.common_vars.hrp:IsDescendantOf(game) and o.common_vars.positions.Old then
    o.common_vars.hrp.CFrame = o.common_vars.positions.Old
    end
end

-- Создаем соединение для обновления десинка
if o.desyncConnection then
    o.desyncConnection:Disconnect()
    o.desyncConnection = nil
end

o.desyncConnection = o.rs.Heartbeat:Connect(function()
    o.Desync:Think()
end)

-- Хук для обработки десинхронизации
-- Примечание: hookmetamethod и checkcaller - это функции API эксплойта, не стандартные в Lua/Luau
o.OldIndex = nil

-- Определяем hookmetamethod и checkcaller, если они не существуют
if not _G.hookmetamethod_defined then
    _G.hookmetamethod_defined = true
    if not hookmetamethod then
        hookmetamethod = function(obj, metamethod, hook)
            -- Заглушка для hookmetamethod
            o.common_vars.original = obj[metamethod]
            obj[metamethod] = hook
            return o.common_vars.original
        end
    end
    
    if not checkcaller then
        checkcaller = function()
            -- Заглушка для checkcaller
            return false
        end
    end
end

if not hookmetamethod then
    o.OldIndex = function(self, prop)
        if prop == "CFrame" then
            if o.Desync:Active() and Library.Flags["desync_hook"] and self == o.getHrp() then
                o.common_vars.oldPosition = o.Desync:GetPositions()

                if o.common_vars.oldPosition then
                    return o.common_vars.oldPosition
                end
            end
        end
        
        return self[prop]
    end
else
    o.OldIndex = hookmetamethod(game, "__index", function(self, prop)
        if not checkcaller() then
            if prop == "CFrame" then
                if o.Desync:Active() and Library.Flags["desync_hook"] and self == o.getHrp() then
                    o.common_vars.oldPosition = o.Desync:GetPositions()

                    if o.common_vars.oldPosition then
                        return o.common_vars.oldPosition
                    end
                end
            end
        end

        return o.OldIndex(self, prop)
    end)
end

-- Добавляем тогл Enabled для десинка с кейбиндом
o.DesyncToggle = PlayerDesyncSection:Toggle({
    name = "Enabled",
    default = false,
    flag = "desync",
    callback = function(value)
        if not value then
            o.Desync:SetStatus(nil)
            o.Desync:RemoveOverwrite()
            
            -- Проверяем, нужно ли скрыть клон
            if o.Desync.ClonedCharacter and Library.Flags["desync_vis"] then
                -- Если Visualize включен, но Enabled выключен, удаляем клон
                o.Desync:DestroyClonedCharacter()
            end
        else
            -- Если включили Enabled и Visualize тоже включен, создаем клон
            if Library.Flags["desync_vis"] and not o.Desync.ClonedCharacter then
                o.Desync:CloneCharacter()
            end
        end
    end
})

-- Добавляем кейбинд для активации десинка
o.DesyncToggle:Keybind({
    flag = "desync_key",
    callback = function(key)
        -- Проверяем состояние кейбинда и тогла визуализации
        o.common_vars.isDesyncActive = Library.Flags["desync"] and Library.Flags["desync_key"]
        o.common_vars.shouldShowClone = o.common_vars.isDesyncActive and Library.Flags["desync_vis"]
        
        -- Управляем видимостью клона в зависимости от состояния десинка
        if o.common_vars.shouldShowClone and not o.Desync.ClonedCharacter then
            o.Desync:CloneCharacter()
        elseif not o.common_vars.shouldShowClone and o.Desync.ClonedCharacter then
            o.Desync:DestroyClonedCharacter()
        end
    end
})

-- Добавляем тогл Use Hook для десинка
PlayerDesyncSection:Toggle({
    name = "Use Hook",
    default = false,
    flag = "desync_hook"
})

-- Добавляем тогл X Position с попапом
o.XPositionToggle = PlayerDesyncSection:Toggle({
    name = "X Position",
    default = false,
    flag = "desync_x"
})

-- Создаем один попап для X Position
o.XPositionPopup = o.XPositionToggle:Popup({size = 150})

-- Добавляем выпадающий список для режима X Position
o.XPositionPopup:Dropdown({
    name = "Mode",
    values = {"Static", "Lerp", "Random"},
    value = "Static",
    flag = "desync_mode_x"
})

-- Добавляем текстбокс для значения X Position
o.XPositionPopup:Textbox({
    name = "Static Value",
    description = "Position offset in studs",
    placeholder = "0",
    default = "0",
    flag = "desync_val_x_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_val_x"] = o.common_vars.value
        end
    end
})

-- Добавляем текстбоксы для мин/макс значений X Position
o.XPositionPopup:Textbox({
    name = "Minimum",
    description = "Minimum position offset",
    placeholder = "-5",
    default = "-5",
    flag = "desync_min_x_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_min_x"] = o.common_vars.value
        end
    end
})

o.XPositionPopup:Textbox({
    name = "Maximum",
    description = "Maximum position offset",
    placeholder = "5",
    default = "5",
    flag = "desync_max_x_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_max_x"] = o.common_vars.value
        end
    end
})

-- Добавляем текстбокс для скорости Lerp X Position
o.XPositionPopup:Textbox({
    name = "Lerp Speed",
    description = "Animation speed for Lerp mode",
    placeholder = "1",
    default = "1",
    flag = "desync_speed_x_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_speed_x"] = o.common_vars.value
        end
    end
})

-- Добавляем тогл Y Position с попапом
o.YPositionToggle = PlayerDesyncSection:Toggle({
    name = "Y Position",
    default = false,
    flag = "desync_y"
})

-- Создаем один попап для Y Position
o.YPositionPopup = o.YPositionToggle:Popup({size = 150})

-- Добавляем выпадающий список для режима Y Position
o.YPositionPopup:Dropdown({
    name = "Mode",
    values = {"Static", "Lerp", "Random"},
    value = "Static",
    flag = "desync_mode_y"
})

-- Добавляем текстбокс для значения Y Position
o.YPositionPopup:Textbox({
    name = "Static Value",
    description = "Vertical offset in studs",
    placeholder = "0",
    default = "0",
    flag = "desync_val_y_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_val_y"] = o.common_vars.value
        end
    end
})

-- Добавляем текстбоксы для мин/макс значений Y Position
o.YPositionPopup:Textbox({
    name = "Minimum",
    description = "Minimum vertical offset",
    placeholder = "-5",
    default = "-5",
    flag = "desync_min_y_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_min_y"] = o.common_vars.value
        end
    end
})

o.YPositionPopup:Textbox({
    name = "Maximum",
    description = "Maximum vertical offset",
    placeholder = "5",
    default = "5",
    flag = "desync_max_y_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_max_y"] = o.common_vars.value
        end
    end
})

-- Добавляем текстбокс для скорости Lerp Y Position
o.YPositionPopup:Textbox({
    name = "Lerp Speed",
    description = "Animation speed for Lerp mode",
    placeholder = "1",
    default = "1",
    flag = "desync_speed_y_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_speed_y"] = o.common_vars.value
        end
    end
})

-- Добавляем тогл Z Position с попапом
o.ZPositionToggle = PlayerDesyncSection:Toggle({
    name = "Z Position",
    default = false,
    flag = "desync_z"
})

-- Создаем один попап для Z Position
o.ZPositionPopup = o.ZPositionToggle:Popup({size = 150})

-- Добавляем выпадающий список для режима Z Position
o.ZPositionPopup:Dropdown({
    name = "Mode",
    values = {"Static", "Lerp", "Random"},
    value = "Static",
    flag = "desync_mode_z"
})

-- Добавляем текстбокс для значения Z Position
o.ZPositionPopup:Textbox({
    name = "Static Value",
    description = "Forward/back offset in studs",
    placeholder = "0",
    default = "0",
    flag = "desync_val_z_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_val_z"] = o.common_vars.value
        end
    end
})

-- Добавляем текстбоксы для мин/макс значений Z Position
o.ZPositionPopup:Textbox({
    name = "Minimum",
    description = "Minimum forward/back offset",
    placeholder = "-5",
    default = "-5",
    flag = "desync_min_z_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_min_z"] = o.common_vars.value
        end
    end
})

o.ZPositionPopup:Textbox({
    name = "Maximum",
    description = "Maximum forward/back offset",
    placeholder = "5",
    default = "5",
    flag = "desync_max_z_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_max_z"] = o.common_vars.value
        end
    end
})

-- Добавляем текстбокс для скорости Lerp Z Position
o.ZPositionPopup:Textbox({
    name = "Lerp Speed",
    description = "Animation speed for Lerp mode",
    placeholder = "1",
    default = "1",
    flag = "desync_speed_z_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_speed_z"] = o.common_vars.value
        end
    end
})

-- Добавляем тогл Pitch Position с попапом
o.PitchPositionToggle = PlayerDesyncSection:Toggle({
    name = "Pitch Position",
    default = false,
    flag = "desync_pitch"
})

-- Создаем один попап для Pitch Position
o.PitchPositionPopup = o.PitchPositionToggle:Popup({size = 150})

-- Добавляем выпадающий список для режима Pitch Position
o.PitchPositionPopup:Dropdown({
    name = "Mode",
    values = {"Static", "Lerp", "Random"},
    value = "Static",
    flag = "desync_mode_pitch"
})

-- Добавляем текстбокс для значения Pitch Position
o.PitchPositionPopup:Textbox({
    name = "Static Value",
    description = "Up/down rotation in degrees",
    placeholder = "0",
    default = "0",
    flag = "desync_val_pitch_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_val_pitch"] = o.common_vars.value
        end
    end
})

-- Добавляем текстбоксы для мин/макс значений Pitch Position
o.PitchPositionPopup:Textbox({
    name = "Minimum",
    description = "Minimum pitch angle",
    placeholder = "-90",
    default = "-90",
    flag = "desync_min_pitch_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_min_pitch"] = o.common_vars.value
        end
    end
})

o.PitchPositionPopup:Textbox({
    name = "Maximum",
    description = "Maximum pitch angle",
    placeholder = "90",
    default = "90",
    flag = "desync_max_pitch_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_max_pitch"] = o.common_vars.value
        end
    end
})

-- Добавляем текстбокс для скорости Lerp Pitch Position
o.PitchPositionPopup:Textbox({
    name = "Lerp Speed",
    description = "Animation speed for Lerp mode",
    placeholder = "1",
    default = "1",
    flag = "desync_speed_pitch_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_speed_pitch"] = o.common_vars.value
        end
    end
})

-- Добавляем тогл Yaw Position с попапом
o.YawPositionToggle = PlayerDesyncSection:Toggle({
    name = "Yaw Position",
    default = false,
    flag = "desync_yaw"
})

-- Создаем один попап для Yaw Position
o.YawPositionPopup = o.YawPositionToggle:Popup({size = 150})

-- Добавляем выпадающий список для режима Yaw Position
o.YawPositionPopup:Dropdown({
    name = "Mode",
    values = {"Static", "Lerp", "Random"},
    value = "Static",
    flag = "desync_mode_yaw"
})

-- Добавляем текстбокс для значения Yaw Position
o.YawPositionPopup:Textbox({
    name = "Static Value",
    description = "Left/right rotation in degrees",
    placeholder = "0",
    default = "0",
    flag = "desync_val_yaw_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_val_yaw"] = o.common_vars.value
        end
    end
})

-- Добавляем текстбоксы для мин/макс значений Yaw Position
o.YawPositionPopup:Textbox({
    name = "Minimum",
    description = "Minimum yaw angle",
    placeholder = "-90",
    default = "-90",
    flag = "desync_min_yaw_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_min_yaw"] = o.common_vars.value
        end
    end
})

o.YawPositionPopup:Textbox({
    name = "Maximum",
    description = "Maximum yaw angle",
    placeholder = "90",
    default = "90",
    flag = "desync_max_yaw_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_max_yaw"] = o.common_vars.value
        end
    end
})

-- Добавляем текстбокс для скорости Lerp Yaw Position
o.YawPositionPopup:Textbox({
    name = "Lerp Speed",
    description = "Animation speed for Lerp mode",
    placeholder = "1",
    default = "1",
    flag = "desync_speed_yaw_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_speed_yaw"] = o.common_vars.value
        end
    end
})

-- Добавляем тогл Roll Position с попапом
o.RollPositionToggle = PlayerDesyncSection:Toggle({
    name = "Roll Position",
    default = false,
    flag = "desync_roll"
})

-- Создаем один попап для Roll Position
o.RollPositionPopup = o.RollPositionToggle:Popup({size = 150})

-- Добавляем выпадающий список для режима Roll Position
o.RollPositionPopup:Dropdown({
    name = "Mode",
    values = {"Static", "Lerp", "Random"},
    value = "Static",
    flag = "desync_mode_roll"
})

-- Добавляем текстбокс для значения Roll Position
o.RollPositionPopup:Textbox({
    name = "Static Value",
    description = "Tilt rotation in degrees",
    placeholder = "0",
    default = "0",
    flag = "desync_val_roll_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_val_roll"] = o.common_vars.value
        end
    end
})

-- Добавляем текстбоксы для мин/макс значений Roll Position
o.RollPositionPopup:Textbox({
    name = "Minimum",
    description = "Minimum roll angle",
    placeholder = "-90",
    default = "-90",
    flag = "desync_min_roll_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_min_roll"] = o.common_vars.value
        end
    end
})

o.RollPositionPopup:Textbox({
    name = "Maximum",
    description = "Maximum roll angle",
    placeholder = "90",
    default = "90",
    flag = "desync_max_roll_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_max_roll"] = o.common_vars.value
        end
    end
})

-- Добавляем текстбокс для скорости Lerp Roll Position
o.RollPositionPopup:Textbox({
    name = "Lerp Speed",
    description = "Animation speed for Lerp mode",
    placeholder = "1",
    default = "1",
    flag = "desync_speed_roll_text",
    callback = function(text)
        o.common_vars.value = tonumber(text)
        if o.common_vars.value then
            Library.Flags["desync_speed_roll"] = o.common_vars.value
        end
    end
})

-- Добавляем тогл Void с кейбиндом
o.VoidToggle = PlayerDesyncSection:Toggle({
    name = "Void",
    default = false,
    flag = "desync_void",
    callback = function(value)
        if value and Library.Flags["desync_void_key"] then
            o.Desync:SetStatus(true)
            o.Desync:OverwritePosition(o.funcs.v3(9e9, -9e9, 9e9))
            
            -- Обновляем клон, если включена визуализация
            if Library.Flags["desync_vis"] and not o.Desync.ClonedCharacter then
                o.Desync:CloneCharacter()
            end
        else
            o.Desync:SetStatus(nil)
            o.Desync:RemoveOverwrite()
            
            -- Проверяем, нужно ли скрыть клон
            o.common_vars.isDesyncActive = Library.Flags["desync"] and Library.Flags["desync_key"]
            if not o.common_vars.isDesyncActive and o.Desync.ClonedCharacter then
                o.Desync:DestroyClonedCharacter()
            end
        end
    end
})

-- Добавляем кейбинд для Void
o.VoidToggle:Keybind({
    flag = "desync_void_key",
    callback = function(key)
        if key and Library.Flags["desync_void"] then
            o.Desync:SetStatus(true)
            o.Desync:OverwritePosition(o.funcs.v3(9e9, -9e9, 9e9))
        else
            o.Desync:SetStatus(nil)
            o.Desync:RemoveOverwrite()
        end
    end
})

-- Добавляем тогл Visualize с колорпикером
o.VisualizeToggle = PlayerDesyncSection:Toggle({
    name = "Visualize",
    default = false,
    flag = "desync_vis",
    callback = function(value)
        -- Проверяем, должен ли быть виден клон (оба тогла должны быть включены)
        o.common_vars.shouldShowClone = value and Library.Flags["desync"]
        
        if o.common_vars.shouldShowClone then
            -- Принудительно создаем клон при включении обоих тоглов
            if not o.Desync.ClonedCharacter then
                o.Desync:CloneCharacter()
            end
        else
            -- Принудительно удаляем клон при выключении любого из тоглов
            if o.Desync.ClonedCharacter then
                o.Desync:DestroyClonedCharacter()
            end
        end
    end
})

-- Создаем один попап для Visualize
o.VisualizePopup = o.VisualizeToggle:Popup({size = 150})

-- Добавляем колорпикер для цвета визуализации
o.VisualizePopup:Colorpicker({
    name = "Color",
    default = o.funcs.rgb(255, 0, 0),
    flag = "desync_vis_color",
    callback = function(color)
        -- Обновляем внешний вид клона при изменении цвета
        if o.Desync.ClonedCharacter then
            o.Desync:UpdateCharacter()
        end
    end
})

-- Добавляем выпадающий список для материала визуализации
o.VisualizePopup:Dropdown({
    name = "Material",
    values = {"ForceField", "Neon", "SmoothPlastic", "Glass"},
    value = "ForceField",
    flag = "desync_vis_material",
    callback = function(material)
        -- Обновляем внешний вид клона при изменении материала
        if o.Desync.ClonedCharacter then
            o.Desync:UpdateCharacter()
        end
    end
})

-- Конфигурация SpeedHack
o.SpeedhackConfig = {
    Enabled = false,
    Active = false,
    Speed = 50
}

-- Конфигурация Fly
o.FlyConfig = {
    Enabled = false,
    Active = false,
    UseCamera = false,     -- Режим следования за направлением камеры
    Speed = 1,             -- Базовая скорость
    SpeedMultiplier = 5,   -- Общий множитель скорости
    VerticalSpeedMultiplier = 0.3, -- Множитель для вертикального движения
    UpKey = nil,           -- Клавиша для движения вверх (по умолчанию не назначена)
    DownKey = nil          -- Клавиша для движения вниз (по умолчанию не назначена)
}

-- Функция для включения/выключения коллизий у персонажа
function setNoClip(character, state)
    if not character then return end
    
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA('BasePart') then
            if state then
                -- Сохраняем оригинальные значения
                if not part:GetAttribute('OriginalCollision') then
                    part:SetAttribute('OriginalCollision', part.CanCollide)
                    part:SetAttribute('OriginalTouch', part.CanTouch)
                    if part:GetAttribute('CanQuery') ~= nil then
                        part:SetAttribute('OriginalQuery', part.CanQuery)
                    end
                end
                -- Отключаем коллизии
                part.CanCollide = false
                part.CanTouch = false
                part.CanQuery = false
            else
                -- Восстанавливаем оригинальные значения
                if part:GetAttribute('OriginalCollision') ~= nil then
                    part.CanCollide = part:GetAttribute('OriginalCollision')
                    part.CanTouch = part:GetAttribute('OriginalTouch')
                    if part:GetAttribute('OriginalQuery') ~= nil then
                        part.CanQuery = part:GetAttribute('OriginalQuery')
                    end
                    -- Очищаем атрибуты
                    part:SetAttribute('OriginalCollision', nil)
                    part:SetAttribute('OriginalTouch', nil)
                    part:SetAttribute('OriginalQuery', nil)
                end
            end
        end
    end
end

-- Основная функция полета
function updateFly(character)
    if o.FlyLoop then
        o.FlyLoop:Disconnect()
        o.FlyLoop = nil
    end
    
    if not character or not (o.FlyConfig.Enabled and o.FlyConfig.Active) then 
        return 
    end
    
    -- Включаем NoClip
    setNoClip(character, true)
    
    -- Создаем основной цикл полета
    o.FlyLoop = o.rs.Stepped:Connect(function()
        o.common_vars.char = o.lp.Character
        if not o.common_vars.char then return end
        
        o.common_vars.hrp = o.common_vars.char:FindFirstChild(o.r15.root)
        o.common_vars.hum = o.common_vars.char:FindFirstChild('Humanoid')
        if not o.common_vars.hrp or not o.common_vars.hrp:IsDescendantOf(game) or not o.common_vars.hum then return end
        
        -- Рассчитываем скорость с учетом множителей
        o.common_vars.baseSpeed = o.FlyConfig.Speed * o.FlyConfig.SpeedMultiplier
        o.common_vars.verticalSpeed = o.common_vars.baseSpeed * o.FlyConfig.VerticalSpeedMultiplier
        o.common_vars.velocity = o.funcs.v3(0, 0, 0)
        
        o.common_vars.camCF = o.camera.CFrame
        o.common_vars.moveDir = o.funcs.v3()
        
        -- Обработка горизонтального движения (всегда с учетом направления камеры)
        if o.uis:IsKeyDown(Enum.KeyCode.W) then
            o.common_vars.moveDir = o.common_vars.moveDir + o.funcs.v3(o.common_vars.camCF.LookVector.X, 0, o.common_vars.camCF.LookVector.Z).Unit -- Вперед (только XZ)
        end
        if o.uis:IsKeyDown(Enum.KeyCode.A) then
            o.common_vars.moveDir = o.common_vars.moveDir - o.funcs.v3(o.common_vars.camCF.RightVector.X, 0, o.common_vars.camCF.RightVector.Z).Unit -- Влево (только XZ)
        end
        if o.uis:IsKeyDown(Enum.KeyCode.S) then
            o.common_vars.moveDir = o.common_vars.moveDir - o.funcs.v3(o.common_vars.camCF.LookVector.X, 0, o.common_vars.camCF.LookVector.Z).Unit -- Назад (только XZ)
        end
        if o.uis:IsKeyDown(Enum.KeyCode.D) then
            o.common_vars.moveDir = o.common_vars.moveDir + o.funcs.v3(o.common_vars.camCF.RightVector.X, 0, o.common_vars.camCF.RightVector.Z).Unit -- Вправо (только XZ)
        end
        
        -- Нормализация и применение скорости к горизонтальному движению
        if o.common_vars.moveDir.Magnitude > 0 then
            o.common_vars.moveDir = o.common_vars.moveDir.Unit * o.common_vars.baseSpeed
            o.common_vars.velocity = o.funcs.v3(o.common_vars.moveDir.X, o.common_vars.velocity.Y, o.common_vars.moveDir.Z)
        end
        
        -- Обработка вертикального движения в зависимости от режима
        if o.FlyConfig.UseCamera then
            -- Режим с учетом направления камеры
            if o.uis:IsKeyDown(Enum.KeyCode.W) then
                o.common_vars.velocity = o.common_vars.velocity + o.funcs.v3(0, o.common_vars.camCF.LookVector.Y * o.common_vars.baseSpeed, 0) -- Вертикальное движение по направлению камеры
            end
            if o.uis:IsKeyDown(Enum.KeyCode.S) then
                o.common_vars.velocity = o.common_vars.velocity - o.funcs.v3(0, o.common_vars.camCF.LookVector.Y * o.common_vars.baseSpeed, 0) -- Вертикальное движение по направлению камеры
            end
        end
        
        -- Дополнительные кнопки для вертикального движения (работают в обоих режимах)
        if o.FlyConfig.UpKey and o.uis:IsKeyDown(o.FlyConfig.UpKey) then
            o.common_vars.velocity = o.common_vars.velocity + o.funcs.v3(0, o.common_vars.verticalSpeed, 0) -- Вверх
        end
        if o.FlyConfig.DownKey and o.uis:IsKeyDown(o.FlyConfig.DownKey) then
            o.common_vars.velocity = o.common_vars.velocity - o.funcs.v3(0, o.common_vars.verticalSpeed, 0) -- Вниз
        end
        
        -- Применяем скорость безопасно с использованием pcall
        pcall(function()
            if o.common_vars.hrp and o.common_vars.hrp:IsDescendantOf(game) then
        o.common_vars.hrp.Velocity = o.common_vars.velocity
        o.common_vars.hum:ChangeState('Freefall')
            end
        end)
    end)
end

-- Останавливает полет
function stopFly()
    if o.FlyLoop then
        o.FlyLoop:Disconnect()
        o.FlyLoop = nil
    end
    
    o.common_vars.char = o.lp.Character
    setNoClip(o.common_vars.char, false)
    
    if o.common_vars.char then
        o.common_vars.hrp = o.common_vars.char:FindFirstChild(o.r15.root)
        o.common_vars.hum = o.common_vars.char:FindFirstChild('Humanoid')
        
        -- Плавное падение при выключении
        if o.common_vars.hrp and o.common_vars.hrp:IsDescendantOf(game) then
            pcall(function()
            o.common_vars.hrp.Velocity = o.funcs.v3(0, -2, 0)
            end)
            
            o.common_vars.tempConn = o.rs.Stepped:Connect(function()
                if not o.common_vars.hrp or not o.common_vars.hrp:IsDescendantOf(game) then
                    if o.common_vars.tempConn then
                    o.common_vars.tempConn:Disconnect()
                    end
                    return
                end
                
                pcall(function()
                o.common_vars.hrp.Velocity = o.funcs.v3(0, o.common_vars.hrp.Velocity.Y, 0)
                end)
                
                if o.common_vars.tempConn then
                o.common_vars.tempConn:Disconnect()
                end
            end)
        end
        
        if o.common_vars.hum and o.common_vars.hum:IsDescendantOf(game) then
            pcall(function()
            o.common_vars.hum:ChangeState('Landing')
            end)
        end
    end
end

-- Функция обновления SpeedHack
function updateSpeedHack(character)
    if not character then return end
    
    -- Используем функции из таблицы оптимизации для получения частей персонажа
    local success, rootPart, humanoid
    
    success = pcall(function()
        rootPart = character:WaitForChild(o.r15.root, 1)
        humanoid = character:WaitForChild('Humanoid', 1)
    end)
    
    if not success or not rootPart or not humanoid then
        return
    end
    
    -- Сохраняем ссылки в common_vars
    o.common_vars.rootPart = rootPart
    o.common_vars.humanoid = humanoid
    
    -- Отключаем предыдущее соединение, если оно существует
    if o.speedHackConnection then
        o.speedHackConnection:Disconnect()
    end
    
    -- Создаем новое соединение с Heartbeat, используя o.rs из таблицы оптимизации
    o.speedHackConnection = o.rs.Heartbeat:Connect(function(dt)
        if o.SpeedhackConfig.Enabled and o.SpeedhackConfig.Active then
            -- Проверяем, что rootPart и humanoid все еще существуют
            if not rootPart or not rootPart:IsDescendantOf(game) or not humanoid or not humanoid:IsDescendantOf(game) then
                return
            end
            
            -- Получаем направление движения
            o.common_vars.move = humanoid.MoveDirection
            
            if o.common_vars.move.Magnitude > 0 then
                -- Безопасно изменяем позицию с использованием pcall
                pcall(function()
                -- Используем функцию из таблицы оптимизации для создания CFrame
                    o.common_vars.newPos = rootPart.Position + (o.common_vars.move.Unit * o.SpeedhackConfig.Speed * dt)
                    rootPart.CFrame = o.funcs.cf(o.common_vars.newPos.X, o.common_vars.newPos.Y, o.common_vars.newPos.Z) * 
                        CFrame.Angles(0, math.atan2(-o.common_vars.move.X, -o.common_vars.move.Z), 0)
                end)
            end
        end
    end)
end

-- Добавляем тогл SpeedHack с попапом
o.SpeedHackToggle = PlayerMovementSection:Toggle({
    name = "Speed Hack",
    default = false,
    flag = "player_speedhack",
    callback = function(value)
        o.SpeedhackConfig.Enabled = value
        
        -- Обновляем SpeedHack при включении/выключении
        if value then
            if o.lp.Character then
                updateSpeedHack(o.lp.Character)
                -- Добавляем уведомление при включении
                Library.Notification({Name = "Speedhack", Description = "Press keybind to activate"})
            end
        else
            -- Отключаем соединение при выключении
            if o.speedHackConnection then
                o.speedHackConnection:Disconnect()
                o.speedHackConnection = nil
            end
            -- Сбрасываем флаг активности
            o.SpeedhackConfig.Active = false
        end
    end
})

-- Создаем один попап для настроек SpeedHack
o.SpeedHackPopup = o.SpeedHackToggle:Popup({size = 150})

-- Добавляем кейбинд в попап для SpeedHack
o.SpeedHackPopup:Keybind({
    name = "Activation Key",
    flag = "speedhack_key",
    callback = function()
        -- Переключаем активность SpeedHack только если включен тогл
        if o.SpeedhackConfig.Enabled then
            o.SpeedhackConfig.Active = not o.SpeedhackConfig.Active
            
            -- Показываем уведомление о текущем состоянии
            o.common_vars.status = o.SpeedhackConfig.Active and "on" or "off"
            Library.Notification({Name = "Speedhack", Description = o.common_vars.status})
        end
    end
})

-- Добавляем текстбокс для настройки скорости в попап
o.SpeedHackPopup:Textbox({
    name = "Speed",
    placeholder = "50",
    default = "50",
    flag = "speedhack_speed_text",
    callback = function(text)
        -- Преобразуем текст в число
        o.common_vars.speed = tonumber(text)
        
        -- Проверяем, что введено число
        if o.common_vars.speed then
            o.SpeedhackConfig.Speed = o.common_vars.speed
        end
    end
})

-- Добавляем тогл Fly с попапом
o.FlyToggle = PlayerMovementSection:Toggle({
    name = "Fly Hack",
    default = false,
    flag = "player_fly",
    callback = function(value)
        o.FlyConfig.Enabled = value
        
        if value then
            if o.lp.Character then
                -- Не активируем полет автоматически, только включаем возможность
                Library.Notification({Name = "Fly", Description = "Press keybind to activate"})
            end
        else
            -- При выключении тогла останавливаем полет
            o.FlyConfig.Active = false
            stopFly()
        end
    end
})

-- Создаем один попап для настроек Fly
o.FlyPopup = o.FlyToggle:Popup({size = 150})

-- Добавляем кейбинд для активации в попап для Fly
o.FlyPopup:Keybind({
    name = "Activation Key",
    flag = "fly_key",
    callback = function()
        -- Переключаем активность Fly только если включен тогл
        if o.FlyConfig.Enabled then
            o.FlyConfig.Active = not o.FlyConfig.Active
            
            -- Показываем уведомление о текущем состоянии
            o.common_vars.status = o.FlyConfig.Active and "on" or "off"
            Library.Notification({Name = "Fly", Description = o.common_vars.status})
            
            -- Обновляем состояние полета
            if o.FlyConfig.Active then
                updateFly(o.lp.Character)
            else
                stopFly()
            end
        end
    end
})

-- Добавляем тогл UseCamera в попап
o.FlyPopup:Toggle({
    name = "UseCamera",
    default = false,
    flag = "fly_usecamera",
    callback = function(value)
        o.FlyConfig.UseCamera = value
    end
})

-- Добавляем кейбинд для движения вверх
o.FlyPopup:Keybind({
    name = "Up Key",
    flag = "fly_up_key",
    callback = function(key)
        -- Сохраняем ключ в конфигурации
        o.FlyConfig.UpKey = key == Enum.KeyCode.Unknown and nil or key
    end
})

-- Добавляем кейбинд для движения вниз
o.FlyPopup:Keybind({
    name = "Down Key",
    flag = "fly_down_key",
    callback = function(key)
        -- Сохраняем ключ в конфигурации
        o.FlyConfig.DownKey = key == Enum.KeyCode.Unknown and nil or key
    end
})

-- Добавляем текстбокс для настройки множителя скорости
o.FlyPopup:Textbox({
    name = "Speed",
    placeholder = "5",
    default = "5",
    flag = "fly_speed_text",
    callback = function(text)
        -- Преобразуем текст в число
        o.common_vars.speed = tonumber(text)
        
        -- Проверяем, что введено число
        if o.common_vars.speed then
            o.FlyConfig.SpeedMultiplier = o.common_vars.speed
        end
    end
})

-- Подключение к событию изменения персонажа
o.lp.CharacterAdded:Connect(function(char)
    if o.SpeedhackConfig.Enabled then
        updateSpeedHack(char)
    end
    
    -- Также проверяем Fly
    if o.FlyConfig.Enabled and o.FlyConfig.Active then
        updateFly(char)
    end
end)

-- Конфигурации
o.ConfigSection = ConfigTab:Section({name = "Configurations", description = ">_<"})
o.ConfigFolder = "BrandNew/Games/Universal/Configs"

-- Создание папок для конфигураций
pcall(function()
    if not isfolder("BrandNew") then
        makefolder("BrandNew")
    end
    
    if not isfolder("BrandNew/Games") then
        makefolder("BrandNew/Games")
    end
    
    if not isfolder("BrandNew/Games/Universal") then
        makefolder("BrandNew/Games/Universal")
    end
    
    if not isfolder(o.ConfigFolder) then
        makefolder(o.ConfigFolder)
    end
end)

-- Функция получения файлов конфигурации
function GetConfigFiles()
    local files = {}
    
    pcall(function()
        if isfolder(o.ConfigFolder) then
            local fileList = listfiles(o.ConfigFolder)
            for _, file in ipairs(fileList) do
                if type(file) == "string" and file:sub(-5) == ".json" then
                    local configName = file:match("([^/\\]+)%.json$")
                    if configName and type(configName) == "string" then
                        table.insert(files, configName)
                    end
                end
            end
        end
    end)
    
    -- Если нет файлов, добавляем значение по умолчанию
    if #files == 0 then
        table.insert(files, "default")
    end
    
    return files
end

-- Поле ввода имени конфига
o.ConfigName = o.ConfigSection:Textbox({
    name = "Config Name",
    placeholder = "Enter config name...",
    default = "default",
    flag = "config_name"
})

-- Список конфигов
o.ConfigList = o.ConfigSection:List({
    name = "Configs",
    values = GetConfigFiles(),
    value = GetConfigFiles()[1] or "default",
    size = 200,
    flag = "config_list",
    callback = function(value)
        if value and type(value) == "string" then
            Library.Flags["config_name"] = value
            if o.ConfigName and o.ConfigName.Set then
                pcall(function()
                    o.ConfigName:Set(value)
                end)
            end
        end
    end
})

-- Функция для обновления списка конфигов с нуля
function RefreshConfigList()
    local configFiles = GetConfigFiles()
    
    -- Создаем новый список конфигов
    if o.ConfigList and o.ConfigList.Objects and o.ConfigList.Objects.Content then
        -- Очищаем существующие элементы
        for _, child in pairs(o.ConfigList.Objects.Content:GetChildren()) do
            if child:IsA("TextButton") then
                child:Destroy()
            end
        end
        
        -- Сбрасываем список элементов
        o.ConfigList.Items = {}
        
        -- Добавляем новые элементы
        for _, itemName in ipairs(configFiles) do
            if type(itemName) == "string" then
                o.ConfigList.Add(itemName)
            end
        end
    end
end

-- Функция для безопасного сохранения конфига (без циклических ссылок)
function SafeGetConfig()
    -- Создаем копию флагов без циклических ссылок
    local safeFlags = {}
    
    -- Обрабатываем каждый флаг отдельно
    for flag, value in pairs(Library.Flags) do
        -- Пропускаем функции, userdata, thread и nil
        if type(value) == "nil" or type(value) == "function" or type(value) == "userdata" or type(value) == "thread" then
            -- Пропускаем
        
        -- Обработка булевых значений (тогглы)
        elseif type(value) == "boolean" then
            safeFlags[flag] = value
            
        -- Обработка чисел
        elseif type(value) == "number" then
            safeFlags[flag] = value
            
        -- Обработка строк
        elseif type(value) == "string" then
            safeFlags[flag] = value
            
        -- Обработка таблиц (цвета, кейбинды и т.д.)
        elseif type(value) == "table" then
            -- Проверяем, является ли это цветом
            if value.r and value.g and value.b then
                safeFlags[flag] = {r = value.r, g = value.g, b = value.b}
                if value.a then 
                    safeFlags[flag].a = value.a 
                end
            
            -- Проверяем, является ли это кейбиндом
            elseif value.key or value.mode or value.value ~= nil then
                local keyData = {}
                
                if value.key then
                    -- Сохраняем только имя клавиши, а не объект
                    if typeof(value.key) == "EnumItem" then
                        keyData.key = value.key.Name
                    else
                        keyData.key = tostring(value.key)
                    end
                end
                
                if value.mode then
                    keyData.mode = value.mode
                end
                
                if value.value ~= nil then
                    keyData.value = value.value
                end
                
                safeFlags[flag] = keyData
            
            -- Проверяем, является ли это массивом строк (для списков)
            elseif #value > 0 and type(value[1]) == "string" then
                safeFlags[flag] = value
                
            -- Для других типов таблиц сохраняем только простые значения
            else
                local simpleTable = {}
                for k, v in pairs(value) do
                    if type(v) ~= "function" and type(v) ~= "userdata" and type(v) ~= "thread" and type(v) ~= "table" then
                        simpleTable[k] = v
                    end
                end
                safeFlags[flag] = simpleTable
            end
        end
    end
    
    -- Преобразуем в JSON
    local success, result = pcall(function()
        return game:GetService("HttpService"):JSONEncode(safeFlags)
    end)
    
    if success then
        return result
    else
        -- В случае ошибки возвращаем пустой JSON
        warn("Ошибка при сохранении конфига: " .. tostring(result))
        return "{}"
    end
end

-- Кнопка сохранения
o.ConfigSection:Button({
    name = "Save Config",
    description = "Save current settings",
    callback = function()
        local configName = Library.Flags["config_name"]
        if not configName or configName == "" or type(configName) ~= "string" then
            configName = "default"
        end
        
        if not isfolder(o.ConfigFolder) then
            makefolder(o.ConfigFolder)
        end
        
        local path = o.ConfigFolder.."/"..configName..".json"
        local configData = SafeGetConfig()
        
        pcall(function()
            writefile(path, configData)
            print("Config saved: " .. path)
            
            -- Показываем уведомление
            if Library.Notification then
                Library.Notification({ 
                    name = "Config Saved", 
                    description = "Configuration '" .. configName .. "' has been saved." 
                })
            end
            
            -- Используем нашу новую функцию обновления списка
            pcall(RefreshConfigList)
            
            -- Устанавливаем выбранное значение после обновления
            task.wait(0.1) -- Небольшая задержка для обновления UI
            if o.ConfigList and o.ConfigList.Set and type(configName) == "string" then
                pcall(function()
                    o.ConfigList:Set(configName)
                end)
            end
        end)
    end
})

-- Функция для безопасной загрузки конфига
function SafeLoadConfig(jsonData)
    local success, data = pcall(function()
        return game:GetService("HttpService"):JSONDecode(jsonData)
    end)
    
    if not success then
        warn("Ошибка при декодировании JSON: " .. tostring(data))
        return false
    end
    
    -- Применяем каждый флаг по отдельности
    for flag, value in pairs(data) do
        -- Проверяем, существует ли такой флаг
        if Library.ConfigFlags[flag] then
            pcall(function()
                Library.ConfigFlags[flag](value)
            end)
        end
    end
    
    return true
end

-- Кнопка загрузки
o.ConfigSection:Button({
    name = "Load Config",
    description = "Load selected config",
    callback = function()
        local configName = Library.Flags["config_list"]
        if not configName or configName == "" or type(configName) ~= "string" then
            return
        end
        
        local path = o.ConfigFolder.."/"..configName..".json"
        
        pcall(function()
            if isfile(path) then
                local data = readfile(path)
                -- Безопасная загрузка конфига
                local success = SafeLoadConfig(data)
                if success then
                    print("Config loaded: " .. path)
                end
                
                -- Показываем уведомление
                if success and Library.Notification then
                    Library.Notification({ 
                        name = "Config Loaded", 
                        description = "Configuration '" .. configName .. "' has been loaded." 
                    })
                elseif not success and Library.Notification then
                    Library.Notification({ 
                        name = "Error", 
                        description = "Failed to load configuration '" .. configName .. "'" 
                    })
                end
            else
                print("Config file not found: " .. path)
                
                -- Показываем уведомление об ошибке
                if Library.Notification then
                    Library.Notification({ 
                        name = "Error", 
                        description = "Config file not found: " .. configName 
                    })
                end
                
                -- Используем нашу новую функцию обновления списка
                pcall(RefreshConfigList)
            end
        end)
    end
})

-- Кнопка удаления
o.ConfigSection:Button({
    name = "Delete Config",
    description = "Delete selected config",
    callback = function()
        local configName = Library.Flags["config_list"]
        if not configName or configName == "" or type(configName) ~= "string" then
            return
        end
        
        local path = o.ConfigFolder.."/"..configName..".json"
        
        pcall(function()
            if isfile(path) then
                delfile(path)
                print("Config deleted: " .. path)
                
                -- Показываем уведомление
                if Library.Notification then
                    Library.Notification({ 
                        name = "Config Deleted", 
                        description = "Configuration '" .. configName .. "' has been deleted." 
                    })
                end
            else
                -- Показываем уведомление об ошибке
                if Library.Notification then
                    Library.Notification({ 
                        name = "Error", 
                        description = "Config file not found: " .. configName 
                    })
                end
            end
            
            -- Используем нашу новую функцию обновления списка
            pcall(RefreshConfigList)
            
            -- Выбираем первый конфиг в списке после удаления
            task.wait(0.1) -- Небольшая задержка для обновления UI
            local newConfigFiles = GetConfigFiles()
            if #newConfigFiles > 0 and o.ConfigList and o.ConfigList.Set then
                pcall(function()
                    o.ConfigList:Set(newConfigFiles[1])
                end)
            end
        end)
    end
})

-- Кнопка обновления списка
o.ConfigSection:Button({
    name = "Refresh List",
    description = "Update config list",
    callback = function()
        -- Используем нашу новую функцию обновления списка
        pcall(RefreshConfigList)
        
        -- Показываем уведомление
        if Library.Notification then
            Library.Notification({ 
                name = "Config List", 
                description = "Config list has been refreshed." 
            })
        end
    end
})

-- Дополнительные настройки
ExtraSection = ConfigTab:Section({name = "Extra", description = ">_<", side = "right"})

-- Привязка меню к клавише
ExtraSection:Keybind({
    name = "MenuKeybind", 
    key = Enum.KeyCode.RightControl,
    mode = "Toggle",
    callback = function() Window.Open() end
})

-- Глобальные переменные для ватермарки
o.watermarkEnabled = false
o.watermarkGui = nil
o.watermarkFrame = nil
o.watermarkStrokeColor = Color3.fromRGB(0, 81, 255) -- Цвет по умолчанию
o.drag = {
    dragging = false,
    dragInput = nil,
    dragStart = nil,
    startPos = nil
}

-- Функция создания/обновления ватермарки
function CreateWatermark(enabled)
    -- Удаляем старый ватермарк, если он существует
    if o.watermarkGui then
        o.watermarkGui:Destroy()
        o.watermarkGui = nil
        o.watermarkFrame = nil
    end
    
    -- Если ватермарк отключен, просто выходим
    if not enabled then
        return
    end
    
    -- Создаем ScreenGui
    o.watermarkGui = Instance.new("ScreenGui")
    o.watermarkGui.Name = "BrandNewWatermark"
    o.watermarkGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    o.watermarkGui.Parent = o.lp:WaitForChild("PlayerGui")
    
    -- Создаем элементы UI
    o.watermarkFrame = Instance.new("Frame")
    o.watermarkUICorner = Instance.new("UICorner")
    o.watermarkText = Instance.new("TextLabel")
    o.watermarkTopStroke = Instance.new("Frame")
    
    o.watermarkFrame.Name = "WaterMark"
    o.watermarkFrame.Parent = o.watermarkGui
    o.watermarkFrame.BackgroundColor3 = Color3.fromRGB(26, 25, 25)
    o.watermarkFrame.BorderColor3 = Color3.fromRGB(0, 0, 0)
    o.watermarkFrame.BorderSizePixel = 0
    o.watermarkFrame.Position = UDim2.new(0.09700948, 0, 0.107579462, 0)
    o.watermarkFrame.Size = UDim2.new(0, 300, 0, 25)
    
    o.watermarkUICorner.CornerRadius = UDim.new(0, 3)
    o.watermarkUICorner.Parent = o.watermarkFrame
    
    o.watermarkText.Name = "Text"
    o.watermarkText.Parent = o.watermarkFrame
    o.watermarkText.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    o.watermarkText.BackgroundTransparency = 1.000
    o.watermarkText.BorderColor3 = Color3.fromRGB(0, 0, 0)
    o.watermarkText.BorderSizePixel = 0
    o.watermarkText.Position = UDim2.new(0.0333333351, 0, 0.11, 0)
    o.watermarkText.Size = UDim2.new(0, 280, 1, 0)
    o.watermarkText.Font = Enum.Font.Sarpanch
    o.watermarkText.Text = "BrandNew | skidded | " .. o.lp.Name .. " | " .. o.MS:GetProductInfo(game.PlaceId).Name
    o.watermarkText.TextColor3 = Color3.fromRGB(255, 255, 255)
    o.watermarkText.TextSize = 12
    o.watermarkText.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    o.watermarkText.TextStrokeTransparency = 0.64
    o.watermarkText.TextXAlignment = Enum.TextXAlignment.Left
    o.watermarkText.TextYAlignment = Enum.TextYAlignment.Center
    
    o.watermarkTopStroke.Name = "TopStroke"
    o.watermarkTopStroke.Parent = o.watermarkFrame
    o.watermarkTopStroke.BackgroundColor3 = o.watermarkStrokeColor -- Используем глобальную переменную для цвета
    o.watermarkTopStroke.BorderColor3 = Color3.fromRGB(0, 0, 0)
    o.watermarkTopStroke.BorderSizePixel = 0
    o.watermarkTopStroke.Size = UDim2.new(0, 300, 0, 1)
    
    -- Добавляем UIStroke к TopStroke
    o.watermarkStrokeUIStroke = Instance.new("UIStroke")
    o.watermarkStrokeUIStroke.Parent = o.watermarkTopStroke
    o.watermarkStrokeUIStroke.Color = Color3.fromRGB(0, 0, 0)
    o.watermarkStrokeUIStroke.Thickness = 1
    o.watermarkStrokeUIStroke.LineJoinMode = Enum.LineJoinMode.Miter
    
    -- Функция для обновления размера WaterMark в зависимости от текста
    function updateWatermarkSize()
        o.common_vars.textSize = o.watermarkText.TextBounds.X
        o.common_vars.newWidth = o.common_vars.textSize + 40
        
        o.ts:Create(o.watermarkFrame, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
            {Size = UDim2.new(0, o.common_vars.newWidth, 0, 25)}):Play()
        
        o.ts:Create(o.watermarkTopStroke, TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
            {Size = UDim2.new(0, o.common_vars.newWidth, 0, 1)}):Play()
    end
    
    o.watermarkText:GetPropertyChangedSignal("Text"):Connect(updateWatermarkSize)
    updateWatermarkSize()
    
    -- Функция для обновления позиции при перетаскивании
    function o.updateDrag(input)
        o.common_vars.delta = input.Position - o.drag.dragStart
        o.common_vars.newPosition = UDim2.new(o.drag.startPos.X.Scale, o.drag.startPos.X.Offset + o.common_vars.delta.X, 
            o.drag.startPos.Y.Scale, o.drag.startPos.Y.Offset + o.common_vars.delta.Y)
        
        o.ts:Create(o.watermarkFrame, TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
            {Position = o.common_vars.newPosition}):Play()
    end
    
    o.watermarkFrame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            o.drag.dragging = true
            o.drag.dragStart = input.Position
            o.drag.startPos = o.watermarkFrame.Position
            
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    o.drag.dragging = false
                end
            end)
        end
    end)
    
    o.watermarkFrame.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            o.drag.dragInput = input
        end
    end)
    
    o.uis.InputChanged:Connect(function(input)
        if input == o.drag.dragInput and o.drag.dragging then
            o.updateDrag(input)
        end
    end)
end

-- Тогл ватермарки с привязанным попапом и колорпикером
ExtraSection:Toggle({
    name = "Watermark", 
    default = false,
    flag = "watermark_enabled",
    callback = function(value)
        o.watermarkEnabled = value
        CreateWatermark(o.watermarkEnabled)
    end
}):Popup({size = 150}):Colorpicker({
    name = "Watermark Color",
    description = ">_<",
    default = Color3.fromRGB(0, 81, 255),
    flag = "watermark_color",
    callback = function(color)
        -- Проверяем тип переданного значения
        if type(color) == "table" and color.c then
            o.watermarkStrokeColor = color.c
        else
            o.watermarkStrokeColor = color
        end
        
        -- Обновляем цвет, если ватермарка активна
        if o.watermarkEnabled and o.watermarkFrame and o.watermarkFrame:FindFirstChild("TopStroke") then
            o.watermarkFrame.TopStroke.BackgroundColor3 = o.watermarkStrokeColor
        end
    end
})

-- Привязка переключения UI к клавише
o.uis.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == Enum.KeyCode.RightControl then
        Window.Open()
    end
end)

-- Установка вкладки по умолчанию
LegitBotTab.Set(true)

-- Периодическое обновление списка конфигов
spawn(function()
    while task.wait(5) do
        if Window and Window.Visible then
            -- Используем нашу новую функцию обновления списка
            pcall(function()
                -- Сохраняем текущее выбранное значение
                local currentSelected = Library.Flags["config_list"]
                
                -- Обновляем список
                RefreshConfigList()
                
                -- Восстанавливаем выбранное значение, если оно существует
                if currentSelected and type(currentSelected) == "string" and o.ConfigList and o.ConfigList.Set then
                    -- Проверяем, существует ли такой конфиг в обновленном списке
                    local configFiles = GetConfigFiles()
                    local exists = false
                    for _, name in ipairs(configFiles) do
                        if name == currentSelected then
                            exists = true
                            break
                        end
                    end
                    
                    if exists then
                        pcall(function()
                            o.ConfigList:Set(currentSelected)
                        end)
                    end
                end
            end)
        end
    end
end)

print("script is loaded. If u paid for this, u are retard")

-- Вкладка Misc и секция Utils
MiscUtilsSection = MiscTab:Section({name = "Utils", description = ">_<"})

-- Auto Armor logic
o.misc = {}
o.auto_armor = false

o.misc.auto_armor = function()
    if not o.auto_armor then return end
    o.common_vars.char = o.lp.Character
    o.common_vars.placeId = game.PlaceId
    
    if o.common_vars.placeId == 2788229376 then
        -- Первая игра - проверяем BodyEffects.Armor
        if o.common_vars.char and o.common_vars.char:FindFirstChild("BodyEffects") and o.common_vars.char.BodyEffects:FindFirstChild("Armor") then
            o.common_vars.armorValue = o.common_vars.char.BodyEffects.Armor.Value
            if o.common_vars.armorValue < 100 then
                o.misc.buying_armor = o.common_vars.char:FindFirstChild("HumanoidRootPart") and o.common_vars.char.HumanoidRootPart.CFrame
                o.common_vars.armorShop = o.ws:FindFirstChild("Ignored") and o.ws.Ignored:FindFirstChild("Shop")
                o.common_vars.armorItem = o.common_vars.armorShop and o.common_vars.armorShop:FindFirstChild("[High-Medium Armor] - $2513")
                if o.common_vars.armorItem and o.common_vars.armorItem:FindFirstChild("Head") and o.common_vars.armorItem:FindFirstChild("ClickDetector") then
                    o.common_vars.char.HumanoidRootPart.CFrame = o.common_vars.armorItem.Head.CFrame
                    fireclickdetector(o.common_vars.armorItem.ClickDetector)
                    o.rs.RenderStepped:Wait()
                    o.common_vars.char.HumanoidRootPart.CFrame = o.misc.buying_armor
                end
            else
                o.misc.buying_armor = nil
            end
        end
    elseif tostring(o.common_vars.placeId) == "71189885129233" then
        -- Вторая игра - проверяем DataFolder.Information.Armor
        if o.lp:FindFirstChild("DataFolder") and o.lp.DataFolder:FindFirstChild("Information") and o.lp.DataFolder.Information:FindFirstChild("Armor") then
            o.common_vars.armorValue = tonumber(o.lp.DataFolder.Information.Armor.Value) or 0
            if o.common_vars.armorValue < 100 then
                o.common_vars.armorShop = o.ws:FindFirstChild("Ignored") and o.ws.Ignored:FindFirstChild("Shop")
                
                o.common_vars.delHoodArmorOptions = {
                    {index = 59, name = "Max Armor 1"},
                    {index = 46, name = "Max Armor 2"},
                    {index = 63, name = "Max Armor 3"},
                    {index = 68, name = "Max Armor 4"},
                    {name = "[Max Armor]", direct = true}
                }
                
                for i, option in ipairs(o.common_vars.delHoodArmorOptions) do
                    o.common_vars.armorObj = nil
                    if option.direct then
                        o.common_vars.armorObj = o.common_vars.armorShop:FindFirstChild(option.name)
                    else
                        o.common_vars.armorObj = o.common_vars.armorShop:GetChildren()[option.index]
                    end
                    if o.common_vars.armorObj and o.common_vars.armorObj:FindFirstChild("Head") and o.common_vars.armorObj:FindFirstChild("ClickDetector") then
                        o.common_vars.armorItem = o.common_vars.armorObj
                        break
                    end
                end
                
                -- Поиск по имени если ничего не найдено
                if not o.common_vars.armorItem then
                    for _, item in pairs(o.common_vars.armorShop:GetChildren()) do
                        if item.Name:lower():find("armor") and item.Name:lower():find("max") and item:FindFirstChild("Head") and item:FindFirstChild("ClickDetector") then
                            o.common_vars.armorItem = item
                            break
                        end
                    end
                end
                
                if o.common_vars.armorItem then
                    o.misc.buying_armor = o.common_vars.char:FindFirstChild("HumanoidRootPart") and o.common_vars.char.HumanoidRootPart.CFrame
                    o.common_vars.char.HumanoidRootPart.CFrame = o.common_vars.armorItem.Head.CFrame
                    fireclickdetector(o.common_vars.armorItem.ClickDetector)
                    o.rs.RenderStepped:Wait()
                    o.common_vars.char.HumanoidRootPart.CFrame = o.misc.buying_armor
                end
            end
        end
    end
end

o.rs.RenderStepped:Connect(o.misc.auto_armor)

-- UI Toggle for Auto Armor
MiscUtilsSection:Toggle({
    name = "Auto Armor Enabled",
    default = false,
    flag = "misc_autoarmor",
    callback = function(v)
        o.auto_armor = v
    end
})

-- AutoBuy functionality
o.autoBuy = {
    enabled = false,
    selectedItems = {},
    itemsList = {},
    buyingIndex = 1,
    isBuying = false,
    originalPosition = nil,
    placeItems = {
        [2788229376] = {"[LMG] - $4098", "[Rifle] - $1694", "[AUG] - $2131"},
        -- Используем строку для большого числа
        ["71189885129233"] = {"[AK47]"}
    },
    buyAmmo = false,
    ammoList = {
        "200 [LMG Ammo] - $328",
        "5 [Rifle Ammo] - $273",
        "90 [AUG Ammo] - $87"
    },
    selectedAmmo = {},
    ammoAttempts = 0,
    maxAmmoAttempts = 5,
    lastGunBought = false
}

-- Функция покупки патронов
o.autoBuy.buyAmmoItem = function(ammoName)
    -- Сохраняем оригинальную позицию, если еще не сохранили
    if not o.autoBuy.originalPosition and o.lp.Character and o.lp.Character:FindFirstChild("HumanoidRootPart") then
        o.autoBuy.originalPosition = o.lp.Character.HumanoidRootPart.CFrame
    end

    -- Находит нужные патроны в магазине и "кликает" по ним
    if o.autoBuy.shopFolder then
        for _, item in pairs(o.autoBuy.shopFolder:GetChildren()) do
            if item.Name == ammoName then
                o.common_vars.itemHead = item:FindFirstChild("Head")
                if o.common_vars.itemHead then
                    -- Телепортируемся к предмету
                    o.lp.Character.HumanoidRootPart.CFrame = o.common_vars.itemHead.CFrame + Vector3.new(0, 3.2, 0)
                    
                    -- Ждем немного для загрузки окружения
                    task.wait(0.3)
                    
                    o.common_vars.clickdetector = item:FindFirstChild("ClickDetector")
                    if o.common_vars.clickdetector then
                        o.common_vars.clickdetector.MaxActivationDistance = 9e9
                        fireclickdetector(o.common_vars.clickdetector)
                        task.wait(0.5)
                        return true
                    end
                end
                break
            end
        end
    end
    return false
end

-- Инициализация списка предметов в зависимости от placeId
o.autoBuy.initializeItems = function()
    local placeId = game.PlaceId
    local placeIdStr = tostring(placeId)
    
    -- Проверяем сначала числовой ключ, затем строковый
    o.autoBuy.itemsList = o.autoBuy.placeItems[placeId] or o.autoBuy.placeItems[placeIdStr] or o.autoBuy.placeItems[2788229376]
    
    -- Устанавливаем первый предмет как выбранный по умолчанию
    if #o.autoBuy.itemsList > 0 then
        o.autoBuy.selectedItems = {[o.autoBuy.itemsList[1]] = true}
    end
end

-- Получение папки магазина
o.common_vars.success = pcall(function()
    o.autoBuy.shopFolder = o.ws:WaitForChild("Ignored", 5):WaitForChild("Shop", 5)
    return true
end)

if not o.common_vars.success or not o.autoBuy.shopFolder then
    o.autoBuy.shopFolder = nil
end

-- Инициализируем список предметов при загрузке
o.autoBuy.initializeItems()

-- Проверка наличия предмета у игрока
o.autoBuy.hasItem = function(itemName)
    if type(itemName) ~= "string" then
        return false
    end
    
    -- Извлекаем название оружия из строки
    o.common_vars.nameCheck = itemName:match("%[(.-)%]")
    if not o.common_vars.nameCheck then
        o.common_vars.nameCheck = itemName:match("%[(.+)") -- Для случаев без закрывающей скобки
        if not o.common_vars.nameCheck then
            o.common_vars.nameCheck = itemName -- Используем полное имя, если не удалось извлечь
        end
    end
    
    o.common_vars.checkContainer = function(container)
        if not container then return false end
        for _, tool in ipairs(container:GetChildren()) do
            if tool:IsA("Tool") and tool.Name:lower():find(o.common_vars.nameCheck:lower()) then
                return true
            end
        end
        return false
    end
    
    return o.common_vars.checkContainer(o.lp.Backpack) or o.common_vars.checkContainer(o.lp.Character)
end

-- Получение списка выбранных предметов
o.autoBuy.getSelectedItems = function()
    o.common_vars.selected = {}
    if type(o.autoBuy.selectedItems) == "table" then
        for _, item in ipairs(o.autoBuy.selectedItems) do
            if type(item) == "string" then
                table.insert(o.common_vars.selected, item)
            end
        end
    end
    return o.common_vars.selected
end

-- Функция покупки предмета
o.autoBuy.buyItem = function(itemName)
    -- Сохраняем оригинальную позицию, если еще не сохранили
    if not o.autoBuy.originalPosition and o.lp.Character and o.lp.Character:FindFirstChild("HumanoidRootPart") then
        o.autoBuy.originalPosition = o.lp.Character.HumanoidRootPart.CFrame
    end

    -- Сначала убирает все предметы из рук в рюкзак
    for _, tool in pairs(o.lp.Character:GetChildren()) do
        if tool:IsA("Tool") then
            tool.Parent = o.lp.Backpack
        end
    end

    -- Находит нужный предмет в магазине и "кликает" по нему
    if o.autoBuy.shopFolder then
        for _, item in pairs(o.autoBuy.shopFolder:GetChildren()) do
            if item.Name == itemName then
                o.common_vars.itemHead = item:FindFirstChild("Head")
                if o.common_vars.itemHead then
                    -- Телепортируемся к предмету
                    o.lp.Character.HumanoidRootPart.CFrame = o.common_vars.itemHead.CFrame + Vector3.new(0, 3.2, 0)
                    
                    -- Ждем немного для загрузки окружения
                    task.wait(0.5)
                    
                    o.common_vars.clickdetector = item:FindFirstChild("ClickDetector")
                    if o.common_vars.clickdetector then
                        o.common_vars.clickdetector.MaxActivationDistance = 9e9
                        
                        -- Первая попытка покупки
                        fireclickdetector(o.common_vars.clickdetector)
                        
                        -- Ждем для завершения покупки
                        task.wait(1)
                        
                        -- Проверяем, появился ли предмет
                        if o.autoBuy.hasItem(itemName) then
                            -- Если оружие куплено успешно, сбрасываем счетчик попыток покупки патронов
                            o.autoBuy.lastGunBought = true
                            o.autoBuy.ammoAttempts = 0
                            
                            -- Если включена автопокупка патронов, покупаем их
                            if o.autoBuy.buyAmmo and #o.autoBuy.selectedAmmo > 0 then
                                -- Покупаем каждый выбранный тип патронов
                                for _, ammoName in ipairs(o.autoBuy.selectedAmmo) do
                                    o.autoBuy.buyAmmoItem(ammoName)
                                end
                            end
                            
                            return true
                        end
                        
                        -- Если не появился, пробуем еще раз
                        fireclickdetector(o.common_vars.clickdetector)
                        task.wait(1)
                        
                        o.common_vars.success = o.autoBuy.hasItem(itemName)
                        
                        -- Если оружие куплено успешно, сбрасываем счетчик попыток покупки патронов
                        if o.common_vars.success then
                            o.autoBuy.lastGunBought = true
                            o.autoBuy.ammoAttempts = 0
                            
                            -- Если включена автопокупка патронов, покупаем их
                            if o.autoBuy.buyAmmo and #o.autoBuy.selectedAmmo > 0 then
                                -- Покупаем каждый выбранный тип патронов
                                for _, ammoName in ipairs(o.autoBuy.selectedAmmo) do
                                    o.autoBuy.buyAmmoItem(ammoName)
                                end
                            end
                        end
                        
                        return o.common_vars.success
                    end
                end
                break
            end
        end
    end
    return false
end

-- Добавляем индекс текущего предмета для покупки
o.autoBuy.currentItemIndex = 1

-- Отключаем предыдущий цикл автозакупки, если он существует
if o.autoBuy.connection then
    o.autoBuy.connection:Disconnect()
    o.autoBuy.connection = nil
end

-- Создаем новый цикл автозакупки
o.autoBuy.connection = o.rs.Heartbeat:Connect(function()
    if not o.autoBuy.enabled or o.autoBuy.isBuying then return end
    
    o.common_vars.selectedItems = o.autoBuy.getSelectedItems()
    
    if #o.common_vars.selectedItems == 0 then return end
    
    -- Проверяем, есть ли предметы, которые нужно купить
    o.common_vars.missingItems = {}
    
    for _, item in ipairs(o.common_vars.selectedItems) do
        if not o.autoBuy.hasItem(item) then
            table.insert(o.common_vars.missingItems, item)
        end
    end
    
    if #o.common_vars.missingItems > 0 then
        o.autoBuy.isBuying = true
        
        -- Если индекс вышел за пределы, сбрасываем его
        if o.autoBuy.currentItemIndex > #o.common_vars.missingItems then
            o.autoBuy.currentItemIndex = 1
        end
        
        -- Покупаем текущий отсутствующий предмет
        o.common_vars.item = o.common_vars.missingItems[o.autoBuy.currentItemIndex]
        o.common_vars.success = o.autoBuy.buyItem(o.common_vars.item)
        
        -- Возвращаемся на исходную позицию
        o.autoBuy.returnToOriginalPosition()
        
        -- Увеличиваем индекс для следующего предмета
        o.autoBuy.currentItemIndex = o.autoBuy.currentItemIndex + 1
        
        -- Если мы дошли до конца списка, сбрасываем индекс
        if o.autoBuy.currentItemIndex > #o.common_vars.missingItems then
            o.autoBuy.currentItemIndex = 1
        end
        
        -- Короткая задержка перед следующей проверкой
        task.wait(0.5)
        o.autoBuy.isBuying = false
    else
        -- Если все предметы уже есть, проверяем нужно ли купить патроны
        if o.autoBuy.buyAmmo and #o.autoBuy.selectedAmmo > 0 and o.autoBuy.ammoAttempts < o.autoBuy.maxAmmoAttempts then
            -- Покупаем патроны только если недавно было куплено оружие
            if o.autoBuy.lastGunBought then
                o.autoBuy.isBuying = true
                
                -- Покупаем каждый выбранный тип патронов
                for _, ammoName in ipairs(o.autoBuy.selectedAmmo) do
                    o.autoBuy.buyAmmoItem(ammoName)
                end
                
                -- Увеличиваем счетчик попыток
                o.autoBuy.ammoAttempts = o.autoBuy.ammoAttempts + 1
                
                -- Если достигли максимального числа попыток, сбрасываем флаг покупки оружия
                if o.autoBuy.ammoAttempts >= o.autoBuy.maxAmmoAttempts then
                    o.autoBuy.lastGunBought = false
                end
                
                -- Возвращаемся на исходную позицию
                o.autoBuy.returnToOriginalPosition()
                
                o.autoBuy.isBuying = false
            end
        end
        
        -- Если все предметы уже есть, делаем небольшую паузу
        task.wait(1)
        -- Сбрасываем индекс для следующего цикла
        o.autoBuy.currentItemIndex = 1
    end
end)

-- Функция для возврата на исходную позицию
o.autoBuy.returnToOriginalPosition = function()
    if o.autoBuy.originalPosition and o.lp.Character and o.lp.Character:FindFirstChild("HumanoidRootPart") then
        o.lp.Character.HumanoidRootPart.CFrame = o.autoBuy.originalPosition
        o.autoBuy.originalPosition = nil
    end
end

-- UI Toggle for AutoBuy with multi-select
o.AutoBuyToggle = MiscUtilsSection:Toggle({
    name = "AutoBuy",
    default = false,
    flag = "misc_autobuy",
    callback = function(v)
        o.autoBuy.enabled = v
    end
})

-- Создаем попап для AutoBuy
o.AutoBuyPopup = o.AutoBuyToggle:Popup({size = 250})

-- Добавляем выпадающий список для выбора оружия в попап AutoBuy
o.AutoBuyPopup:Dropdown({
    name = "Items",
    values = o.autoBuy.itemsList,
    multi = true,
    value = o.autoBuy.itemsList[1] and {o.autoBuy.itemsList[1]} or {},
    flag = "autobuy_items",
    callback = function(v)
        o.autoBuy.selectedItems = v
    end
})

-- Добавлять ammo только если не 71189885129233
if tostring(game.PlaceId) ~= "71189885129233" then
    -- Добавляем тогл для включения/выключения автопокупки патронов
    o.AutoBuyPopup:Toggle({
        name = "Auto Buy Ammo",
        default = false,
        flag = "autobuy_ammo",
        callback = function(v)
            o.autoBuy.buyAmmo = v
        end
    })

    -- Добавляем выпадающий список для выбора типов патронов
    o.AutoBuyPopup:Dropdown({
        name = "Ammo Types",
        values = o.autoBuy.ammoList,
        multi = true,
        value = {},
        flag = "autobuy_ammo_types",
        callback = function(v)
            o.autoBuy.selectedAmmo = v
        end
    })
end

-- Добавляем функционал Multi Guns
o.multiGuns = {
    enabled = false,
    selectedGuns = {},
    gunsList = {"[LMG] - $4098", "[Rifle] - $1694", "[AUG] - $2131"},
    isEquipping = false
}

-- Функция для экипировки выбранного оружия
o.multiGuns.equipSelectedGuns = function()
    if o.multiGuns.isEquipping then return end
    o.multiGuns.isEquipping = true
    
    -- Получаем персонажа и рюкзак
    o.common_vars.char = o.lp.Character
    o.common_vars.backpack = o.lp.Backpack
    
    if not o.common_vars.char or not o.common_vars.backpack then
        o.multiGuns.isEquipping = false
        return
    end
    
    -- Экипируем каждое оружие из выбранного списка
    for _, gunName in ipairs(o.multiGuns.selectedGuns) do
        -- Ищем оружие в рюкзаке
        o.common_vars.nameCheck = gunName:match("%[(.-)%]")
        if not o.common_vars.nameCheck then
            o.common_vars.nameCheck = gunName -- Используем полное имя, если не удалось извлечь
        end
        
        for _, tool in ipairs(o.common_vars.backpack:GetChildren()) do
            if tool:IsA("Tool") and tool.Name:lower():find(o.common_vars.nameCheck:lower()) then
                -- Экипируем оружие
                tool.Parent = o.common_vars.char
                task.wait(0.2) -- Небольшая задержка между экипировкой
                
                -- Пытаемся перезарядить оружие
                pcall(function()
                    o.RP.MainEvent:FireServer("Reload", tool)
                end)
                
                break
            end
        end
    end
    
    o.multiGuns.isEquipping = false
end

-- Функция для проверки, все ли выбранные оружия экипированы
o.multiGuns.checkEquippedGuns = function()
    if not o.multiGuns.enabled or o.multiGuns.isEquipping then return end
    
    o.common_vars.char = o.lp.Character
    if not o.common_vars.char then return end
    
    -- Проверяем, все ли выбранные оружия экипированы
    o.common_vars.missingGuns = false
    
    for _, gunName in ipairs(o.multiGuns.selectedGuns) do
        o.common_vars.nameCheck = gunName:match("%[(.-)%]")
        if not o.common_vars.nameCheck then
            o.common_vars.nameCheck = gunName
        end
        
        o.common_vars.foundGun = false
        for _, tool in ipairs(o.common_vars.char:GetChildren()) do
            if tool:IsA("Tool") and tool.Name:lower():find(o.common_vars.nameCheck:lower()) then
                o.common_vars.foundGun = true
                break
            end
        end
        
        if not o.common_vars.foundGun then
            o.common_vars.missingGuns = true
            break
        end
    end
    
    -- Если какое-то оружие отсутствует, экипируем все заново
    if o.common_vars.missingGuns then
        o.multiGuns.equipSelectedGuns()
    end
end

-- Обработка события появления персонажа для Multi Guns
o.multiGuns.characterAddedConnection = o.lp.CharacterAdded:Connect(function(character)
    if o.multiGuns.enabled and game.PlaceId == 2788229376 then -- Только для первой игры
        task.wait(0.5) -- Задержка для загрузки GUI
        o.multiGuns.equipSelectedGuns()
    end
end)

-- Создаем цикл проверки экипированного оружия
if o.multiGuns.checkConnection then
    o.multiGuns.checkConnection:Disconnect()
    o.multiGuns.checkConnection = nil
end

o.multiGuns.checkConnection = o.rs.Heartbeat:Connect(function()
    if game.PlaceId == 2788229376 and o.multiGuns.enabled then
        -- Проверяем каждые 2 секунды
        if not o.multiGuns.lastCheck or tick() - o.multiGuns.lastCheck > 2 then
            o.multiGuns.lastCheck = tick()
            o.multiGuns.checkEquippedGuns()
        end
    end
end)

-- Добавляем тогл Multi Guns с попапом (только для первой игры)
if game.PlaceId == 2788229376 then
    MiscUtilsSection:Toggle({
        name = "Multi Guns",
        default = false,
        flag = "misc_multiguns",
        callback = function(v)
            o.multiGuns.enabled = v
            if v then
                o.multiGuns.equipSelectedGuns()
            end
        end
    }):Popup({size = 200}):Dropdown({
        name = "Guns",
        values = o.multiGuns.gunsList,
        multi = true,
        value = {},
        flag = "multiguns_items",
        callback = function(v)
            o.multiGuns.selectedGuns = v
            if o.multiGuns.enabled then
                o.multiGuns.equipSelectedGuns()
            end
        end
    })
end

-- Создаем секцию Extra во вкладке Misc (справа)
ExtraSection = MiscTab:Section({name = "Extra", description = ">_<", side = "right"})

-- Добавляем тогл No Recoil
ExtraSection:Toggle({
    name = "No Recoil",
    default = false,
    flag = "misc_norecoil",
    callback = function(value)
        if value then
            -- Сохраняем оригинальный хук, если он еще не сохранен
            if not o.originalRecoilHook then
                o.originalRecoilHook = hookmetamethod(game, "__newindex", function(self, index, value)
                    o.common_vars.callingScr = getcallingscript()
                    
                    -- Функция проверки Framework
                    function o.common_vars.isframework(scriptInstance)
                        if tostring(scriptInstance) == "Framework" then
                            return true
                        end
                        return false
                    end
                    
                    -- Функция проверки аргументов
                    function o.common_vars.checkArgs(instance, idx)
                        if tostring(instance):lower():find("camera") and tostring(idx) == "CFrame" then
                            return true
                        end
                        return false
                    end
                    
                    -- Если включен No Recoil и вызов от Framework для изменения CFrame камеры, блокируем
                    if Library.Flags["misc_norecoil"] and o.common_vars.isframework(o.common_vars.callingScr) and o.common_vars.checkArgs(self, index) then
                        return
                    end
                    
                    -- Иначе пропускаем вызов
                    return o.originalRecoilHook(self, index, value)
                end)
            end
        end
    end
})

-- Добавляем тогл Unlock Camera Distance
ExtraSection:Toggle({
    name = "Unlock Camera Distance",
    default = false,
    flag = "misc_unlockcamera",
    callback = function(value)
        if value then
            -- Устанавливаем максимальное расстояние камеры на бесконечность
            o.lp.CameraMaxZoomDistance = math.huge
            
            -- Сохраняем соединение для обновления при изменении настроек
            if not o.cameraDistanceConnection then
                o.cameraDistanceConnection = o.rs.Heartbeat:Connect(function()
                    if Library.Flags["misc_unlockcamera"] then
                        if o.lp.CameraMaxZoomDistance ~= math.huge then
                            o.lp.CameraMaxZoomDistance = math.huge
                        end
                    end
                end)
            end
        else
            -- Возвращаем стандартное значение при выключении
            o.lp.CameraMaxZoomDistance = 128 -- Стандартное значение в большинстве игр
            
            -- Отключаем соединение
            if o.cameraDistanceConnection then
                o.cameraDistanceConnection:Disconnect()
                o.cameraDistanceConnection = nil
            end
        end
    end
})

-- Добавляем тогл FOV Changer с попапом
o.FovChangerToggle = ExtraSection:Toggle({
    name = "FOV Changer",
    default = false,
    flag = "misc_fovchanger",
    callback = function(value)
        -- Сохраняем оригинальное FOV при первом включении
        if not o.originalFov and value then
            o.originalFov = o.camera.FieldOfView
        end
        
        if value then
            -- Устанавливаем новое FOV
            o.camera.FieldOfView = Library.Flags["misc_fov_value"] or 70
            
            -- Создаем соединение для обновления FOV
            if not o.fovChangerConnection then
                o.fovChangerConnection = o.rs.RenderStepped:Connect(function()
                    if Library.Flags["misc_fovchanger"] and o.camera.FieldOfView ~= Library.Flags["misc_fov_value"] then
                        o.camera.FieldOfView = Library.Flags["misc_fov_value"] or 70
                    end
                end)
            end
        else
            -- Возвращаем оригинальное FOV при выключении
            if o.originalFov then
                o.camera.FieldOfView = o.originalFov
            end
            
            -- Отключаем соединение
            if o.fovChangerConnection then
                o.fovChangerConnection:Disconnect()
                o.fovChangerConnection = nil
            end
        end
    end
})

-- Создаем попап для FOV Changer
o.FovChangerToggle:Popup({size = 150}):Slider({
    name = "FOV Value",
    min = 70,
    max = 120,
    default = 90,
    float = 1,
    flag = "misc_fov_value",
    callback = function(value)
        if Library.Flags["misc_fovchanger"] then
            o.camera.FieldOfView = value
        end
    end
})

-- Функционал Save Walkspeed удален

-- Функционал Jump Power удален

-- ChatSpy функционал удален

-- Создаем секцию PlayerActions во вкладке Misc (слева)
PlayerActionsSection = MiscTab:Section({name = "Player Actions", description = ">_<", side = "left"})

-- Функция для обновления списка игроков
function UpdatePlayerList()
    playerNames = {}
    for _, player in pairs(o.plrs:GetPlayers()) do
        if player ~= o.lp then
            -- Проверка, что player.Name это строка
            playerName = player.Name
            if type(playerName) ~= "string" then
                playerName = tostring(playerName)
            end
            table.insert(playerNames, playerName)
        end
    end
    return playerNames
end

-- Инициализация списка игроков
o.playerList = UpdatePlayerList()
o.selectedPlayer = nil

-- Добавляем список игроков
o.PlayersList = PlayerActionsSection:List({
    name = "Players",
    values = o.playerList,
    value = o.playerList[1],
    flag = "player_selected",
    callback = function(value)
        o.selectedPlayer = o.plrs:FindFirstChild(value)
    end
})

-- Сохраняем оригинальную функцию Refresh
if o.PlayersList then
    if type(o.PlayersList.Refresh) == "function" then
        -- Если Refresh уже функция, сохраняем её
        o.originalRefresh = o.PlayersList.Refresh
    else
        -- Если Refresh не функция, создаём обёртку
        o.originalRefresh = function(values)
            o.PlayersList.Refresh(values)
        end
    end
    
    -- Переопределяем функцию Refresh для безопасного вызова
    o.PlayersList.Refresh = function(values)
        if type(o.originalRefresh) == "function" then
            o.originalRefresh(values)
        end
    end
end

-- Функция для обновления списка игроков при входе/выходе
o.plrs.PlayerAdded:Connect(function(player)
    if player ~= o.lp then
        o.playerList = UpdatePlayerList()
        if o.PlayersList and o.PlayersList.Refresh then
            -- Используем нашу безопасную функцию Refresh
            o.PlayersList.Refresh(o.playerList)
        end
    end
end)

o.plrs.PlayerRemoving:Connect(function()
    o.playerList = UpdatePlayerList()
    if o.PlayersList and o.PlayersList.Refresh then
        -- Используем нашу безопасную функцию Refresh
        o.PlayersList.Refresh(o.playerList)
    end
end)

-- Добавляем кнопку View (наблюдение за игроком)
PlayerActionsSection:Button({
    name = "View",
    callback = function()
        if o.selectedPlayer and o.selectedPlayer.Character then
            -- Устанавливаем камеру на выбранного игрока
            o.camera.CameraSubject = o.selectedPlayer.Character:FindFirstChildOfClass("Humanoid")
            o.isViewing = true
            
            -- Создаем соединение для слежения за персонажем игрока
            if not o.viewConnection then
                o.viewConnection = o.rs.RenderStepped:Connect(function()
                    if not o.selectedPlayer or not o.selectedPlayer.Character then
                        -- Если игрок вышел или персонаж исчез, возвращаем камеру
                        if o.viewConnection then
                            o.viewConnection:Disconnect()
                            o.viewConnection = nil
                        end
                        
                        if o.lp.Character then
                            o.camera.CameraSubject = o.lp.Character:FindFirstChildOfClass("Humanoid")
                        end
                        o.isViewing = false
                    end
                end)
            end
        end
    end
})

-- Добавляем кнопку Stop View (прекращение наблюдения)
PlayerActionsSection:Button({
    name = "Stop View",
    callback = function()
        -- Отключаем наблюдение и возвращаем камеру
        if o.viewConnection then
            o.viewConnection:Disconnect()
            o.viewConnection = nil
        end
        
        if o.lp.Character then
            o.camera.CameraSubject = o.lp.Character:FindFirstChildOfClass("Humanoid")
        end
        o.isViewing = false
    end
})

-- Добавляем кнопку Teleport (телепортация к игроку)
PlayerActionsSection:Button({
    name = "Teleport",
    callback = function()
        if o.selectedPlayer and o.selectedPlayer.Character and o.lp.Character then
            -- Телепортируемся к игроку
            o.lp.Character.HumanoidRootPart.CFrame = o.selectedPlayer.Character.HumanoidRootPart.CFrame
        end
    end
})

-- Добавляем кнопку Add Friend (добавление игрока в друзья)
PlayerActionsSection:Button({
    name = "Add Friend",
    callback = function()
        if o.selectedPlayer then
            -- Добавляем игрока в список друзей
            MaterialChamsConfig.Friend.Friends[o.selectedPlayer.Name] = true
            saveFriends()
            
            -- Если включен Friend Chams, применяем к новому другу
            if MaterialChamsConfig.Friend.Enabled and Library.Flags["visual_materialchams"] then
                applyFriendChams()
            end
            
            -- Если включен Friend Highlight, применяем к новому другу
            if HighlightChamsConfig.Friend.Enabled and Library.Flags["visual_highlightchams"] then
                -- Убедимся, что Friends инициализирован
                if not HighlightChamsConfig.Friend.Friends then
                    HighlightChamsConfig.Friend.Friends = {}
                end
                applyFriendHighlight()
            end
            
            -- Если включен Other Chams или Other Highlight, обновляем их, чтобы исключить нового друга
            if MaterialChamsConfig.Other.Enabled and Library.Flags["visual_materialchams"] then
                applyOtherChams()
            end
            
            if HighlightChamsConfig.Other.Enabled and Library.Flags["visual_highlightchams"] then
                applyOtherHighlight()
            end
        end
    end
})

-- Добавляем кнопку Remove Friend (удаление игрока из друзей)
PlayerActionsSection:Button({
    name = "Remove Friend",
    callback = function()
        if o.selectedPlayer and MaterialChamsConfig.Friend.Friends[o.selectedPlayer.Name] then
            -- Удаляем игрока из списка друзей
            MaterialChamsConfig.Friend.Friends[o.selectedPlayer.Name] = nil
            saveFriends()
            
            -- Если включен Other Chams или Other Highlight, обновляем их, чтобы включить бывшего друга
            if MaterialChamsConfig.Other.Enabled and Library.Flags["visual_materialchams"] then
                applyOtherChams()
            end
            
            if HighlightChamsConfig.Other.Enabled and Library.Flags["visual_highlightchams"] then
                applyOtherHighlight()
            end
            
            -- Удаляем хайлайт друга, если он существует
            friendData = HighlightChamsConfig.Friend.Friends and HighlightChamsConfig.Friend.Friends[o.selectedPlayer.Name]
            if friendData then
                if friendData.Highlight and friendData.Highlight:IsA("Highlight") then
                    pcall(function()
                        friendData.Highlight:Destroy()
                    end)
                end
                HighlightChamsConfig.Friend.Friends[o.selectedPlayer.Name] = nil
            end
        end
    end
})

-- Добавляем тогл Destroy Seats в секцию Extra
ExtraSection:Toggle({
    name = "Destroy Seats",
    default = false,
    flag = "misc_destroyseats",
    callback = function(value)
        if value then
            -- Сохраняем оригинальные сиденья
            if not o.originalSeats then
                o.originalSeats = {}
                
                -- Находим все сиденья в игре
                for _, seat in pairs(workspace:GetDescendants()) do
                    if seat:IsA("Seat") or seat:IsA("VehicleSeat") then
                        -- Сохраняем информацию о сиденье
                        table.insert(o.originalSeats, {
                            instance = seat,
                            parent = seat.Parent,
                            position = seat.Position,
                            orientation = seat.Orientation,
                            size = seat.Size,
                            anchored = seat.Anchored,
                            canCollide = seat.CanCollide,
                            disabled = false
                        })
                        
                        -- "Уничтожаем" сиденье (делаем невидимым и неактивным)
                        seat.CanCollide = false
                        seat.Anchored = true
                        seat.Disabled = true
                        seat.Transparency = 1
                    end
                end
            else
                -- Если сиденья уже были сохранены, просто деактивируем их
                for _, seatData in pairs(o.originalSeats) do
                    if seatData.instance and seatData.instance.Parent then
                        seatData.instance.CanCollide = false
                        seatData.instance.Anchored = true
                        seatData.instance.Disabled = true
                        seatData.instance.Transparency = 1
                        seatData.disabled = true
                    end
                end
            end
            
            -- Создаем соединение для обработки новых сидений
            if not o.seatsConnection then
                o.seatsConnection = workspace.DescendantAdded:Connect(function(descendant)
                    if (descendant:IsA("Seat") or descendant:IsA("VehicleSeat")) and Library.Flags["misc_destroyseats"] then
                        -- Сохраняем информацию о новом сиденье
                        table.insert(o.originalSeats, {
                            instance = descendant,
                            parent = descendant.Parent,
                            position = descendant.Position,
                            orientation = descendant.Orientation,
                            size = descendant.Size,
                            anchored = descendant.Anchored,
                            canCollide = descendant.CanCollide,
                            disabled = true
                        })
                        
                        -- "Уничтожаем" сиденье
                        descendant.CanCollide = false
                        descendant.Anchored = true
                        descendant.Disabled = true
                        descendant.Transparency = 1
                    end
                end)
            end
        else
            -- Восстанавливаем сиденья
            if o.originalSeats then
                for _, seatData in pairs(o.originalSeats) do
                    if seatData.instance and seatData.instance.Parent then
                        -- Восстанавливаем оригинальные свойства
                        seatData.instance.CanCollide = seatData.canCollide
                        seatData.instance.Anchored = seatData.anchored
                        seatData.instance.Disabled = false
                        seatData.instance.Transparency = 0
                        seatData.disabled = false
                    end
                end
            end
            
            -- Отключаем соединение
            if o.seatsConnection then
                o.seatsConnection:Disconnect()
                o.seatsConnection = nil
            end
        end
    end
})

-- Создаем секцию World во вкладке Misc (справа)
o.WorldSection = MiscTab:Section({name = "World", description = ">_<", side = "right"})

-- Добавляем тогл Fog с попапом
o.FogToggle = o.WorldSection:Toggle({
    name = "Fog",
    default = false,
    flag = "world_fog",
    callback = function(value)
        if value then
            -- Сохраняем оригинальные настройки тумана
            if not o.originalFogSettings then
                o.originalFogSettings = {
                    FogStart = o.LS.FogStart,
                    FogEnd = o.LS.FogEnd,
                    FogColor = o.LS.FogColor
                }
            end
            
            -- Применяем настройки тумана
            o.LS.FogStart = Library.Flags["fog_start"] or 0
            o.LS.FogEnd = Library.Flags["fog_end"] or 1000
            fogColor = Library.Flags["fog_color"]
            if fogColor then
                if type(fogColor) == "table" and fogColor.c then
                    o.LS.FogColor = fogColor.c
                else
                    o.LS.FogColor = fogColor
                end
            end
        else
            -- Восстанавливаем оригинальные настройки
            if o.originalFogSettings then
                o.LS.FogStart = o.originalFogSettings.FogStart
                o.LS.FogEnd = o.originalFogSettings.FogEnd
                o.LS.FogColor = o.originalFogSettings.FogColor
            end
        end
    end
})

-- Создаем попап для настроек тумана
o.FogPopup = o.FogToggle:Popup({size = 200})

-- Добавляем слайдер для начала тумана
o.FogPopup:Slider({
    name = "FogStart",
    min = 0,
    max = 1000,
    default = 0,
    float = 1,
    flag = "fog_start",
    callback = function(value)
        if Library.Flags["world_fog"] then
            o.LS.FogStart = value
        end
    end
})

-- Добавляем слайдер для конца тумана
o.FogPopup:Slider({
    name = "FogEnd",
    min = 0,
    max = 10000,
    default = 1000,
    float = 1,
    flag = "fog_end",
    callback = function(value)
        if Library.Flags["world_fog"] then
            o.LS.FogEnd = value
        end
    end
})

-- Добавляем колорпикер для цвета тумана
o.FogPopup:Colorpicker({
    name = "FogColor",
    description = ">_<",
    default = Color3.fromRGB(192, 192, 192),
    flag = "fog_color",
    callback = function(color)
        if Library.Flags["world_fog"] then
            if type(color) == "table" and color.c then
                o.LS.FogColor = color.c
            else
                o.LS.FogColor = color
            end
        end
    end
})

-- Добавляем тогл Bloom с попапом
o.BloomToggle = o.WorldSection:Toggle({
    name = "Bloom",
    default = false,
    flag = "world_bloom",
    callback = function(value)
        -- Проверяем, существует ли эффект Bloom
        bloomEffect = o.LS:FindFirstChild("Bloom")
        
        if value then
            -- Создаем эффект Bloom, если его нет
            if not bloomEffect then
                bloomEffect = Instance.new("BloomEffect")
                bloomEffect.Name = "Bloom"
                bloomEffect.Parent = o.LS
            end
            
            -- Применяем настройки Bloom
            bloomEffect.Intensity = Library.Flags["bloom_intensity"] or 0
            bloomEffect.Size = Library.Flags["bloom_size"] or 0
            bloomEffect.Threshold = Library.Flags["bloom_threshold"] or 0
            bloomEffect.Enabled = true
        else
            -- Отключаем эффект Bloom
            if bloomEffect then
                bloomEffect.Enabled = false
            end
        end
    end
})

-- Создаем попап для настроек Bloom
o.BloomPopup = o.BloomToggle:Popup({size = 200})

-- Добавляем слайдер для интенсивности Bloom
o.BloomPopup:Slider({
    name = "Intensity",
    min = 0,
    max = 5,
    default = 0,
    float = 0.01,
    flag = "bloom_intensity",
    callback = function(value)
        bloomEffect = o.LS:FindFirstChild("Bloom")
        if Library.Flags["world_bloom"] and bloomEffect then
            bloomEffect.Intensity = value
        end
    end
})

-- Добавляем слайдер для размера Bloom
o.BloomPopup:Slider({
    name = "Size",
    min = 0,
    max = 50,
    default = 0,
    float = 0.01,
    flag = "bloom_size",
    callback = function(value)
        bloomEffect = o.LS:FindFirstChild("Bloom")
        if Library.Flags["world_bloom"] and bloomEffect then
            bloomEffect.Size = value
        end
    end
})

-- Добавляем слайдер для порога Bloom
o.BloomPopup:Slider({
    name = "Threshold",
    min = 0,
    max = 10,
    default = 0,
    float = 0.01,
    flag = "bloom_threshold",
    callback = function(value)
        bloomEffect = o.LS:FindFirstChild("Bloom")
        if Library.Flags["world_bloom"] and bloomEffect then
            bloomEffect.Threshold = value
        end
    end
})

-- Добавляем тогл ColorCorrection с попапом
o.ColorCorrectionToggle = o.WorldSection:Toggle({
    name = "ColorCorrection",
    default = false,
    flag = "world_colorcorrection",
    callback = function(value)
        -- Проверяем, существует ли эффект ColorCorrection
        colorEffect = o.LS:FindFirstChild("ColorCorrection")
        
        if value then
            -- Создаем эффект ColorCorrection, если его нет
            if not colorEffect then
                colorEffect = Instance.new("ColorCorrectionEffect")
                colorEffect.Name = "ColorCorrection"
                colorEffect.Parent = o.LS
            end
            
            -- Применяем настройки ColorCorrection
            colorEffect.Brightness = Library.Flags["cc_brightness"] or 0
            colorEffect.Contrast = Library.Flags["cc_contrast"] or 0
            colorEffect.Saturation = Library.Flags["cc_saturation"] or 0
            
            tintColor = Library.Flags["cc_tint"]
            if tintColor then
                if type(tintColor) == "table" and tintColor.c then
                    colorEffect.TintColor = tintColor.c
                else
                    colorEffect.TintColor = tintColor
                end
            end
            
            colorEffect.Enabled = true
        else
            -- Отключаем эффект ColorCorrection
            if colorEffect then
                colorEffect.Enabled = false
            end
        end
    end
})

-- Создаем попап для настроек ColorCorrection
o.ColorCorrectionPopup = o.ColorCorrectionToggle:Popup({size = 200})

-- Добавляем слайдер для яркости
o.ColorCorrectionPopup:Slider({
    name = "Brightness",
    min = -1,
    max = 1,
    default = 0,
    float = 0.05,
    flag = "cc_brightness",
    callback = function(value)
        colorEffect = o.LS:FindFirstChild("ColorCorrection")
        if Library.Flags["world_colorcorrection"] and colorEffect then
            colorEffect.Brightness = value
        end
    end
})

-- Добавляем слайдер для контраста
o.ColorCorrectionPopup:Slider({
    name = "Contrast",
    min = -1,
    max = 1,
    default = 0,
    float = 0.05,
    flag = "cc_contrast",
    callback = function(value)
        colorEffect = o.LS:FindFirstChild("ColorCorrection")
        if Library.Flags["world_colorcorrection"] and colorEffect then
            colorEffect.Contrast = value
        end
    end
})

-- Добавляем слайдер для насыщенности
o.ColorCorrectionPopup:Slider({
    name = "Saturation",
    min = -1,
    max = 1,
    default = 0,
    float = 0.05,
    flag = "cc_saturation",
    callback = function(value)
        colorEffect = o.LS:FindFirstChild("ColorCorrection")
        if Library.Flags["world_colorcorrection"] and colorEffect then
            colorEffect.Saturation = value
        end
    end
})

-- Добавляем колорпикер для оттенка (TintColor - это цветовой фильтр, который накладывается на изображение)
o.ColorCorrectionPopup:Colorpicker({
    name = "TintColor",
    description = ">_<",
    default = Color3.fromRGB(255, 255, 255), -- Белый цвет не меняет изображение
    flag = "cc_tint",
    callback = function(color)
        colorEffect = o.LS:FindFirstChild("ColorCorrection")
        if Library.Flags["world_colorcorrection"] and colorEffect then
            if type(color) == "table" and color.c then
                colorEffect.TintColor = color.c
            else
                colorEffect.TintColor = color
            end
        end
    end
})

-- Добавляем тогл Shadows с попапом
o.ShadowsToggle = o.WorldSection:Toggle({
    name = "Shadows",
    default = false,
    flag = "world_shadows",
    callback = function(value)
        -- Сохраняем оригинальные настройки теней при первом включении
        if not o.originalShadowSettings then
            o.originalShadowSettings = {
                GlobalShadows = o.LS.GlobalShadows
            }
        end
        
        if value then
            -- Применяем настройки теней из флагов
            if Library.Flags["shadows_disable"] ~= nil then
                o.LS.GlobalShadows = not Library.Flags["shadows_disable"]
            end
        else
            -- Восстанавливаем оригинальные настройки
            if o.originalShadowSettings then
                o.LS.GlobalShadows = o.originalShadowSettings.GlobalShadows
            end
        end
    end
})

-- Создаем попап для настроек теней
o.ShadowsPopup = o.ShadowsToggle:Popup({size = 150})

-- Добавляем тогл для отключения теней
o.ShadowsPopup:Toggle({
    name = "DisableShadows",
    default = false,
    flag = "shadows_disable",
    callback = function(value)
        if Library.Flags["world_shadows"] then
            o.LS.GlobalShadows = not value
        end
    end
})

-- Добавляем тогл Ambient с попапом
o.AmbientToggle = o.WorldSection:Toggle({
    name = "Ambient",
    default = false,
    flag = "world_ambient",
    callback = function(value)
        -- Сохраняем оригинальные настройки окружающего света при первом включении
        if not o.originalAmbientSettings then
            o.originalAmbientSettings = {
                Ambient = o.LS.Ambient
            }
        end
        
        if value then
            -- Применяем настройки окружающего света из флагов
            if Library.Flags["ambient_color"] then
                if type(Library.Flags["ambient_color"]) == "table" and Library.Flags["ambient_color"].c then
                    o.LS.Ambient = Library.Flags["ambient_color"].c
                else
                    o.LS.Ambient = Library.Flags["ambient_color"]
                end
            end
        else
            -- Восстанавливаем оригинальные настройки
            if o.originalAmbientSettings then
                o.LS.Ambient = o.originalAmbientSettings.Ambient
            end
        end
    end
})

-- Создаем попап для настроек окружающего света
o.AmbientPopup = o.AmbientToggle:Popup({size = 150})

-- Добавляем колорпикер для цвета окружающего света
o.AmbientPopup:Colorpicker({
    name = "AmbientColor",
    description = ">_<",
    default = Color3.fromRGB(0, 0, 0),
    flag = "ambient_color",
    callback = function(color)
        if Library.Flags["world_ambient"] then
            if type(color) == "table" and color.c then
                o.LS.Ambient = color.c
            else
                o.LS.Ambient = color
            end
        end
    end
})

-- Добавляем тогл ClockTime с попапом
o.ClockTimeToggle = o.WorldSection:Toggle({
    name = "ClockTime",
    default = false,
    flag = "world_clocktime",
    callback = function(value)
        -- Сохраняем оригинальные настройки времени при первом включении
        if not o.originalTimeSettings then
            o.originalTimeSettings = {
                ClockTime = o.LS.ClockTime,
                TimeOfDay = o.LS.TimeOfDay
            }
        end
        
        if value then
            -- Применяем настройки времени из флагов
            o.LS.ClockTime = Library.Flags["clocktime_value"] or 0
            
            -- Создаем соединение для обновления времени
            if not o.clockTimeConnection then
                o.clockTimeConnection = o.rs.Heartbeat:Connect(function()
                    if Library.Flags["world_clocktime"] and o.LS.ClockTime ~= Library.Flags["clocktime_value"] then
                        o.LS.ClockTime = Library.Flags["clocktime_value"] or 14
                    end
                end)
            end
        else
            -- Восстанавливаем оригинальные настройки
            if o.originalTimeSettings then
                o.LS.ClockTime = o.originalTimeSettings.ClockTime
                o.LS.TimeOfDay = o.originalTimeSettings.TimeOfDay
            end
            
            -- Отключаем соединение
            if o.clockTimeConnection then
                o.clockTimeConnection:Disconnect()
                o.clockTimeConnection = nil
            end
        end
    end
})

-- Создаем попап для настроек времени
o.ClockTimePopup = o.ClockTimeToggle:Popup({size = 150})

-- Добавляем слайдер для времени
o.ClockTimePopup:Slider({
    name = "Time",
    min = 0,
    max = 24,
    default = 0,
    float = 0.1,
    flag = "clocktime_value",
    callback = function(value)
        if Library.Flags["world_clocktime"] then
            o.LS.ClockTime = value
        end
    end
})

-- Добавляем тогл LightingType с попапом
o.LightingTypeToggle = o.WorldSection:Toggle({
    name = "LightingType",
    default = false,
    flag = "world_lightingtype",
    callback = function(value)
        -- Сохраняем оригинальные настройки типа освещения при первом включении
        if not o.originalLightingTypeSettings then
            o.originalLightingTypeSettings = {
                Technology = o.LS.Technology
            }
        end
        
        if value then
            -- Применяем настройки типа освещения из флагов
            o.common_vars.lightingType = Library.Flags["lightingtype_value"]
            
            if o.common_vars.lightingType == "Voxel" then
                o.LS.Technology = Enum.Technology.Voxel
            elseif o.common_vars.lightingType == "Legacy" then
                o.LS.Technology = Enum.Technology.Legacy
            elseif o.common_vars.lightingType == "ShadowMap" then
                o.LS.Technology = Enum.Technology.ShadowMap
            elseif o.common_vars.lightingType == "Future" then
                o.LS.Technology = Enum.Technology.Future
            end
        else
            -- Восстанавливаем оригинальные настройки
            if o.originalLightingTypeSettings then
                o.LS.Technology = o.originalLightingTypeSettings.Technology
            end
        end
    end
})

-- Создаем попап для настроек типа освещения
o.LightingTypePopup = o.LightingTypeToggle:Popup({size = 150})

-- Добавляем выпадающий список для типа освещения
o.LightingTypePopup:Dropdown({
    name = "Type",
    values = {"Voxel", "Legacy", "ShadowMap", "Future"},
    value = "Voxel",
    flag = "lightingtype_value",
    callback = function(value)
        if Library.Flags["world_lightingtype"] then
            if value == "Voxel" then
                o.LS.Technology = Enum.Technology.Voxel
            elseif value == "Legacy" then
                o.LS.Technology = Enum.Technology.Legacy
            elseif value == "ShadowMap" then
                o.LS.Technology = Enum.Technology.ShadowMap
            elseif value == "Future" then
                o.LS.Technology = Enum.Technology.Future
            end
        end
    end
})

-- WalkSpeed и JumpPower settings
moveSettings = {
    WalkSpeedEnabled = false,
    WalkSpeed = 16,
    JumpPowerEnabled = false,
    JumpPower = 50,
}

-- Добавляем хук метатаблицы для WalkSpeed и JumpPower
mt = getrawmetatable(game)
oldIndex = mt.__index
oldNewIndex = mt.__newindex
setreadonly(mt, false)

mt.__newindex = newcclosure(function(self, key, value)
    -- Проверка на WalkSpeed
    if key == "WalkSpeed" and moveSettings.WalkSpeedEnabled and self:IsA("Humanoid") then
        -- Если значение меньше установленного в настройках, заменяем его
        if value < moveSettings.WalkSpeed then
            value = moveSettings.WalkSpeed
        end
    end
    
    -- Проверка на JumpPower
    if key == "JumpPower" and moveSettings.JumpPowerEnabled and self:IsA("Humanoid") then
        -- Если значение меньше установленного в настройках, заменяем его
        if value < moveSettings.JumpPower then
            value = moveSettings.JumpPower
        end
    end
    
    return oldNewIndex(self, key, value)
end)

setreadonly(mt, true)

-- Добавляем WalkSpeed и JumpPower только для первой игры (не 71189885129233)
if game.PlaceId ~= 71189885129233 and tostring(game.PlaceId) ~= "71189885129233" then
    -- Добавляем WalkSpeed toggle в секцию движения
    WalkSpeedToggle = PlayerMovementSection:Toggle({
        name = "WalkSpeed",
        default = false,
        flag = "player_walkspeed",
        callback = function(v)
            moveSettings.WalkSpeedEnabled = v
            
            -- Обновляем WalkSpeed для текущего персонажа
            char = o.getChar()
            if char then
                hum = char:FindFirstChildOfClass("Humanoid")
                if hum then
                if v then
                        hum.WalkSpeed = moveSettings.WalkSpeed
                else
                        hum.WalkSpeed = 16 -- Стандартное значение
                    end
                end
            end
        end
    })

    WalkSpeedPopup = WalkSpeedToggle:Popup({size = 150})
    WalkSpeedPopup:Slider({
        name = "Speed",
        min = 16,
        max = 120,
        default = 16,
        float = 1,
        flag = "player_walkspeed_amount",
        callback = function(v)
            moveSettings.WalkSpeed = v
            
            -- Обновляем WalkSpeed для текущего персонажа если включен тогл
            if moveSettings.WalkSpeedEnabled then
                char = o.getChar()
                if char then
                    hum = char:FindFirstChildOfClass("Humanoid")
                    if hum then
                        hum.WalkSpeed = v
                    end
                end
            end
        end
    })

    -- Добавляем JumpPower toggle в секцию движения
    JumpPowerToggle = PlayerMovementSection:Toggle({
        name = "Jump Power",
        default = false,
        flag = "player_jumppower",
        callback = function(v)
            moveSettings.JumpPowerEnabled = v
            
            -- Обновляем JumpPower для текущего персонажа
            char = o.getChar()
            if char then
                hum = char:FindFirstChildOfClass("Humanoid")
                if hum then
                if v then
                        hum.JumpPower = moveSettings.JumpPower
                else
                        hum.JumpPower = 50 -- Стандартное значение
                    end
                end
            end
        end
    })

    JumpPowerPopup = JumpPowerToggle:Popup({size = 150})
    JumpPowerPopup:Slider({
        name = "Power",
        min = 30,
        max = 200,
        default = 50,
        float = 1,
        flag = "player_jumppower_amount",
        callback = function(v)
            moveSettings.JumpPower = v
            
            -- Обновляем JumpPower для текущего персонажа если включен тогл
            if moveSettings.JumpPowerEnabled then
                char = o.getChar()
                if char then
                    hum = char:FindFirstChildOfClass("Humanoid")
                    if hum then
                        hum.JumpPower = v
                    end
                end
            end
        end
    })
end

-- Anti-Inertia
AntiInertiaSettings = {
    Speed = {
        Ground = 0.3,
        Air = 0.3
    },
    NoInertia = true
}

PlayerMovementSection:Toggle({
    name = "Anti Inertia",
    default = false,
    flag = "player_anti_inertia"
})

-- Создаем отдельное соединение для Anti-Inertia
if o.antiInertiaConnection then
    o.antiInertiaConnection:Disconnect()
    o.antiInertiaConnection = nil
end

o.antiInertiaConnection = o.rs.Heartbeat:Connect(function()
    if not Library.Flags["player_anti_inertia"] then return end
    
    o.common_vars.char = o.getChar()
    if not o.common_vars.char then return end
    
    -- Проверяем наличие HumanoidRootPart более безопасно
    o.common_vars.hrp = o.common_vars.char:FindFirstChild(o.parts.HRP)
    if not o.common_vars.hrp or not o.common_vars.hrp:IsDescendantOf(game) then return end
    
    o.common_vars.hum = o.common_vars.char:FindFirstChildOfClass("Humanoid")
    if not o.common_vars.hum then return end
    
    -- Получаем направление движения
    o.common_vars.moveDir = o.common_vars.hum.MoveDirection
    
    if o.common_vars.moveDir.Magnitude > 0 then
        -- Определяем множитель скорости в зависимости от состояния (в воздухе или на земле)
        o.common_vars.speedMult = (o.common_vars.hum:GetState() == Enum.HumanoidStateType.Freefall or o.common_vars.hum:GetState() == Enum.HumanoidStateType.Jumping)
            and AntiInertiaSettings.Speed.Air or AntiInertiaSettings.Speed.Ground
        
        -- Вычисляем новую скорость
        o.common_vars.newVel = o.common_vars.moveDir * o.common_vars.speedMult * 50
        
        -- Применяем новую скорость с учетом настроек инерции
        if AntiInertiaSettings.NoInertia then
            -- Режим без инерции - мгновенное изменение скорости
            pcall(function()
                if o.common_vars.hrp and o.common_vars.hrp:IsDescendantOf(game) then
                    o.common_vars.hrp.Velocity = o.funcs.v3(o.common_vars.newVel.X, o.common_vars.hrp.Velocity.Y, o.common_vars.newVel.Z)
                end
            end)
        else
            -- Режим с инерцией - плавное изменение скорости
            pcall(function()
                if o.common_vars.hrp and o.common_vars.hrp:IsDescendantOf(game) then
                    o.common_vars.curVel = o.common_vars.hrp.Velocity
                    o.common_vars.hrp.Velocity = o.funcs.v3(
                        o.common_vars.curVel.X + (o.common_vars.newVel.X - o.common_vars.curVel.X) * 0.5,
                        o.common_vars.hrp.Velocity.Y,
                        o.common_vars.curVel.Z + (o.common_vars.newVel.Z - o.common_vars.curVel.Z) * 0.5
                    )
                end
            end)
        end
    elseif AntiInertiaSettings.NoInertia then
        -- Если нет движения и включен режим без инерции, обнуляем горизонтальную скорость
        pcall(function()
            if o.common_vars.hrp and o.common_vars.hrp:IsDescendantOf(game) then
                o.common_vars.hrp.Velocity = o.funcs.v3(0, o.common_vars.hrp.Velocity.Y, 0)
            end
        end)
    end
end)
